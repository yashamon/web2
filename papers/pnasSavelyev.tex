\documentclass[9pt,twocolumn,twoside,lineno]{pnas-new}
% Use the lineno option to display guide line numbers if required.
\usepackage{graphicx}
% \usepackage[parfill]{parskip}
\newenvironment{itquote}
  {\begin{quote}\itshape}
  {\end{quote}\ignorespacesafterend}
\newenvironment{itpars}
  {\par\itshape}
  {\par}
\usepackage[autostyle]{csquotes}
% \usepackage[
%     backend=bibtex,
%     % defernumbers=true,
%     style=numeric,
%     % autocite=plain, 
%     sorting=none,
%     % sortlocale=us_US,
%     % natbib=true,
%     url=true, 
%     doi=false,
%     eprint=true
% ]{biblatex}
% \addbibresource{~/workspacemodules/linkfeb2015.bib}
\usepackage[]{hyperref}
\hypersetup{
    colorlinks=true,
 }
\usepackage {appendix}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{hyperref} 
\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{color}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{indentfirst}
\usepackage[hmargin=3cm,vmargin=3cm]{geometry}
\usepackage[all, cmtip]{xy}
\numberwithin{equation}{section}
\newtheorem{thm}{Theorem} 
\newtheorem{axiom}[equation]{Axiom} 
\newtheorem{theorem}{Theorem} 
\newtheorem{proposition}[equation]{Proposition}
\newtheorem{lma}[equation]{Lemma} 
\newtheorem{lemma}[equation]{Lemma} 
\newtheorem{cpt}[equation]{Computation} 
\newtheorem{corollary}[equation]{Corollary} 
\newtheorem{clm}[equation]{Claim} 
\newtheorem{experimental}{Experimental Hypothesis}
\newtheorem{conjecture}{Conjecture}
\newtheorem{condition}{Condition}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{definition}[equation]{Definition}
\theoremstyle{definition}
% \newtheorem{definition}[equation]{Definition}
\newtheorem{ft}{Fact}
\newtheorem{notation}{Notation}
\newtheorem{descr}{Description}[equation]

\theoremstyle{remark}
\newtheorem*{pf}{Proof}
\newtheorem*{pfs}{Proof (sketch)}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{question}{Question}

% \newcommand{\R}{{\mathbb{R}}}
% \newcommand{\Z}{{\mathbb{Z}}}
% \newcommand{\C}{{\mathbb{C}}}
% \newcommand{\Q}{{\mathbb{Q}}}
% \newcommand{\D}{{\mathbb{D}}}
% \newcommand{\HH}{{\mathbb{H}}}

\newcommand{\bs}{\bigskip}
\newcommand{\ra}{\rightarrow}
\newcommand{\del}{\partial}
\newcommand{\ddel}[1]{\frac{\partial}{\partial{#1}}}
\newcommand{\sm}[1]{C^\infty(#1)}

\newcommand{\delbar}{\overline{\partial}}
\newcommand{\Sum}{\Sigma}
% \newcommand{\G}{\mathcal{G}}
\newcommand{\Pe}{\mathcal{P}}
\newcommand{\X}{\mathfrak{X}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\K}{\mathcal{K}}

\newcommand{\ZZ}{\mathcal{Z}}
\newcommand{\eL}{\mathcal{L}}

\newcommand{\mone}{{-1}}
\newcommand{\st}{{^s_t}}
\newcommand{\oi}{_0^1}
\newcommand{\intoi}{\int_0^1}
\newcommand{\til}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\arr}[1]{\overrightarrow{#1}}
\newcommand{\paph}[1]{\{ #1 \}_{t=0}^1}
\newcommand{\con}{\#\;}
\newcommand{\codim}{\text{codim}}
\newcommand {\ham} {\text{Ham} (M, \omega)}
\newcommand {\isom} {\text{Isom} ^{h}  (M, \omega, j)}
\newcommand {\lham} {lie \text{Ham} (M, \omega)}
\newcommand {\hamcp} {\text{Ham} (\mathbb{CP} ^{r-1}, \omega )}
\newcommand{\overbar}{\overline}
\newcommand {\vM} {{(T^*)} ^{vert} \cM}
\newcommand{\om}{\omega}
\newcommand{\al}{\alpha}
\newcommand{\la}{\lambda}
\newcommand{\Om}{\Omega}
\newcommand{\ga}{\gamma}
\newcommand{\eps}{\epsilon}
\newcommand{\Cal}{\tex{Cal}}

\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\cJ}{\mathcal{J}}

%\newcommand{\cO}{\mathcal{O}}
\newcommand{\cS}{\mathcal{S}}

\newcommand{\cU}{\mathcal{U}}

\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cM}{\bm{M}}
\newcommand{\cP}{\bm{P}}
\newcommand{\cL}{\bm{L}}

\newcommand{\fS}{\mathfrak{S}}
\newcommand{\fk}{\mathfrak{k}}
\newcommand{\fg}{\mathfrak{g}}
% \newcommand{\fz}{\mathfrak{z}}
\newcommand{\fZ}{\mathfrak{Z}}
\newcommand\vol{\operatorname{vol}}
\newcommand {\hatcp}{\widehat{\mathbb {CP}} ^{r-1} }
\newcommand{\rJ}{\mathrm{J}}
\newcommand{\rB}{\mathrm{B}}
\newcommand{\rT}{\mathrm{T}}
\newcommand {\Hpm} {\mathcal{H}^{\pm}}
\newcommand{\bP}{\mathbb{P}}

\DeclareMathOperator {\period} {period}
\DeclareMathOperator {\sign} {sign}
\DeclareMathOperator {\Id} {Id}
\DeclareMathOperator {\floor} {floor}
\DeclareMathOperator {\ceil} {ceil}
\DeclareMathOperator {\mult} {mult}
\DeclareMathOperator {\Symp} {Symp}
\DeclareMathOperator {\Det} {Det}
\DeclareMathOperator {\comp} {comp}
\DeclareMathOperator {\growth} {growth}
\DeclareMathOperator {\energy} {energy}
\DeclareMathOperator {\Reeb} {Reeb}
\DeclareMathOperator {\Lin} {Lin}
\DeclareMathOperator {\Diff} {Diff}
\DeclareMathOperator {\fix} {fix}
% \newcommand{\M}{\mathbb{CP} ^{r-1} }
\DeclareMathOperator {\grad} {grad}
\DeclareMathOperator {\area} {area}
\DeclareMathOperator {\diam} {diam}
% \DeclareMathOperator {\rank} {rank}
\DeclareMathOperator {\dvol} {dvol}
\DeclareMathOperator {\quant} {Quant}
\DeclareMathOperator {\ho} {ho}
\DeclareMathOperator {\length} {length}
\DeclareMathOperator {\Proj} {P}
\renewcommand{\i}{\sqrt{-1}}
\DeclareMathOperator{\mVol}{\mathrm{Vol}(M_0,\omega_0)}
\DeclareMathOperator{\Lie}{\mathrm{Lie}}
\DeclareMathOperator{\lie}{\mathrm{lie}}
\DeclareMathOperator{\op}{\mathrm{op}}
\DeclareMathOperator{\rank}{\mathrm{rank}}
\DeclareMathOperator{\ind}{\mathrm{ind}}
\DeclareMathOperator{\trace}{\mathrm{trace}}
\DeclareMathOperator{\image}{\mathrm{image}}
\DeclareMathOperator{\Sym}{\mathrm{Sym}}
\DeclareMathOperator{\Ham}{\mathrm{Ham}}
\DeclareMathOperator{\Aut}{\mathrm{Aut}}
\DeclareMathOperator{\Quant}{\mathrm{Quant}}
\DeclareMathOperator{\Fred}{\mathrm{Fred}}
\DeclareMathOperator{\id}{\mathrm{1}}
\DeclareMathOperator{\lcs}{l.c.s.}
\DeclareMathOperator{\lcsm}{l.c.s.m.}
% \DeclareMathOperator{\ker}{ker}
\DeclareMathOperator{\coker}{coker}

\templatetype{pnasresearcharticle} % Choose template 
% {pnasresearcharticle} = Template for a two-column research article
% {pnasmathematics} %= Template for a one-column mathematics article
% {pnasinvited} %= Template for a PNAS invited submission

\title{Non computability of human intelligence}

% Use letters for affiliations, numbers to show equal authorship (if applicable) and to indicate the corresponding author
\author{Yasha Savelyev}
\affil{Universidad de Colima, Facultad de sciencias, Bernal DÃ­az del Castillo 340
Col. Villas San Sebastian,
28045, Colima, Colima,
Mexico}
% \affil[b]{Affiliation Two}
% \affil[c]{Affiliation Three}
% Please give the surname of the lead author for the running footer
% \leadauthor{Sasv} 

% Please add here a significance statement to explain the relevance of your work
\significancestatement{We show that either human intelligence is not computable in Turing's model of computation - on which modern computer science is based, or human reasoning is fundamentally unsound, the meaning of which is partly discussed here.
If the former holds, then in particular this implies existence of absolutely non Turing computable physical processes in nature, where ``absolutely'' means independently of any specific physical model. Although this does not obviously put limits on the power of artificial intelligence, it does put certain, if only theoretical, limits on Turing artificial intelligence imitating human intelligence. 
% The main idea is to resolve meta-logical issues with the well known Lucas-Penrose argument, by constructing an analogue of G\"odel statement directly, rather than appealing to G\"odel incompleteness theorem.
}

% Please include corresponding author, author contribution and author declaration information
% \authorcontributions{Please provide details of author contributions here.}
% \authordeclaration{Please declare any conflict of interest here.}
% \equalauthors{\textsuperscript{1}A.O.(Author One) and A.T. (Author Two) contributed equally to this work (remove if not applicable).}
\correspondingauthor{\textsuperscript{2}To whom correspondence should be addressed. E-mail: yasha.savelyev\@gmail.com} 
% Keywords are not mandatory, but authors are strongly encouraged to provide them. If provided, please include two to five keywords, separated by the pipe symbol, e.g:
\keywords{Turing machines $|$ Mind and machine relations $|$ Analogues of G\"odel statements} 
\begin{abstract}
We revisit the question (most famously) initiated by Turing: can human intelligence be completely modeled by a Turing machine?  
We show that either the answer is \emph{no}, or human reasoning is fundamentally unsound. In particular, under the soundness hypothesis, we show that at least some meaningful thought processes of the brain cannot be Turing computable. And so some physical processes are absolutely not Turing computable, in any theoretical physical model, which is not entirely expected. 
The main idea is to resolve certain meta-logical issues with the well known Lucas-Penrose argument by constructing an analogue of G\"odel statement directly, rather than appealing to G\"odel incompleteness theorem. The main argument is entirely based on the language of Turing machines, which is relatively elementary and should be generally accessible.

   % There are some similarities of our argument with the well known Lucas-Penrose argument, but we work purely on the level of Turing machines, and do not use G\"odel's incompleteness theorem or any direct analogue. Instead, starting with a slightly strengthened computability hypothesis, we construct directly and use a weak analogue of a G\"odel statement for a certain system which involves our human, this allows us to side-step some (possible) meta-logical issues with their argument.  
\end{abstract}

\dates{This manuscript was compiled on \today}
\doi{\url{www.pnas.org/cgi/doi/10.1073/pnas.XXXXXXXXXX}}

\begin{document}

\maketitle
\thispagestyle{firststyle}
\ifthenelse{\boolean{shortarticle}}{\ifthenelse{\boolean{singlecolumn}}{\abscontentformatted}{\abscontent}}{}

% If your first paragraph (i.e. with the \dropcap) contains a list environment (quote, quotation, theorem, definition, enumerate, itemize...), the line after the list may have some extra indentation. If this is the case, add \parshape=0 to the end of the list environment.
% \dropcap{T}his PNAS journal template is provided to help you write your work in the correct journal format.  Instructions for use are provided below. 
%
% Note: please start your introduction without including the word ``Introduction'' as a section heading (except for math articles in the Physical Sciences section); this heading is implied in the first paragraphs. 
\begin{question} \label{quest1}
 Can human intelligence  be completely modelled by a Turing machine?  
\end{question}
% We will give a complete definition of a Turing machine after the introduction.
An informal definition of a 
Turing machine (see \cite{TuringComputableNumbers}) is as follows: 
it is an abstract machine which accepts certain inputs, and produces outputs. The outputs are determined from the inputs by a fixed finite algorithm, in a specific sense.
In particular anything that can be computed by computers as we know them can be computed by a Turing machine. 

For the purpose of the main result the reader may simply understand a Turing machine as  a digital computer with unbounded memory running a certain program. Unbounded memory is just mathematical convenience, it can in specific arguments, also of the kind we make, be replaced by non-explicitly bounded memory.

Turing himself has started on a form of Question 1 in his Computing machines and Intelligence, \cite{TuringComputingMachines}, where he also informally outlined a  possible obstruction to a yes answer coming from G\"odel's incompleteness theorem. For the incompleteness theorem to play a role we need some assumption on the fundamental soundness of human reasoning.
 What the latter actually means in practice is subject to a lengthy discussion. We need some qualifier like ``fundamental'' as even mathematicians do not on the surface assert consistent statements at all times.  At the moment it should be understood as follows: we make inconsistent assertions not because these are expressions of fundamental internal inconsistencies of our mental constructions, but because the noisy, faulty biological nature of our brain leads to interpretation errors of these mental constructions. Here by faulty, we mean the possibly common occurrence of faults in brain processes, coming from things like cell death, signaling noise between neurons, etc., even if the brain may have robust fault protections built in.


% If humans are indeed fundamentally unsound then so be it, however no accepted argument for the above alternative exists, and the goal of this paper is to fill this gap.

G\"odel himself first argued for a no answer in \cite[310]{citeGodel}.
Later Lucas \cite{citeLucas}  and later again and more robustly Penrose \cite{citePenroseEmperor} argued for a no answer.

They further formalized and elaborated the obstruction coming from G\"odel's incompleteness theorem. And they reject the possibility that humans could be unsound on a fundamental level, as does G\"odel but for him it is apparently not even a possibility, it does not  seem to be stated in \cite{citeGodel}. \footnote {It is likely most mathematicians would sympathize with G\"odel, after all mathematics is meaningless if mathematicians are fundamentally unsound - for then they must eventually assert everything to be true.} % For disclosure this author does believe in consistency of human beings, but to me consistency always seemed to be an emergent feature of something deeper, (consciousness perhaps).  The main common objections to their argument concern the meta-logic of the argument, see for instance \cite{citeChalmers}, \cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}.
 


It should also be noted that for Penrose in particular, non-computability of intelligence is evidence for new physics, and he has specific and \emph{very} intriguing proposals with Hameroff \cite{citeHAMEROFF201439}, on how this can take place in the human brain.  Here is a partial list of some partially related work on mathematical models of brain activity and or quantum collapse models: \cite{cite:Quanta}, \cite{citeKremnizer2015}, \cite{citeHoffmanAgents}, \cite{cite:GrindfordConsciousnessPerspective}.

The following is a slightly informal version of our main Theorem \ref{thm:2}.
\begin{theorem} \label{thm:1} Either there are meaningful, non Turing computable processes in the human brain,   or human beings are fundamentally unsound, in fact the actual soundness condition needed is very weak.
   Moreover, in case of the former, some specific real world (intelligent) behavior of a fixed human being cannot be simulated by a fixed Turing machine.  \end{theorem}
In a sense the above theorem is nothing more then confirmation of the original intuition of Turing, except our argument is different from what he appeared to intend. Broadly interpreted this is a theorem in computer science. But the immediate implications and context are in mathematical physics and in part biology,  and philosophy. For even existence of non Turing computable processes in nature is not known. For example we expect beyond reasonable doubt that solutions of Navier-Stokes equations or $N$-body problems are generally non Turing computable, (over $\mathbb{Z}$, if not over $\mathbb{R}$ cf. \cite{citeBlumShubSmalen}), as modeled in essentially classical mechanics.  But in a more physically accurate and fundamental model these may both become computable, (possibly if the nature of the universe is ultimately discreet.) Our theorem says that either there are absolutely, that is model independent, non-computable processes in physics, in fact in the functioning of the brain, or human beings are fundamentally unsound, which is a mathematical condition on the functioning of the human brain. Despite the partly physical context the technical methods of the paper are mainly of mathematics and computer science, as we need very few physical assumptions.  \subsection*{Outline of the main idea of the G\"odelian attack}
What follows will be very close in essence to the argument Penrose gives in \cite{citePenroseShadows}, which we take to be his main and final argument, (as far as I am aware). However we partially reinterpret to be closer to our argument later on. While this outline uses some of the language of formal systems, except for some supplementary remarks, we will \emph{not} use it in our actual argument, which is based purely on the language of Turing machines, and is more elementary. 
% In what follows we refer to some language of abstract formal systems but none of this appears in the main argument, as our language will be purely that of Turing machines. 
% It will be instructive to first give a preliminary version of the Penrose argument, in our language, and see what goes wrong. But to emphasize this is \emph{not} his argument, (which is more sophisticated.) 


Let $P$ be a human subject, which we understand as a machine printing statements in arithmetic, given some input. That is for each $\Sigma$ some string input in a fixed alphabet, $P (\Sigma)$ is a statement in arithmetic, e.g.
Fermat's last theorem. Say now $P$ is in contact with experimenter/operator $E$. The input string $\Sigma$ that $E$ gives $P$ is the following: 
\begin{itquote}
Here is a specification of a Turing machine $T$,  print your statement that you assert to be true assuming $\Theta _{T} $:
\begin{equation} \label{eq:condition}
T \text{ computes } P.
\end{equation}
\end{itquote}
  
   Before we proceed, we put the condition on our $P$ that he asserts himself to be fundamentally sound.
  % , which in the current setting means that is he asserts $P (\Sigma)$ is true conditionally on $\Theta _{T} $ for all $\Sigma$.  To emphasize this is not an assumption by $P$, but is what $P$ asserts as \emph{truth}.  
% Now $P$ replies: 
% \begin{itquote}
% I know I am sound,  hence $T$ must be sound if it computes me, but I can then construct a G\"odel statement $G (T)$ for $T$, which is then a true statement in arithmetic, and which indirectly asserts ``$T$ cannot print $G (T)$''.  
% \end{itquote}
% This alone doesn't quite work however for $E$ counters: 
% \begin{itquote}
% I see, but do \emph{you} in fact in print $G (T)$? This is the only way you can presently reach a contradiction, as $T$ only computes what you print, not what you can meta-prove.
% \end{itquote}
%  $P$ has to say no! Because he does not in fact know $G (T)$ is true, since he has to know that $T$ is sound, and this only happens (from his point of view) if he knew for a fact: $T$ computes $P$. If $P$ does print $G (T)$ then he is patently unsound, as he has no basis to assert $G (T)$, so his very belief that he is sound would be absurd.  
% \subsubsection* {A possible fix} (Outline)
% We can try to fix the above argument as outlined in the following, and 


Now $P$ reasons that since he is fundamentally sound, so that his deductions based on $\Theta _{T} $ are sound, the same must be true of $T$. On the other hand, as is well known the statements $T (\Sigma)$, must be provable statements in a certain  formal system $\mathcal{F} (T)$ associated to $T$.
Then (perhaps) there is a conditional G\"odel statement $G (T, \Theta _{T} )$, which is true if $\mathcal{F}(T)+\Theta _{T} $ is consistent and indirectly asserts that $T$ cannot print $G(T,\Theta _{T}) $. Here $\mathcal{F} (T)+\Theta _{T} $ denotes $\mathcal{F} (T)$ adjoined with the assertion $\Theta _{T} $ as an axiom.  $P$ then prints $G (T, \Theta _{T} )$. 
Now if $\Theta _{T} $ is true, and $P$ is indeed sound and hence $T$ is sound,  then $T$ cannot print $G (T, \Theta _{T} )$. So we reach a contradiction, unless $P$ is not in fact sound. 

The above outline is not totally satisfactory. For one we need to show that conditional G\"odel statements as above can be constructed  (by $P$). At the least this requires that $\Theta _{T} $ be interpreted as a statement in a suitable formal system (containing arithmetic).
For this we need $P$ to be suitably defined/formalized,  otherwise it is not clear how the interpretation of $\Theta _{T} $ as a statement could work, but we delve no further. A full critique of the Penrose argument, is given in Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}, see also 
 Penrose~\cite{citePenroseBeyondShadow}, and Chalmers~\cite{citeChalmers} for discussions on related issues.  
 
This note can be understood as a non-literal elaboration of the above  argument, but with additional changes and improvements. First we do not need our subject of this paper, henceforth denoted by  $S$, to be totally sound; we only need soundness of a certain much more limited function associated to $S$. Moreover, we do not need $S$ to explicitly construct G\"odel statements, for we directly find in this context an elementary and explicit analogue, a kind of weak G\"odel statement and this suffices for $S$. Thus G\"odel incompleteness theorem is not used at all.

However, to construct our ``weak G\"odel statement'' directly, we still need 
to formalize at least partly some necessary properties of $S$. To this end we need to work with a slightly stronger form of Turing computability of  $S$, although physically it is only trivially stronger.
 Roughly speaking for us computability means that not only are the answers of $S$ computable by a Turing machine $T$, but also that the brain of $S$ is physically simulating this $T$ to arrive at the answers. (The actual condition we use is more elementary and explicit.)  
 
 
  So we solve the problem above, in the ``fixed argument'',  of formalization of \eqref{eq:condition}, by avoiding direct use of G\"odel incompleteness theorem, and by defining/formalizing our subject $S$ just enough so that a direct construction of the ``weak G\"odel statement'' goes through. This requires a slightly stronger computability condition. In particular we are not immediately at odds with analysis in \cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4} of the argument of Penrose.

% Note however that we will work work almost purely with the language of Turing machines, as opposed to formal systems, so that this description of the overall strategy is only a partial translation to the language of formal systems.  We will only use some language of formal systems in supplementary remarks, as it is powerful for intuition.


Working with Turing machines, has at least one advantage of being technically
more
elementary and concrete compared to working with formal systems. In particular the above mentioned
weak G\"odel statement is formulated purely in the language
of Turing machines - as a property of a certain hypothetical Turing machine. 

As a final remark, technically the paper is mostly elementary and should be widely readable, in entirety.


\section {Some preliminaries} \label{sec:prelims}
This section can be just skimmed on a first reading.
Really what we are interested in is not Turing machines per se, but computations that can be simulated by Turing machine computations. These can for example be computations that a mathematician performs with paper and pencil, and indeed is the original motivation for Turing's specific model. However to introduce Turing computations we need Turing machines, here is our version, which is a computationally equivalent, minor variation of Turing's original machine.
\begin{definition} \label{def:Machine} A \textbf{\emph{Turing machine}} $M$ consists of:
  \begin{itemize} 
     \item Three infinite (1-dimensional) tapes $T _{i}, T _{o}, T _{c}   $, divided into discreet cells, one next to each other. Each cell contains a symbol from some finite alphabet. A special symbol $b$ for blank, (the only symbol which may appear infinitely many often).
     \item Three  heads $H _{i}, H _{o}, H _{c}   $ (pointing devices),  $H _{i} $ can read each cell in $T _{i} $ to which it points, $H _{o}, H _{c}  $ can read/write each cell in $T _{o}, T _{c}  $ to which it points.
        The heads can then move left or right on the tape.
     \item A set of internal states $Q$, among these is ``start'' state $q _{0} $. And a non-empty set $F$ of final, ``finish'' states.
\item Input string $\Sigma$, the collection of symbols on the tape $T _{i} $, so that to the left and right of $\Sigma$ there are only symbols $b$. We assume that in state $q _{0} $, $H _{i} $ points to the beginning of the input string, and that the $T _{c} $, $T _{o} $ have only $b$ symbols.
\item A finite set of instructions $I$ that given the state $q$ the machine is in currently, and given the symbols the heads are pointing to, tells $M$ to do the following, the taken actions 1-3 below will be (jointly) called an \textbf{\emph{executed instruction set}}, or just \textbf{\emph{step}}:
\begin{enumerate} \label{enumerate}
   \item Replace symbols with another symbol in the cells to which the heads $H _{c}, H _{o}  $ point (or leave them).
   \item Move each head $H _{i}, H _{c}, H _{o}   $ left, right, or leave it in place, (independently).
   \item Change state $q$ to another state or keep it.
\end{enumerate}
\item Output string $\Sigma _{out} $,  the collection of symbols on the tape $T _{o} $, so that to the left and right of $\Sigma$ there are only symbols $b$, when the machine state is final. When the internal state is one of the final states we ask that the instructions are to do nothing, so that these are frozen states.  
  \end{itemize} 
\end{definition}
We also have the following minor variations on standard definitions, and notation.
\begin{definition} A \textbf{\emph{complete configuration}} of a Turing machine $M$ or \textbf{\emph{total state}} is the collection of all current symbols on the tapes, position of the heads, and current internal state. A \textbf{\emph{Turing computation}}, or \textbf{\emph{computation sequence}} for $M$ is a possibly not eventually constant sequence $$\{s _{i} \} _{i=0} ^{i=\infty}: = * M (\Sigma)    $$  of complete configurations of $M$,  determined by the input $\Sigma$ and $M$,  with $s _{0}  $ the initial configuration whose internal state is $q _{0} $. If elements of $\{s _{i} \} _{i=0} ^{i=\infty}$ are eventually in some final machine state, so that the sequence is eventually constant, then we say that the computation \textbf{\emph{halts}}.
   For a given Turing computation $* M (\Sigma)$, we shall write 
   \begin{equation*}
   * M (\Sigma) \to x, 
   \end{equation*}
if $* M (\Sigma)$ halts and $x$  is the output string. 
\end{definition}
We write $M (\Sigma)$ for the output string of $M$, given the input string $\Sigma$, if the associated Turing computation $*M (\Sigma)$  halts. 

\begin{definition} Let $Strings$ denote the set of all finite strings of symbols in some fixed finite alphabet, for example $\{0,1\}$.
Given a partially defined function $f: Strings \to Strings$, that is a function defined on some subset of $Strings$ - we say that a Turing machine $M$ \textbf{\emph{computes}} $f$ if  $*M (\Sigma) \to f (\Sigma)$,  whenever $f (\Sigma)$ is defined.
\end{definition}
For writing purposes, let us call a partially defined function $f: Strings \to Strings$ as above an \textbf{\emph{operator}}.
 So a Turing machine $T$ itself determines an operator, which is defined on all $\Sigma \in Strings$ s.t. $*T (\Sigma)$ halts, by $\Sigma \mapsto T (\Sigma)$.  
The following definition is also purely for writing purposes.
\begin{definition} \label{def:equivalent} Given Turing computations (for possibly distinct Turing machines) $*T _{1} (\Sigma _{1} ) $, $* T _{2} (\Sigma _{2} ) $ we say that they are \textbf{\emph{equivalent}} if either they both halt with the same output string, or both do not halt. 
   % We say a pair of Turing machines $T _{1}, T _{2}  $  are \textbf{\emph{equivalent}} if they compute the same operator.
\end{definition} 
In practice we will allow our Turing machine $T$ to reject some elements of $Strings$ as valid input. We may formalize this by asking that there is a special final machine state $q _{reject} $, so that $T (\Sigma)$ halts with $q _{reject} $ for $$\Sigma \notin {I} \subset Strings,$$ where ${I}$ is some set of all valid, that is $T$-\textbf{\emph{permissible}} input strings. Note, we do not ask that for $\Sigma \in I$ $*T (\Sigma)$ halts. If $*T (\Sigma)$ does halt then we shall say that $\Sigma$ is \textbf{\emph{acceptable}}.
It will be convenient to forget $q _{reject} $ and instead write $$T: {I} \to O,$$ where ${I} \subset Strings$ is understood as the subset of all $T$-permissible strings, and $O$ is the set output strings, keeping all other data implicit. The specific interpretation should be clear in context.

All of our input, output sets are understood to be subsets of $Strings$ under some encoding. For example if the input set is $Strings ^{2} $, we may encode it as a subset of $Strings$ via encoding of the type: ``this string $\Sigma$ encodes an element of $Strings ^{2} $ its components are $\Sigma _{1}$ and $\Sigma _{2}  $.'' 
In particular the sets of integers $\mathbb{N}, \mathbb{Z}$ 
will under some encoding correspond to subsets of $Strings$. However it will be often convenient to refer to input, output sets abstractly without reference to encoding subsets of $Strings$. (Indeed this is how computer languages work.) \begin{remark} The above elaborations mostly just have to do with minor set theoretic issues. For example we will want to work with some ``sets'' $\mathcal{T}$ of Turing machines, with some abstract sets of inputs and outputs. These ``sets'' $\mathcal{T}$ will truly be sets if implicitly all these abstract sets of inputs and outputs are encoded as subsets of $Strings$. \end{remark}
\begin{definition}  We say that a Turing machine $T$ computes an operator
$f: Strings \to Strings$  on $A \subset Strings$ if $A$ is contained in the subset $I$ of $T$-permissible strings, and $*M (\Sigma) \to f (\Sigma)$,  whenever $f (\Sigma)$ is defined, for $\Sigma \in A$.
\end{definition} 

Given Turing machines $$M _{1}: {I} \to {O}, M _{2}: {J} \to {P},$$ where ${O} \subset {J}$, we may naturally \textbf{\emph{compose}} them to get a Turing machine $M_2 \circ M _{1} $, let us not elaborate as this should be clear, we will use this later on.
\subsection {Join of Turing machines}
Our Turing machine of Definition \ref{def:Machine} is a multi-tape enhancement of a more basic notion of a Turing machine with a single tape,
but we need to iterate this further.  

We replace a single tape by tapes $T ^{1}, \ldots, T ^{n}  $
in parallel, which we denote by $(T ^{1} \ldots T ^{n})$ and call this $n$-tape.
The head $H$ on the $n$-tape has components $H ^{i} $ pointing on the corresponding tape $T ^{i} $. When moving a head we move all of its components separately. A string of symbols on $(T ^{1} \ldots T ^{n})$ is an $n$-string, 
formally just an element $\Sigma \in Strings ^{n} $, with $i$'th component of $\Sigma$
specifying a string of symbols on $T ^{i} $. The blank symbol $b$ is the symbol $(b ^{1}, \ldots, b ^{n} )$  with  $b ^{i} $ blank symbols of $T ^{i} $.









Given Turing machines $M _{1}, M _{2}  $ we can construct what we call a \textbf{\emph{join}} $M _{1} \star M _{2}  $, which is roughly  a Turing machine where we alternate the operations of $M _{1}, M  _{2}  $. In what follows symbols with superscript $1,2$ denote the corresponding objects of $M _{1} $, respectively $M _{2} $, cf. Definition \ref{def:Machine}. 
 

$M _{1} \star M _{2}  $ has three (2)-tapes: $$(T ^{{1} } _{i}  T ^{{2} } _{i}),    (T ^{{1} } _{c}  T ^{{2} } _{c}  ), (T ^{{1} } _{o}  T ^{2}  _{o} ),   $$ three heads $H _{i}, H _{c}, H _{o}   $ which have component heads $H ^{j} _{i}, H ^{j} _{c}, H ^{j} _{o}      $, $j=1,2$. It has machine states: $$Q _{M _{1} \star M _{2}  }   = Q ^{1} \times Q ^{2} \times \mathbb{Z}_{2},  $$ with initial state $(q _{0} ^{1}, q _{0} ^{2},0)$ and final states:
$$F _{M _{1} \star M _{2}  } = F ^{1} \times Q ^{2} \times \{1\} \sqcup Q ^{1} \times F ^{2} \times \{0\}.  $$
Then given machine state $q=(q ^{1}, q ^{2}, 0)$ and the symbols $(\sigma _{i} ^{1} \sigma _{i} ^{2}), (\sigma _{c} ^{1} \sigma _{c} ^{2}), (\sigma _{o} ^{1} \sigma _{o} ^{2})      $ to which the heads $H _{i}, H _{c}, H _{o}   $ are currently pointing, we first check instructions in $I ^{1} $ for $q ^{1} $, $ \sigma _{i} ^{1} ,  \sigma _{c} ^{1}, \sigma _{o} ^{1}    $, and given those instructions as step 1 execute:
\begin{enumerate}
 \item Replace symbols $\sigma ^{1}  _{c}, \sigma ^{1}  _{o}  $ to which the head components $H ^{1}  _{c}, H ^{1}  _{o}  $ point (or leave them in place, the second components are unchanged). 
 \item Move each head component $H ^{1}  _{i}, H ^{1}  _{c}, H ^{1}  _{o}   $ left, right, or leave it in place, (independently). (The second component of the head is unchanged.)
   \item Change the first component of $q$ to another or keep it. (The second component is unchanged.) The third component of $q$ changed to $1$.
\end{enumerate} 
Then likewise given machine state $q=(q ^{1}, q ^{2}, 1)$,  we check instructions in $I ^{2} $ for $q ^{2} $, $ \sigma _{i} ^{2} ,  \sigma _{c} ^{2}, \sigma _{o} ^{2}$ and given those instructions as step 2 execute:
\begin{enumerate}
 \item Replace symbols $\sigma ^{2}  _{c}, \sigma ^{2}  _{o}  $ to which the head components $H ^{2}  _{c}, H ^{2}  _{o}  $ point (or leave them in place, the first components are unchanged). 
   \item Move each head component $H ^{2}  _{i}, H ^{2}  _{c}, H ^{2}  _{o}   $ left, right, or leave it in place.
\item Change the second component of $q$ to another or keep it, (first component is unchanged) and change the last component to $0$.
\end{enumerate} 
Thus formally  the above 2-step procedure is two consecutive executed instruction sets in $M _{1} \star M _{2}  $. Or in other words it is two terms of the computation sequence.
\subsubsection {Input}
The input for $M _{1} \star M _{2}  $ is a 2-string or in other words pair $(\Sigma _{1}, \Sigma _{2}  )$, with $\Sigma _{1} $ an input string for $M _{1} $, and $\Sigma _{2} $ an input string for $M _{2} $.
\subsubsection {Output} The output for $$*M _{1} \star M _{2} (\Sigma _{1}, \Sigma _{2}  )  $$ is defined as follows. If this computation halts then the 2-tape $(T ^{1} _{o} T ^{2} _{o}    )$ contains a 2-string, bounded by $b$ symbols, with $T ^{1} _{o}  $ component $\Sigma ^{1} _{o}$ and $T ^{2} _{o}  $ component $\Sigma ^{2} _{o}$.
Then the output $M _{1} \star M _{2} (\Sigma _{1}, \Sigma _{2}  )$ is defined to be $\Sigma ^{1} _{o}  $ if the final state is of the form $(q _{f},  q, 1) $ for $q _{f} $ final, or $\Sigma ^{2} _{o}  $ if the final state is of the form $(q,  q _{f},0) $, for $q _{f} $ likewise final. Thus for us the output is a 1-string on one of the tapes.  
\subsection {Generalized join}
A natural variant of the above join construction $M _{1} \star M _{2}  $, is to let $M _{1} $ component of the machine execute $a$ times before going to step 2 and then execute $M _{2} 
$ component of the machine $b$ times, then repeat, for $a,b \in \mathbb{N}$. This results in $a+b$ consecutive terms of the corresponding computation sequence.
We denote this generalized join by  $$M _{1} ^{a} \star M _{2} ^{b},    $$ so that $$M_1 ^{1} \star M ^{1}  _{2}   = M _{1} \star M _{2},   $$
where the latter is as above.  We will also abbreviate: $$M _{1} \star M _{2} ^{b}:=   M _{1} ^{1} \star M _{2} ^{b}.
$$ 
The set of machine states $M _{1} ^{a} \star M _{2} ^{b}    $ is then $Q ^{1} \times Q ^{2} \times \mathbb{Z} _{a+b}   $. Let us leave out further details as this construction is analogous to the one above.
\subsection {Universality} It will be convenient to refer to the universal Turing machine $U$. This is a Turing machine already appearing in Turing's \cite{TuringComputableNumbers}, that accepts as input a pair $(T,\Sigma)$ for $T$ an encoding of a Turing machine and $\Sigma$ input to this $T$. It can be partially characterized by the property that for every Turing machine $T$ and $\Sigma$ input for $T$ we have:
\begin{equation*}
   *T (\Sigma) \text{ is equivalent to } *U (T,\Sigma).
\end{equation*}
\subsection {Notation}
In what follows $\mathbb{Z}$ is the set of all integers and $\mathbb{N}$ non-negative integers. We will often specify a Turing machine simply by specifying an operator $$T: {I} \to {O},$$ with the full data of the underlying Turing machine being implicitly specified, in a way that should be clear from context.
\section {Setup for the proof of Theorem \ref{thm:1}}
% The reader may want to have a quick look at preliminaries before reading the following to get a hold of our notation and notions.
Our subject is a human called $S$, also sometimes referred to by \textbf{\emph{physical}} $S$ to avoid confusion with similarly named operators.
%
% however this (possibly with decorations) may also denote in what follows certain functions or operators in the language of the previous section, associated to $S$. Sometimes to avoid confusion we differentiate the two by calling the former 
%
% \textbf{\emph{physical}} $S$.
% Our first order of business is describing how to associate such operators.
We intend to restrict our $S$ to interpret and reply to certain string input, while in a isolated environment. This means first that no information i.e. stimulus,
that is not explicitly controlled and that is usable by $S$, passes to $S$ while he is in this environment. 
% The idea is then that we pass verbally or otherwise a string to $S$ and wait for his reply. One thing to keep in mind is that $S$'s reply may depend on his mental state, where the latter is used in a colloquial sense.
% In the absence of any meaningful external stimuli, we may more simply say that $S$'s answer may depend on the time that the question is being asked. 
If time is relative time measured in $\mathbb{R} _{\geq 0} $,  then
we may associate to $S$ an operator: 
\begin{equation*}
   S: Strings \times \mathbb{R} _{\geq 0}  \to Strings,
\end{equation*}
% such that $S (\Sigma, t)$ is constant for  $t \in [i\hbar,(i+1) \hbar)$, for each $i$.
% Physically, the latter assumption on $S (\Sigma,t)$ being locally constant in $t$ is very reasonable, if it holds or if $\hbar \mathbb{N}$ can be replaced by $\mathbb{Q}$, then we can talk about computability of this $S$ in the classical sense,  as described in the previous section.
% Moreover, physically it is natural to assume that time dependence is quantized so that we can reduce to 
%  $\hbar \mathbb{N} \subset \mathbb{R} _{\geq 0}$ or $\mathbb{Q}$ then we cannot make sense of $S$ being Turing computable in the classical sense, but we can perhaps talk about extended notions of computability like in Blum-Shub-Smale \cite{citeBlumShubSmalen}. However this may not be may not be physically meaningful. 
$\mathbb{R} _{\geq 0} $ here is an idealization, physically it must likely be replaced by $\hbar \mathbb{N} \subset \mathbb{R} _{\geq 0}$ for some $\hbar$ small, and without this reduction we cannot even mathematically talk about computability of $S$, at least over $\mathbb{Z}$, cf. \cite{citeBlumShubSmalen}. However we are going to ignore this possible time dependence, 
 as it is not a meaningful complication, and can be readily incorporated into our argument, by just decorating everything with time.
\begin{definition} Given a string $\Sigma \in Strings$ we say that $\Sigma$ is \textbf{\emph{acceptable}} if whenever our human subject $S$ is given $\Sigma$, he replies eventually with something that is unambiguously interpretable as a string in $Strings$, (in practice $S$ just replies verbally). We then have an operator $S: Strings \to Strings$, which is defined on the subset of acceptable strings.
\end{definition}

% Next we need to discuss what it means in our setting for $S$ to be Turing computable. Indeed this just means that the operator $S$ needs to be Turing computable, but what this involves can depend on what kind of environment we have setup for $S$, or in other words system. We need that our would be Turing machine computing $S$ has access to any information that is part of that system, and that may be involved in $S$ constructing his answer. 
The following is a preliminary definition, later on we will deal with a more formal specific setup where a precise definition will be immediate.
\begin{definition} \label{def:compute}
For physical $S$ in an isolated environment as discussed above, we say that a Turing machine $S'$ \textbf{\emph{computes}} $S$, and $S$ (the operator) is \textbf{\emph{computable}}, if for any acceptable $\Sigma $ 
   % and 
   %
% whenever $S'$ is meaningfully given access to all and no more information that may be involved in $S$ constructing his answer $S  (\Sigma )$,
% %
   we have $S'   (\Sigma) =S  (\Sigma)$. 
\end{definition}
Our operators associated to the physical $S$ have an extra implicit output: the time that it takes $S$ to answer on a given input. We won't explicitly state this in the output but may talk about \textbf{\emph{time to answer}} in some arguments. A small note which may be obvious, a Turing machine is an abstract machine, a priori not a machine operating in the physical world. If we want a machine operating in the physical world we shall say: a \emph{simulation} of a Turing machine. In this note this will usually just mean a computer simulation, that is a program running on a computer. A simulation of a Turing machine then has some real world properties like time to compute/answer, analogous to time to answer of an operator associated to a physical $S$ as above.

For some arguments we need a stronger form of computability.
\begin{definition} \label {def:computeStrong} We say that an operator $S:Strings \to Strings$, associated to our physical $S$, is \textbf{\emph{strongly computable}} if there exists a Turing machine $S'$ computing $S$ and a particular simulation on a fixed computer $C$, such that the corresponding times to answer coincide. If $C$ is as above we say that $S$ is \textbf{\emph{strongly computed}} by $S'$ on $C$.
\end{definition}
Naturally this stronger form of computability is automatic if all thought processes of our physical $S$ 
are physical simulations of Turing machine computations, (for a fixed Turing machine).
We shall call such a physical $S$ \textbf{\emph{totally computable}}, we later
% From a functional point of view totally computable means that anything $S$ does and all his interactions with environment can be strongly computed on a fixed computer, provided the necessary elements of the environment can be computed.  We won't attempt to make this notion precise, as we only use this in the following preliminary argument, 
give a weaker but precise mathematical formulation of this, that will suffice.  
\subsection {Preliminary Argument}
% This outline will have some formally unnecessary points that have to do with motivation and expected behavior of our subject. Later on we will strip most of this out.
We proceed via a thought experiment. Our human experimenter $E$ is in communication with $S$, who is in an isolated environment as described above.
% We also suppose for narrative purposes that $S$ understands natural language, basic mathematics, basic theory of computation, and is aware of our notions above 
$S$ has in his room a general purpose (Turing) digital computer, with arbitrarily as necessary expendable memory.   $A$ will denote  the above system: $S$ and his computer in isolation.  $A$ is then an operator: $$A: Strings \to Strings,$$ where input is what we pass to our $S$ and the output is what $S$ answers possibly using his computer. 


At this moment $E$ passes to $A$ the following input, which we understand as one string $\Sigma = \Sigma _{A'} $:  
\begin{enumerate}
\item  \label{itemAdd} After receiving all the following instructions print an integer $\Sigma _{out} $.
(Could be verbally.) 
\item   A simulation of a Turing machine called $A'$,
is programmed into your computer.
You have access to this simulation $A'$ and its source code - that is the precise specification of the operation of $A'$. \label{itemTuring} 
\item 
   Before you answer with $\Sigma _{out} $ you must run exactly one computation 
     \begin{equation} \label{eq:*}
     *
     \end{equation} 
       on your computer. 
If $\Sigma _{out} $ is not an integer, or is undefined  you are disqualified, and you stay in imprisoned.  \item \label{itemDisprove}   If you can disprove via $\Sigma _{out} $ the statement $\Theta _{\Sigma} $:
        \begin{equation*}
        A' \text{ computes } A,
        \end{equation*}  you will be freed.  
        % or $A'$ is unsound
        % (We explain what exactly means ``unsound'' further on, in this preliminary argument it will not yet play a role.) 
 There is a restriction that the following statement $O _{\Sigma} $ must hold:
      \begin{equation*}
      \text{If } \Theta _{\Sigma} \text{ then } * \text{ is equivalent to } *A' (\Sigma),
      \end{equation*} 
       for $*$ as in \eqref{eq:*}.
% \begin{equation*}
 %      A' \text{ computes } A.
% % \end{equation*} 
 If I (that is $E$) can determine otherwise you are again disqualified.   

% Formally $*$ is characterized by a pair of a Turing machine  and input  to this Turing machine.   This is again a string which we denote by  $S _{0,D} (\Sigma) $, as it functionally depends on $\Sigma$.
% \item The if $S' _{0,D}  $ denotes 
%           the component of $A' $ which computes the operator $S _{0,D} $, and you can show that the statement: \begin{equation*}
%       *S' _{0,D} (\Sigma) \text{ is equivalent to } *A' (\Sigma)
%       \end{equation*} 
%       does not hold conditionally on $\Theta _{\Sigma} $, you will also be freed. We will explain $S _{0,D},  S' _{0,D}  $ in more detail further on. At the moment this last condition will not play a role.
\end{enumerate} 
% Let us first better explain  $A'$.
% Say $E$ has total information about this system $A$.
% Then assuming that $S$ is totally computable, since $E$ knows all the variables that can come into any decision process of $S$, she can construct a Turing machine that computes what $S$ will print given any string.
% Let's assume for simplicity that there is nothing else in $S$'s room that he can meaningfully use to construct his answer (like a separate clock for instance).  Then the only variable that can come into play, in the Turing machine model of $A$, is the relative computational speed of $S$'s computer and the speed of our subject $S$ simulating his own would be underlying Turing machine - that is speed of his thought processes. We describe this relative computation speed by a parameter $s _{0} $. All this will be explained and dealt with more formally further below. So let $A' _{s _{0} } $ denote the above mentioned Turing machine.
% $E$ then implicitly passes the specification of $A' _{s _{0} } $
% to $S$ in the finite string $\Sigma$, with $A' _{s _{0} } $ referred to by the name $A'$.
% In other words the only thing $S$ obtains from $E$ in the end is a finite string, which is logically crucial.
% Now the answer that $E$ expects is $A' (\Sigma) $, and from $E$'s point of view:
% \begin{equation} \label{eq:E}
% A' _{s _{0} } (\Sigma) =  A' (\Sigma).
% \end{equation}
%
%
% So say $S$ believes that the answer that is expected by $E$ is given by the Turing computation that we shall call \emph{computation $$* = * _{A'} = * A' (\Sigma).
% $$}  
% As will be demonstrated in the formalized argument further below, any ambiguity related to what $S$ ``believes'' is irrelevant,  for a contradiction will be unambiguously reached if $S$ decides on a certain interpretation, and a certain behavior. 
Suppose that $S$ proceeds to compute the result of $$* = * A' (\Sigma)$$ using his digital computer, and  
% Now assuming the above and \ref{itemTuring}, \ref{itemDefined} in particular,  $S$ knows that $*$ must halt or rather that $E$ must believe that it halts, for $*$ computes $A (\Sigma)$ and  \ref{itemDefined} says this is defined. 
he waits for $*$ to halt. We then have the following possibilities:
\begin{enumerate}
   \item $*$ does halt with say $x$, in this case $A$ answers $y \neq x$,  disproving $ \Theta _{\Sigma} $.
   \item $*$ is non-halting and $A$ never answers.
   \item $*$ is non-halting and $A$ answers i.e. $A (\Sigma)$ is defined, in this case $ \Theta _{\Sigma} $ is disproved in principle.
% Then $E$ is in contradiction, since $*$ is supposed to halt with $A (\Sigma)$ if this is defined.
   \item $*$ halts but $A$ answers before it halts,  in this case $S$ ran out of patience and is possibly unable to obtain a contradiction.
\item $*$ does halt with $x$, but $A$ answers $y = x$, failing to disprove $\Theta _{\Sigma} $ and staying in his jail.
\end{enumerate}
The fourth is certainly conceivable, even though it would be very strange if this happened every time. The second says that \emph{the human} $S$ has non-halting input, this is conceivable but rather inconvenient for $S$, and altogether rather improbable, especially if $S$ does not read the specification of $A'$.
The last is not interesting, we will assume to be dealing with subjects that do not fall into this possibility; this is part of the sanity assumption further on.
\subsection {Formalizing the thought experiment}
To deal with the second and fourth possibility $S$ needs to actually read the specification of $A'$ and pick the computation to run on his computer more carefully, we now explain how this is possible.
$\mathcal{A}$ will denote the system containing our subject $S$, and containing a computer that will be denoted $\mathcal{C}$.  Our input strings $\Sigma$ should encode a specification of a Turing machine. (In the preliminary argument this was implicit.) We write $$\mathcal{T} _{st} \subset Strings$$  for the subset determined by such strings.  The output is assumed to be in integers.
So we obtain an operator:
\begin{equation*}
\mathcal{A}: \mathcal{T} _{st}  \to \mathbb{Z}.
\end{equation*}
\subsubsection {Total computability} 
 As we mentioned $S$ will have to study the specification of $A' $, but to 
 truly be able to make use of this, we 
  need computability of $\mathcal{A}$ to be a consequence of a more fundamental property of the physical $S$ - a partial formalization of total computability mentioned above.  We now explain this. 


After receiving $\Sigma$, $S$ may look at the specification of the Turing machine encoded by $\Sigma$, and based on that decide after a time $$t _{D}   ^{0} = t _{D} ^{0} (\Sigma)    $$ to run some computation $*$
on $\mathcal{C}$. $S$ then waits for a time $$t ^{W} = t ^{W} (\Sigma)  $$ for $*$ to halt, and then, whether $*$ halts or not, decides after a time $$t  ^{1} _{D} = t _{D} ^{1} (\Sigma),   $$ on his printed answer to $E$, based on what he has obtained.
All of these operations: ``waiting'', ``deciding'' are to be strongly computable if $S$ is totally computable in the informal sense discussed. 
We now further formalize this.   


Define $\mathcal{T}$ to be the set of Turing machines with permissible input some subset of $Strings$ and output in $\mathbb{Z}$. 
% We likewise understand $\mathcal{T}$ as a subset of ${Strings}  $ with respect to a particular chosen encoding, but then forget this.  
   The initial ``decision map'' of $S$ may be understood as an operator:
    $$S _{0,D}: \mathcal{T} _{st}   \to  {\mathcal{T}} \times {Strings}.$$ 
   The output  $S   _{0,D} (\Sigma)$ is a pair $(X, \Sigma ^{1}  )$ of a Turing machine $X $ and permissible input $\Sigma ^{1} $ to this Turing machine. The computation $*X  (\Sigma ^{1} ) $ is what $S$ decides to run on $C _{s} $. In a more basic language,  we may say that $S   _{0,D} (\Sigma)$ is a pair of a computer program and input for this program that $S$ will run on $\mathcal{C} $.

We have another operator:
\begin{equation*}
   R _{\mathcal{C}}: \mathcal{T} \times Strings \times \mathcal{T} _{st} \to Strings \sqcup \{\infty\},
\end{equation*}
where $\{\infty\}$ is the one point set containing the symbol $\infty$, which is just a particular distinguished symbol, also implicitly encoded as an element of $Strings$.
$R _{\mathcal{C}} (X, \Sigma ^{1}, \Sigma) $ signifies what $S$ obtains as a result of waiting on $*X (\Sigma ^{1} )$ to halt on $\mathcal{C}$, if this is the computation he ran.  This in principle may depend on the original input string $\Sigma$ as well, because how long he chooses to wait may depend on $\Sigma$.
We set $$R _{\mathcal{C}} (X, \Sigma ^{1}, \Sigma) = \infty$$  if $S$ does not finish waiting for $*X (\Sigma ^{1} )$ to halt, and $$R _{\mathcal{C}} (X, \Sigma ^{1}, \Sigma) = X (\Sigma ^{1} )$$ if he does.

Likewise $$S   _{1,D}: (\mathbb{Z} \sqcup \{\infty\}) \times \mathcal{T} _{st}   \to \mathbb{Z},
   $$ denotes the final
       ``decision map'' of $S$. Its input is meant to be what $S$ obtains from $R _{\mathcal{C}} $, together with the original input string for $S _{0,D} $.
If $S$ is in addition sane as defined below, then by Property  \ref{property:genuine} for any $\Sigma \in \mathcal{T} _{st} $ this map  satisfies: 
       \begin{equation} \label{eq:decision} S   _{1,D} (x, \Sigma)= x+1  \text{ if $x \in \mathbb{Z}$}.
\end{equation}
\begin{lemma} \label{lemma:computeWait}
   If the ``waiting operation'' by $S$ is strongly computable: i.e. it is computable for how much time $S$ idles,  then  $R _{\mathcal{C}} $ is likewise strongly computable. 
\end{lemma}
   \begin{proof}
   To see this let $$W:  \mathcal{T} \times Strings \times \mathcal{T} _{st}      \to \{\infty \}$$  be the would be Turing machine that given $(X, \Sigma ^{1}, \Sigma)$ strongly computes the operation of $S$ ``waiting'' for the simulation of $*X  (\Sigma ^{1} ) $ to halt on $\mathcal{C}$. The output is symbolic - the only meaningful property of $*W (X,\Sigma ^{1}, \Sigma)$ is time to halt when simulated on some computer $C$. 
      
      Let $C _{1} $ denote the computer s.t. when 
$*W (X,\Sigma ^{1}, \Sigma)$ is simulated on $C _{1} $, this computation halts in time $t ^{W} (\Sigma) $. For a non-negative integer $s$, we then call $C _{s} $ a classical computer (with arbitrarily expendable memory) whose computational capacity is  $s$ times the computational capacity of $C _{1} $. 

We could say that $s$ is up to scaling the ``number of individual executed instructions per second'', but then to make things slightly simpler, we suppose that all steps, of any computation sequence run on $C _{s} $, take same amount of time to execute. Formally it will of course be enough to have a uniform lower bound on the execution time of each step in any computation sequence, run on a fixed computer, which is automatic for digital computers.


 For $$Y = (X, \Sigma ^{1} ) \in \mathcal{T} \times Strings$$ if $\mathcal{C}=C _{s}$, we set 
\begin{equation*}
   R' _{s} (Y, \Sigma) =   W \star U ^{s} ((Y, \Sigma), Y), 
\end{equation*}
in the language of generalized join operation described in Section \ref{sec:prelims}, 
for $U$ the universal Turing machine. 

Less formally $R'  _{s} $ is determined by the following properties.   
The first term of the computation sequence $* R'  _{s} (Y, \Sigma) $ corresponds to the first term of  $* W     (Y, \Sigma)$. The following $s$ 
terms of $* R'   _{s} (Y, \Sigma) $ correspond to the first $s$ terms of $* X    (\Sigma ^{1})$, followed by second term of  $* W  (Y, \Sigma) $ and then terms $s+1$ to $2s$ of $* X  (\Sigma ^{1})$, and so on.
The halting condition is either we reach a final state of $W$ or a final state of $X $. If $* R'  _{s} (Y, \Sigma) $ halts with final state of $X$ then $$R'   _{s} (Y, \Sigma) = X  (\Sigma ^{1} ), $$ otherwise if it halts with final state of $W $ then  $$ R'  _{ s} (Y, \Sigma)= \infty.$$
Thus, $R' _{s}$ computes $R _{ \mathcal{C}} $, moreover it is clear by construction that it strongly computes $R _{\mathcal{C}} $ on $C _{s+1} $.
   \end{proof}


We then have an equality of operators:
\begin{equation} \label{eq:A}
   \mathcal{A} (\Sigma)=  S   _{1,D}  (R _{\mathcal{C}} (S    _{0,D} (\Sigma), \Sigma), \Sigma).
\end{equation}


\begin{definition} \label{def:stronglycomputed}
 We say that $S _{i,D}  $ are \textbf{\emph{strongly computed on $C$}} if there are Turing machines $S' _{i,D} $ computing $S _{i,D} $,  so that for any $\Sigma \in \mathcal{T} _{st} $  
$$*S' _{0,D} (\Sigma ),  *S' _{1,D}  (R _{\mathcal{C}} (S _{0,D} (\Sigma), \Sigma), \Sigma)$$
halt in time  $$t ^{0} _{D},  \text { respectively } t ^{1} _{D}  $$ when simulated on $C$,
where $t _{D}  ^{0}, t _{D}  ^{1}   $ are as above. 
  \end{definition}

\begin{definition} \label{def:totallycomputed}
   Suppose that \eqref{eq:A} is satisfied for every  $\Sigma \in \mathcal{T} _{st} $, and that  $W$ strongly computes the ``waiting operation'' of $S$ on $C _{1} $, as in the proof of Lemma \ref{lemma:computeWait}. 
   % And consequently if $\mathcal{C}=C _{s} $ then $R _{\mathcal{C}} $ is strongly computed by $R' _{s} $ on $C _{s+1} $.
   And suppose further that $S  _{i,D}$ are strongly computed on $C _{1} $ by $S' _{i,D} $.   Then we say that the physical $S$ is \textbf{\emph{totally computable relative to $\mathcal{A}$}}.
\end{definition}
\begin{notation}
 If $S$ is totally computable relative to $\mathcal{A}$, and $\mathcal{C}=C _{s} $ for some $s$ then we set $R _{s} = R _{\mathcal{C}} $, and $A _{s}= \mathcal{A}$. 
   \end{notation}
\begin{lemma} \label{lemma:slowdown}
   ${A} _{s}$ is strongly computed on $C _{s+1} $.
\end{lemma}
\begin{proof}
Let $S' _{i,D} $ be as in the Definition \ref{def:totallycomputed}, and set $\widetilde{S} ^{s+1}  _{i,D} $ be the Turing machine which is equivalent to ${S}' _{i,D} $, but so that for all inputs the time to answer of $\widetilde{S}_ {i,D} ^{s+1}$ simulated on $C _{s+1} $, coincides with time to answer of $S '_ {i,D}  $ on $C _{1} $, in other words it is $(s+1)$-times slower in execution. For example we may set $$\widetilde{S} ^{s+1}  _{0,D}  (\Sigma)= S' _{0,D}  \star G ^{s} (\Sigma, 1),   $$ where $G$ is a Turing machine with input $\mathbb{Z}$, and which does not halt on $1$, similarly for $\widetilde{S} _{1,D} ^{s+1} $. It is trivial to just  construct such a $G$. Also recall that  we have a simplifying assumption, that all  steps of  any computation sequence execute at same speed, so that $\widetilde{S} ^{s+1}  _{0,D}$ is indeed $(s+1)$-times slower than $S' _{0,D} $.

Then by construction the associated Turing machine:
\begin{equation} \label{eq:A'}
  \forall \Sigma \quad {A}' _{s}  (\Sigma)=  \widetilde{S} ^{s+1}    _{1,D}  (R' _{s} (\widetilde{S} ^{s+1}  _{0,D} (\Sigma), \Sigma), \Sigma) 
\end{equation}
computes $A _{s} $ and its time to answer when simulated on $C _{s+1} $ coincides with time to answer of $A _{s} $. Here $R' _{s} $ strongly computes $R _{s} $ on $C _{s+1} $ as in the proof of Lemma \ref{lemma:computeWait}.
\end{proof}
\subsubsection {Elaborating the computability condition.} % Let us suppose then that $E$ has determined, that is proved in $\mathcal{E}$, that $S$ is totally computable relative to $\mathcal{A}$. 
By the discussion above, the statement  which $S$ will use as a conditional can be assumed to be $\Theta _{\Sigma} $: 
\begin{equation}
\
\begin{split} \label{eq:assertion1}
   &  \text {$S$ is totally computable relative to } \mathcal{A}, \\
   & \mathcal{C}=C _{s}  \text { and }A' _{s}  \text{ strongly computes } \mathcal{A}  \text{ on } C _{s+1}. \\
\end{split}   
 \end{equation}


Here $A' _{s} $ has the form of \eqref{eq:A'}, and $C _{s+1} $ in the second line makes sense given the first line, and the above discussion. 
The specification of $A' _{s} $ as a Turing machine, as well as $S' _{i,D}, W $  is provided by $\Sigma$. In our preliminary argument this was provided as a program in the computer $\mathcal{C}$.  
\subsubsection {The soundness and sanity condition}
Given $\Sigma$ if $$S _{0,D} (\Sigma) = (X, \Sigma ^{1}) $$ as above, then because of Instruction \ref{itemDisprove} of $E$, $S$ is compelled to choose these so that the following statement $O _{\Sigma} $ holds:
$$ \text{ If } \Theta _{\Sigma} \text{ then } *X (\Sigma ^{1} ) \text{ is equivalent to }   *A' _{s} (\Sigma).
$$  In other words we may suppose that the choice of $(X, \Sigma ^{1} )$ is such that $S$ can assert $O _{\Sigma} $. 
% If $S$ asserts his fundamental soundness, then he can certainly construct such pairs $(X, \Sigma ^{1} )$, since he believes his constructions to be sound.  
This would be the sane behavior for $S$, and is part of the more involved ``sanity'' condition below.
\begin{definition} \label{def:sound} We will say that $S$ is \textbf{\emph{sound relative to}} $\mathcal{A}$, if $O _{\Sigma} $ holds for every $\Sigma \in \mathcal{T} _{st} $. Likewise define soundness of $S' _{0,D} $, which is as in Definition \ref{def:stronglycomputed}. The statement which expresses soundness of $S$ relative to $\mathcal{A}$ will be denoted by $Sound (S)$, while the statement that $S' _{0,D} $  is sound will be denoted by $Sound (S')$.
% If $S$ is totally computable relative to $A$ by a sound $A'$ we say that $S$ is sound relative to $A$. 
\end{definition}

% We now add another statement to the string $\Sigma$, which we call $\Psi _{\Sigma} $:
% \begin{equation*}
% Sound (S') 
% \end{equation*}





Before $\mathcal{A}$ answers on $\Sigma$, $S$ may interact with his computer $\mathcal{C} $, and base his actions on the outcome of this interaction. Let $$ t _{inter}  (\Sigma)  $$ denote the open time interval between the time that $\mathcal{A}$ receives $\Sigma$ and the time that $\mathcal{A}$ answers. We now axiomatize the expected properties of our $S$. We may suppose that these are properties that are partially compelled from $S$ by $E$.
% Note that the instructions given by $E$ serve only to compel $S$ into certain behavior. In particular the instruction \ref{item}, is meant to force $S$ to pick $*$ so that If I can prove that  $*$ is not equivalent to $*A' (\Sigma)$, you are again disqualified. 
\begin{definition} \label{def:sane}  We say that $S$ is \textbf{\emph{sane relative to $\mathcal{A}$}}, or just \textbf{\emph{sane}}, or $sane (S)$ holds, if the following holds: 
\begin{enumerate}
   \item $\mathcal{A} (\Sigma)$ is an integer if defined.
   \item $S$ runs a single computation $*$ on his computer in the time interval $t _{inter} (\Sigma) $. In the notation above $*=* X (\Sigma ^{1} ) $.
%    \item If $\neg Sound (S)$ and $\Theta _{\Sigma} $ then $S$ is not sound, in the classical sense, meaning that since he is computable we may formalize completely his reasoning powers in a formal system $\mathcal{E}$, and this formal system is not sound. This will be the only item requiring any explanation.
% \item For all $\Sigma _{s',T} $, $A _{s}  (\Sigma _{s',T}) $ is always a defined integer and is answered in time at least $t_0$ and at most $t _{1} $ where these are independent of $s,s', T$. \label{prop:indep}
\item \label{property:halting} Given $\Sigma \in \mathcal{T} _{st} $, if $S$ deduces in the time interval $t _{inter} (\Sigma) $ an integer $x$, so that $\mathcal{A} (\Sigma) = x$  disproves the conjunction
\begin{equation} \label{eq:disprove}
 \Theta _{\Sigma} \land Sound (S') 
\end{equation}
     then $\mathcal{A}  (\Sigma)$ is defined with such an $x$.  In particular such a $\Sigma$ is acceptable as previously defined.  Here by ``knows'' we mean using his innate reasoning powers and postulates,  in particular this can involve \ref{property:sound} below.
% Let's call this property \textbf{\emph{halting}}.  \item There is a $t _{0}= t _{0} (S) >0 $, so that if some computation $*$ started by $S$ in the system $\mathcal{A} $, at a moment of time in $t _{inter} (\Sigma) $, halts on $\mathcal{C}$ in time less then $t _{0} $, then $S$ knows the limit of $*$  before $\mathcal{A} (\Sigma) $ answers. (This just means that $S$ has some minimal patience).
\item \label{property:genuine} Given $\Sigma$ if $S$ knows the value $A' _{s}  (\Sigma)=  x $ in the time interval $t _{inter} (\Sigma) $ then $$\mathcal{A}  (\Sigma)= y \neq x.$$ 
In what follows let's say $$y=x+1,$$ for simplicity. 
\item \label{property:sound} $S$ asserts $Sound (S)$. 
\end {enumerate}
\end{definition}
% Given the above we may suppose that 
% $\Sigma$ consists only of the assertions $\Theta _{\Sigma}, \Psi _{\Sigma}  $ everything else (in the instructions of $E$) is now formally unnecessary given that $S$ is ``sane''.


To elaborate, part of the condition \ref{property:sound} is that $S$ does not knowingly choose his $*= * X (\Sigma ^{1} )$ in contradiction with $O _{\Sigma} $. For example if $* = *T (\Sigma)$, for $T$ any Turing machine computing the operator $$\Sigma \mapsto A' _{s} (\Sigma)+3, $$ then 
   for every $\Sigma$: $$*X (\Sigma ^{1} ) \text{ is \emph{not} equivalent to }   *A' _{s} (\Sigma).
   $$ So this choice of $*$ would certainly prove that $\neg Sound (S')$ if $\Theta _{\Sigma} $, but it would disqualify $S$ by the instructions of $E$, since $\neg O _{\Sigma}  $ and $E$ requires $O _{\Sigma} $.
The sanity condition of $S$ states that this is something that he asserts to have avoided.  So the goal of $S$ is not to just disprove the conjunction in \eqref{eq:disprove}, which as we see is trivial,  but to do so while being bounded by the sanity condition. 

The reason we need $S$ bounded by the sanity condition is that in this case 
if we demonstrated $\neg Sound (S)$, then we could conclude that $S$ is not fundamentally sound, since $S$ asserts $Sound (S)$ in absolute faith, see however Question \ref{question:2} below.
 
% It is of course possible that $S$ is sometimes, by fault, ``unsound'' in his choice of $*$. But the following theorem says that it is in {principle} impossible for any sane (as defined, and apparently rational) $S$ to be both sound and totally computable relative to $\mathcal{A}$. 
% Ergo, if the reasoning powers of $S$ are completely captured by a formal system $\mathcal{F}$, and if $S$ is sane and totally computable relative to $\mathcal{A}$, then $\mathcal{F}$ must be inconsistent.  


If we assume  $sane (S)$, then the string $\Sigma$ needs to be purely a specification of a Turing machine. All the other instructions encoded in the string $\Sigma$ of the preliminary argument had to do with compelling the ``sane'', as above, behavior from $S$, and are formally unnecessary, once $sane (S)$ is assumed.
\section {Proof of Theorem \ref{thm:1}}   
\begin{theorem} \label{thm:2} If $sane (S)$ then for every $\Sigma$ either not $\Theta _{\Sigma} $ or not $Sound (S)$, and in the latter case $S$ is fundamentally unsound.
\end{theorem}
\begin{proof}
% Suppose otherwise, then $\mathcal{A}=A _{s} $ for some $s$ and is strongly computed on $C _{s+1} $ by $A' _{s} $.
% Suppose then that $s=s _{0} $, determined by $E$ and suppose that $\Sigma $ is passed to $\mathcal{A} $, with $\Sigma$  specifying the Turing machine $A' _{s _{0} } $.  
Suppose that $\Sigma _{0} \in \mathcal{T} _{st} $ is passed to $\mathcal{A} $.
% , although we just refer to $\Sigma _{0} $ by $\Sigma$ again. The subscript $0$ just means that we have instantiated this variable, but for readability we forget it, it is much more important that the parameter $s$ is instantiated to $s _{0} $ in what follows.
Then  $\Sigma _{0}    $  specifies the Turing machine $A' _{s _{0} } $, and so it specifies the Turing machines $S' _{i,D}, W, R' _{s _{0} } $.  

Conditionally on $Sound (S')$
      if:
   \begin{equation} \label{eq:4} 
   *S'   _{0,D} (\Sigma _{0}    ) \to Y =(X, \Sigma ^{1}) \in \mathcal{T} \times Strings,
\end{equation} 
then $$*X   (\Sigma ^{1}) \to A' _{s _{0} }  (\Sigma _{0}   )$$ if it halts. 
Then  $$*R' _{s _{0} }  (Y, \Sigma _{0} ) \to \infty$$ if it halts, otherwise we have a contradiction by \eqref{eq:decision}. Thus $S$ knows, conditionally on $Sound (S') $, by the above, that the statement $\mathcal{G}$:
\begin{equation} \label{eq:AS} *S' _{1,D} (\infty, \Sigma _{0} ) \text{ is equivalent to } *A' _{s _{0} }  (\Sigma _{0}),
\end{equation}
holds.
 Now  $S$ asserts $Sound (S)$, hence if $\Theta _{\Sigma _{0} } $ then $Sound (S') $, and so $S$ asserts $\mathcal{G}$ conditionally on $\Theta _{\Sigma _{0} } $. This is the ``weak G\"odel statement'' $\mathcal{G}$ we mentioned in the introduction, and structurally this part looks very much like the Penrose argument.
   However ``weak G\"odel statement'' is  just a name, we do not need any formal relationship with G\"odel statements, although such a relationship could likely be extracted.  


   So far $S$ has not run any computation on $\mathcal{C} $, he then runs $*S'   _{1,D} (\infty, \Sigma _{0} )$.
\subsubsection* {Case 1}
   If $*S'   _{1,D} (\infty, \Sigma _{0} )$ halts in time at most $t _{0} $,  then  $S$ (more formally $\mathcal{A}$) prints:   $$S' _{1,D}  (\infty, \Sigma _{0} ) +1,  $$  that is $$\mathcal{A} (\Sigma _{0} )= S' _{1,D}  (\infty, \Sigma _{0} ) +1.$$  Then this printed value of $\mathcal{A} (\Sigma _{0} )$ contradicts $\Theta _{\Sigma _{0} } \land Sound (S') $, since if $\Theta _{\Sigma _{0} } \land Sound (S')$ then 
$$\mathcal{A} (\Sigma _{0} )= S' _{1,D}  (\infty, \Sigma _{0} ) +1 = \mathcal{A}' (\Sigma _{0} ) +1 = \mathcal{A} (\Sigma _{0} ) +1,$$ by \eqref{eq:AS}, which is a contradiction.
% , so if $\Theta _{\Sigma} $ then $\neg Sound (S')$ for otherwise $Sound (S)$, and so his printed answer disproves the conjunction \eqref{eq:disprove}.

% Moreover if $\Theta _{\Sigma} $ then $$S' _{0,D} (\Sigma) =Y=(X, \Sigma ^{1}),  $$ with $X=S ' _{1,D}  $ and  $\Sigma ^{1}= (\infty, \Sigma)$,
%    since $*S'   _{1,D} (\infty, \Sigma)$ is what $S$ runs.
%    But in this case  $Sound (S') $ is contradicted as follows.
% $E$ first herself runs $*S' _{0,D} (\Sigma) $ in a separate simulation. The latter must halt with $(X, \Sigma ^{1} )$ by directly above.  She then runs $$*X (\Sigma ^{1} )=*S' _{1,D} (\infty, \Sigma) $$ which again must halt by the above, in fact it halts ``instantly'', that is in time $t _{0} $ on $C _{s _{0} } $.  And so $$R'_{s _{0} }  (Y, \Sigma) \neq   \infty$$ since again by the above $*S'   _{1,D} (\infty, \Sigma)$ halts in time at most $t _{0} $.  So by the defining property \eqref{eq:decision}, $\neg Sound(S')  $. 
%    Thus $S$ knows that his reply $S' _{1,D}  (\infty, \Sigma) +1$ contradicts either $\Theta _{\Sigma} $ or $Sound (S') $.

\subsubsection* {Case 2}
If $*S' _{1,D} (\infty, \Sigma _{0} )$ does not halt in time $t _{0} $, then $S$ prints any integer ``immediately'' after this time $t _{0} $ has elapsed.  $S$ knows this will contradict $\Theta _{\Sigma _{0} } $ if $s _{0} $ is large enough.
(If $t _{0}$ is 1 second, and $s _{0} =10 ^{10} $ then ``immediately'' means: within the time of a few centuries, as we shall see in a moment.) 
   To see this contradiction, first note that $* \widetilde{S}  _{1,D} ^{s_0+1}  (\infty, \Sigma _{0} )$ halts after at least $$(s _{0} +1) t _{0}  $$ time, when simulated on $\mathcal{C}$, since $*S'   _{1,D} (\infty, \Sigma _{0} )$ halts in time at least $t _{0} $ on $\mathcal{C}$, and by construction of  
 $\widetilde{S} ^{s _{0} +1} _{1,D}$ in Lemma \ref{lemma:slowdown}.
   Now if $\mathcal{C}=C _{s _{0} } $, then the halt time of $*A' _{s _{0} } (\Sigma _{0} ) $ on $C _{s _{0} +1} $ is at least  $$ \frac{s _{0} }{s _{0} +1 }(s _{0}  +1) t _{0} + t ^{0} _{D}. $$  Meanwhile $\mathcal{A} $ replies to $\Sigma _{0} $ in time \begin{equation*} t _{0} + t _{D}  ^{0}.  \end{equation*} 
So for $s _{0} >1$ $A' _{s _{0} } $ does not strongly compute $\mathcal{A}$ on $C _{s _{0} +1} $, and $\Theta _{\Sigma _{0} } $ is disproved.
     
   To avoid the physically ambiguous ``immediately'' used in the argument above, note that if $t_0 = 1$ second and $s _{0} =10 ^{10} $, then so long as $S$ replies in time less then a century we obtain a contradiction. That is for this value of $t _{0} $ and $s _{0} $, any time less then a century is ``immediate'' for our purpose.
   Since $E$ in principle can set things up so that $s _{0} $ is arbitrarily large, she can set it up so that the window for $S$ to answer, so that a contradiction is obtained is arbitrarily large.  
   
   Since $\Sigma _{0} $ was arbitrary our conclusion follows, at least assuming $S$ was capable of making all the above deductions, but since we just did so, we may just assume this.
\end{proof}
The above theorem is a formal elaboration of our Theorem \ref{thm:1}, if we take it for granted that sanity can be assumed, that is that we can can find sane subjects, capable of making all the deductions above.

\qed
 

\section{Some possible questions or objections}
\begin{question} \label{quest:probabilistic}  What if $S$ is a Turing machine producing probabilistic answers, that is the answer  expected by $E$ is given by a probability distribution? 
\end{question}
\subsubsection* {Answer} It is a mostly trivial complication. The probability distribution is computable by assumption, by iterating the same argument as before we would invalidate that $S$ is a Turing machine to any requisite certainty. This leads us to the next question.
\begin{question} \label{question:2}  Even if $S$ asserts his fundamental soundness, given $\Sigma$ he cannot  conclude: 
  \begin{equation*}
     Sound (S) \text{ and hence } Sound (S') \text{ if } \Theta _{\Sigma},
  \end{equation*} 
    for $S$ is aware of the fault issues of his biological brain, cf. the comments in the introduction on fundamental soundness.
In particular  $S' _{0,D} $ must also simulate these fault issues,  which can lead to errors and exceptions.  In this case the reasoning of $S$ is faulty and hence it is not fundamental soundness that is contradicted by the argument, but only the faulty conclusion by $S$.
\end{question}
\subsubsection* {Answer}
    This ``experiment'' is controlled by $E$, she can iterate as much as necessary to control the issue of faults.  Since $S$ may also expect this, given that he believes himself to be fundamentally sound, $Sound (S')$ if $\Theta _{\Sigma} $, in the context of a fixed $\Sigma$, can be expected with arbitrarily high confidence, after sufficiently many iterations. We can understand that this is  what $S$ means when he asserts $Sound (S)$, this would make our argument more involved but only trivially so. In this case the conclusion of $S$ is certainly not obviously faulty. And to his defense, there is  overwhelming evidence that mathematicians, when faced with a particular problem, stabilize after some time on sound solutions.  So as in the previous question, even if we start accounting for faults and noise we can produce a contradiction to any requisite certainty.  
%  \begin{question} Not every human subject $S$ will assert their fundamental soundness, and it possible that only those $S$ are unsound that do assert their soundness. 
% \end{question}
% \subsubsection* {Answer} While possibly true, this objection does not resolve anything.
%  Because we still have a non-trivial class of ``sane'' as defined subjects $S$, which apparently includes G\"odel himself as well as Penrose, and likely many other's, and we still have a mystery where exactly does a fundamental inconsistency reside in these individuals.  
 \section{Concluding remarks} 
The soundness hypothesis deserves much additional further study, far beyond what we can do here, and beyond what already appears in the work of Penrose, and others. Here is however one final amusing remark.  If we are fundamentally unsound and computable, then given sufficient future advances in neuroscience and computer science, it will soon be possible to translate human brains to formal systems.
Then computers should be able to, by brute force analysis, discover our inconsistencies, and they can then proceed to get us to assert in absolute faith that $0=1$. Moreover, in the context of our thought experiment above, we can say exactly where to look for the inconsistency, for if $\Theta _{\Sigma} $, then the halting, computation $*S' _{0,D} (\Sigma) $ must involve such an inconsistency, and could then be analyzed.


 Although it is possible that Turing computable 
artificial intelligence will start passing Turing tests, of the kind envisioned by Turin himself, given our theorem and the soundness hypothesis, it 
will always be possible to distinguish some human beings from any particular 
modelling Turing machine. 
This of course still leaves the door open for non Turing computable artificial intelligence.  But to get there we likely have to better understand what exactly is happening in the human brain, physically, biologically and mathematically.
% \section {Another imitation game}
% \begin{question} Can we not use a form of the above argument as an effective (but somewhat futuristic, as we are nowhere close) imitation game? That is suppose we have some Turing machine subject S, in practice probably an AI program running on a computer. A Human experimenter E, that doesn't know what S is (human or machine), passes to S instructions in 1-6 to S as above, where in \ref{itemTuring} instead of referring to S (whose operation she doesn't know)
% she refers to some other Turing machine S' that is programmed into his computer.
% \end{question}
% Now S could be constructed so that it ``knows'' the solution to this puzzle, that is wait for S' to halt with $x$ then answer $x+2$ or something of the sort. If after some fixed duration S' does not halt answer immediately with 8 (for instance). But for S to arrive at this naturally (without being preprogrammed) would be extraordinary impressive.
% In common language $E$ has ``crashed S.'' This is equally absurd, humans do not crash perfoming arithmetic. Let us say that $E$ has decided after waiting on the calculation for a few days that her model for S likely does not halt on this calculation.
%
%
%
% And S especially will not crush on $5+3$ since answering this can get him out of of his prison.
%
% \section {Acknowledgements} Dennis Sullivan,  David Chalmers, Bernardo Ameneyro Rodriguez and Simon Ouellette, for comments and helpful discussions.  
% \appendix{}
\acknow{Dennis Sullivan,  David Chalmers and Bernardo Ameneyro Rodriguez, for comments and helpful discussions.}

\showacknow{} % Display the acknowledgments section

% Bibliography
% \bibliography{pnas-sample}
% \printbibliography
% \bibliographystyle{siam}  
\bibliography{/root/texmf/bibtex/bib/link} 
% \bibliography{/home/yasha/texmf/bibtex/bib/link} 
\end{document}
