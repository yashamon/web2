\documentclass{amsart}  %[12pt] %\textwidth=125mm
\usepackage{etoolbox}

% \makeatletter
% \patchcmd{\@settitle}{\uppercasenonmath\@title}{}{}{}
%  \patchcmd{\@setauthors}{\MakeUppercase}{}{}{}
% % \patchcmd{\section}{\scshape}{}{}{}
% \makeatother
%\textheight=185mm
%\headheight=10mm
\usepackage{graphicx}
\newenvironment{itquote}
  {\begin{quote}\itshape}
  {\end{quote}\ignorespacesafterend}
\newenvironment{itpars}
  {\par\itshape}
  {\par}
\usepackage[autostyle]{csquotes}
\usepackage {appendix}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{hyperref} 
\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true}
\usepackage{amsmath}
\usepackage{amssymb}
% \usepackage[
%     backend=biber,
%     % defernumbers=true,
%     style=numeric,
%     % autocite=plain, 
%     sorting=none,
%     % sortlocale=us_US,
%     % natbib=true,
%     url=true, 
%     doi=false,
%     eprint=true
% ]{biblatex}
% \addbibresource{~/workspacemodules/link.bib}
\usepackage{amscd}
\usepackage{color}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{indentfirst}
\usepackage[hmargin=3cm,vmargin=3cm]{geometry}
% \usepackage[all, cmtip]{xy}
\numberwithin{equation}{section}
\newtheorem{thm}[equation]{Theorem} 
\newtheorem{axiom}[equation]{Axiom} 
\newtheorem{theorem}[equation]{Theorem} 
\newtheorem{proposition}[equation]{Proposition}
\newtheorem{lma}[equation]{Lemma} 
\newtheorem{lemma}[equation]{Lemma} 
\newtheorem{cpt}[equation]{Computation} 
\newtheorem{corollary}[equation]{Corollary} 
\newtheorem{remark}[equation]{Remark}
\newtheorem{clm}[equation]{Claim} 
\newtheorem{conjecture}{Conjecture}
\newtheorem{definition}[equation]{Definition}
\theoremstyle{definition}
% \newtheorem{definition}[equation]{Definition}
\newtheorem{ft}{Fact}
\newtheorem{notation}{Notation}
\newtheorem{descr}{Description}[equation]

\theoremstyle{remark}
\newtheorem*{pf}{Proof}
\newtheorem*{pfs}{Proof (sketch)}
\newtheorem{example}{Example}
\newtheorem{question}{Question}
\newtheorem{objection}{Objection}

\newcommand{\R}{{\mathbb{R}}}
\newcommand{\Z}{{\mathbb{Z}}}
% \newcommand{\C}{{\mathbb{C}}}
\newcommand{\Q}{{\mathbb{Q}}}
\newcommand{\D}{{\mathbb{D}}}
\newcommand{\HH}{{\mathbb{H}}}

\newcommand{\bs}{\bigskip}
\newcommand{\ra}{\rightarrow}
\newcommand{\del}{\partial}
\newcommand{\ddel}[1]{\frac{\partial}{\partial{#1}}}
\newcommand{\sm}[1]{C^\infty(#1)}

\newcommand{\delbar}{\overline{\partial}}
\newcommand{\Sum}{\Sigma}
% \newcommand{\G}{\mathcal{G}}
\newcommand{\Pe}{\mathcal{P}}
\newcommand{\X}{\mathfrak{X}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\K}{\mathcal{K}}

\newcommand{\ZZ}{\mathcal{Z}}
\newcommand{\eL}{\mathcal{L}}

\newcommand{\mone}{{-1}}
\newcommand{\st}{{^s_t}}
\newcommand{\oi}{_0^1}
\newcommand{\intoi}{\int_0^1}
\newcommand{\til}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\arr}[1]{\overrightarrow{#1}}
\newcommand{\paph}[1]{\{ #1 \}_{t=0}^1}
\newcommand{\con}{\#\;}
\newcommand{\codim}{\text{codim}}
\newcommand {\ham} {\text{Ham} (M, \omega)}
\newcommand {\isom} {\text{Isom} ^{h}  (M, \omega, j)}
\newcommand {\lham} {lie \text{Ham} (M, \omega)}
\newcommand {\hamcp} {\text{Ham} (\mathbb{CP} ^{r-1}, \omega )}
\newcommand{\overbar}{\overline}
\newcommand {\vM} {{(T^*)} ^{vert} \cM}
\newcommand{\om}{\omega}
\newcommand{\al}{\alpha}
\newcommand{\la}{\lambda}
\newcommand{\Om}{\Omega}
\newcommand{\ga}{\gamma}
\newcommand{\eps}{\epsilon}
\newcommand{\Cal}{\tex{Cal}}

\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cI}{\mathcal{I}}
% \newcommand{\cJ}{\mathcal{J}}

%\newcommand{\cO}{\mathcal{O}}
\newcommand{\cS}{\mathcal{S}}

\newcommand{\cU}{\mathcal{U}}

\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cM}{\bm{M}}
\newcommand{\cP}{\bm{P}}
\newcommand{\cL}{\bm{L}}

\newcommand{\fS}{\mathfrak{S}}
\newcommand{\fk}{\mathfrak{k}}
\newcommand{\fg}{\mathfrak{g}}
% \newcommand{\fz}{\mathfrak{z}}
\newcommand{\fZ}{\mathfrak{Z}}
\newcommand\vol{\operatorname{vol}}
\newcommand {\hatcp}{\widehat{\mathbb {CP}} ^{r-1} }
\newcommand{\rJ}{\mathrm{J}}
\newcommand{\rB}{\mathrm{B}}
\newcommand{\rT}{\mathrm{T}}
\newcommand {\Hpm} {\mathcal{H}^{\pm}}
\newcommand{\bP}{\mathbb{P}}

\DeclareMathOperator {\period} {period}
\DeclareMathOperator {\sign} {sign}
\DeclareMathOperator {\Id} {Id}
\DeclareMathOperator {\halt} {halt}

\DeclareMathOperator {\floor} {floor}
\DeclareMathOperator {\ceil} {ceil}
\DeclareMathOperator {\mult} {mult}
\DeclareMathOperator {\Symp} {Symp}
\DeclareMathOperator {\Det} {Det}
\DeclareMathOperator {\comp} {comp}
\DeclareMathOperator {\growth} {growth}
\DeclareMathOperator {\energy} {energy}
\DeclareMathOperator {\Reeb} {Reeb}
\DeclareMathOperator {\Lin} {Lin}
\DeclareMathOperator {\Diff} {Diff}
\DeclareMathOperator {\fix} {fix}
% \newcommand{\M}{\mathbb{CP} ^{r-1} }
\DeclareMathOperator {\grad} {grad}
\DeclareMathOperator {\area} {area}
\DeclareMathOperator {\diam} {diam}
% \DeclareMathOperator {\rank} {rank}
\DeclareMathOperator {\dvol} {dvol}
\DeclareMathOperator {\quant} {Quant}
\DeclareMathOperator {\ho} {ho}
\DeclareMathOperator {\length} {length}
\DeclareMathOperator {\Proj} {P}
\renewcommand{\i}{\sqrt{-1}}
\DeclareMathOperator{\mVol}{\mathrm{Vol}(M_0,\omega_0)}
\DeclareMathOperator{\Lie}{\mathrm{Lie}}
\DeclareMathOperator{\lie}{\mathrm{lie}}
\DeclareMathOperator{\op}{\mathrm{op}}
\DeclareMathOperator{\rank}{\mathrm{rank}}
\DeclareMathOperator{\ind}{\mathrm{ind}}
\DeclareMathOperator{\trace}{\mathrm{trace}}
\DeclareMathOperator{\image}{\mathrm{image}}
\DeclareMathOperator{\Sym}{\mathrm{Sym}}
\DeclareMathOperator{\Ham}{\mathrm{Ham}}
\DeclareMathOperator{\Aut}{\mathrm{Aut}}
\DeclareMathOperator{\Quant}{\mathrm{Quant}}
\DeclareMathOperator{\Fred}{\mathrm{Fred}}
\DeclareMathOperator{\id}{\mathrm{1}}
\DeclareMathOperator{\lcs}{l.c.s.}
\DeclareMathOperator{\lcsm}{l.c.s.m.}
% \DeclareMathOperator{\ker}{ker}
\DeclareMathOperator{\coker}{coker}

\begin{document}
\title {Universal G\"odel statements and computability of intelligence} 
% less provocative
% Use letters for affiliations, numbers to show equal authorship (if applicable) and to indicate the corresponding author
\author{Yasha Savelyev} 
\href{http://yashamon.github.io/web2/papers/immitation.pdf} {Direct link to author's version}
\address{University of Colima, Department of Sciences, CUICBAS}
\email {yasha.savelyev@gmail.com}
\begin{abstract}
 We show that there is a mathematical obstruction to complete Turing computability of intelligence.  This obstruction can be circumvented only if human reasoning is fundamentally unsound, with the latter formally interpreted here as certain stable soundness. To this end, we develop in a specific setting an analogue of a G\"odel statement for stably sound Turing machines, as defined here. This stably G\"odel statement $\mathcal{G}$ in addition has a certain universality with respect to a certain class of Turing machines / formal systems.   Moreover, this $\mathcal{G}$ is constructed explicitly, given the general form of our class of Turing machines. The main argument is implicitly based on set theory, in contrast to the partially meta-logical arguments of G\"odel and Penrose, arguing for a similar obstruction. For this reason we are able to phrase our results as theorems.
% This results in a even more striking result, if a  human is provably computable, and accepts some basic set theory as true, then they must stably assert $0=1$.  
\end{abstract}
\maketitle
% \thispagestyle{firststyle}
% \ifthenelse{\boolean{shortarticle}}{\ifthenelse{\boolean{singlecolumn}}{\abscontentformatted}{\abscontent}}{}
% If your first paragraph (i.e. with the \dropcap) contains a list environment (quote, quotation, theorem, definition, enumerate, itemize...), the line after the list may have some extra indentation. If this is the case, add \parshape=0 to the end of the list environment.
% \dropcap{T}his PNAS journal template is provided to help you write your work in the correct journal format.  Instructions for use are provided below. 
%
% Note: please start your introduction without including the word ``Introduction'' as a section heading (except for math articles in the Physical Sciences section); this heading is implied in the first paragraphs. 
% We will give a complete definition of a Turing machine after the introduction.
In what follows we understand {\emph{human intelligence}  very much like Turing in \cite{TuringComputingMachines}, as a black box which receives inputs and produces outputs. More specifically, this black box $B$ is meant to be some system which contains a human subject. We do not care about what is happening inside $B$.
So we are not directly concerned here with such intangible things as understanding, intuition, consciousness - the inner workings of human intelligence that are supposed as special.  The only thing that concerns us is what output $B$ produces given an input, not how it is produced. Given this \emph{very} limited interpretation, the question that we are interested in is this: 
\begin{question} \label{quest1}
 Can human intelligence  be completely modelled by a Turing machine?  
\end{question}
An informal definition of a  Turing machine (see \cite{TuringComputableNumbers}) is as follows: 
it is an abstract machine which permits certain inputs, and produces outputs. The outputs are determined from the inputs by a fixed finite algorithm, defined in a certain precise sense. 
For a non-expert reader we point out that this ``fixed'' does not preclude the algorithm from ``learning'', \footnote {In the sense of ``machine learning''.} it just means that how it ``learns'' is completely determined by the initial algorithm. In particular anything that can be computed by computers as we know them can be computed by a Turing machine.  For our purposes the reader may simply understand a Turing machine as a digital computer with unbounded memory running some particular program. Unbounded memory is just a mathematical convenience.  In specific arguments, also of the kind we make, we can work with non-explicitly bounded memory.  
Turing himself has started on a form of Question 1 in his ``Computing machines and Intelligence'', \cite{TuringComputingMachines}, where he also informally outlined a  possible obstruction to a yes answer coming from G\"odel's incompleteness theorem. 


For the incompleteness theorem to have any relevance we need some assumption on the soundness or consistency of human reasoning.  
Informally, a human is sound if whenever they asserts something in absolute faith, this something is indeed true. This requires context as truth in general is undefinable.  For our arguments later on the context will be in certain mathematical models. 
However, we cannot honestly hope for soundness as even mathematicians are not on the surface sound at all times, they may assert mathematical untruths at various  times, (but usually not in absolute faith). But we can certainly hope for some kind of fundamental soundness.


In this work we will formally interpret fundamental soundness as stable soundness. 
% For preliminary understanding of this  ``fundamental'' is as follows. We are on the surface unsound not because of fundamental internal inconsistencies of our mental constructions, but for the following pair of reasons.  First, due to time constraints humans make certain leaps of faith without fully vetting their logic. Second, the physically noisy, faulty, biological nature of our brain may lead to interpretation errors of our mental constructions. By ``faulty'' we mean the possibly common occurrence of faults in brain processes, coming from things like brain cell death, signaling noise between neurons, neurotransmitter imbalance, etc. Let us call all these possible fault vectors ``brain noise''. In other words, according to us to say that a human being is fundamentally sound, is to say that after ``stripping out'' the ``brain noise'',  this human being will be sound and have undiminished reasoning powers.  
% Later on we formally interpret fundamental soundness in terms of a certain mathematically precise notion of stable soundness. 
Essentially, our machine \footnote {Here we use the term machine as an abstraction for a process acting on inputs, but it need not be a  computational process, in contrast to Turing machines.} $B$ is now allowed to make corrections, and if a statement printed by $B$ is never corrected then this statement is true, if $B$ has our stable soundness property. The negation of stably sound is stated as either stably unsound or not stably sound, synonymously. This stable soundness reflects our basic understanding of how science progresses. Of course even stable soundness needs idealizations to make sense for humans. The human brain deteriorates and eventually fails, so that either we idealize the human brain to never deteriorate, or $B$ now refers not to an individual human but to the evolving scientific community.  

Around the same time as Turing, G\"odel argued for a no answer to Question 1, see \cite[310]{citeGodel}, relating the question to existence of absolutely undecidable problems, see also Feferman~\cite{citeFeferman2006-SFEATA}, and Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4} for a discussion.  Since existence of absolutely undecidable problems is such a difficult and contentious issue, even if G\"odel's argument is in essence correct, it is not completely compelling. Interestingly, for G\"odel fundamental unsoundness of human reasoning is not even a possibility, it does not seem to be stated in \cite{citeGodel}.  A more in depth analysis of G\"odel versus Turing on computability and the mind appears for example in \cite{citeCopelandShagrirComputability}.  

Later Lucas \cite{citeLucas} and later again and more robustly Penrose \cite{citePenroseBeyondShadow} argued for a no answer based only on soundness, and by further elaborating the  obstruction from the G\"odel incompleteness theorem. Such an argument if correct would be much more compelling.  % They further elaborated the obstruction coming from G\"odel's incompleteness theorem. And they reject the possibility that humans could be unsound on a fundamental level, as does G\"odel but for him it   
% \footnote {It is likely most mathematicians would sympathize with G\"odel, after all the entirety mathematics is meaningless if mathematicians are fundamentally unsound.} 
% For disclosure this author does believe in consistency of human beings, but to me consistency always seemed to be an emergent feature of something deeper, (consciousness perhaps).  The main common objections to their argument concern the meta-logic of the argument, see for instance \cite{citeChalmers}, \cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}.  

It should also be noted that for Penrose, in particular, non-computability of intelligence is evidence for new physics, and he has specific and \emph{very} intriguing proposals with Hameroff~\cite{citeHAMEROFF201439} on how this can take place in the human brain.  Here is also a partial list of some partially related work on mathematical models of brain activity and or quantum collapse models: \cite{cite:Quanta}, \cite{citeKremnizer2015}, \cite{citeHoffmanAgents}, \cite{cite:GrindfordConsciousnessPerspective}.

From my perspective, the most troubling issue with the Penrose argument concerns the soundness assumption, and we will review this in this introduction. Other authors, particularly Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}, argue that there are  meta-logical issues even allowing for soundness. Following a technically very different approach to Penrose, we intend to completely resolve these issues here. In particular, there should be no meta-logical issues because our results are theorems and not just meta-theorems, cf. Section \ref{section:Penrose}. 

The following is a slightly informal version of our main Theorem \ref{thm:2}, taking the view that our idealized human is represented by the evolving scientific community or just $H$ for short.  The sole formal property that we postulate for $H$, what we call the stable Penrose property, will be explained in Section \ref{section:systemMpm}. It is analogous to the arithmetic Penrose property, we describe just below in the outline of the Penrose argument.
% Essentially this property just says that $H$ asserts that $H$ is stably sound. (This is quiet rational given our definition of stable soundness.) 
\begin{theorem} \label{thm:1} Either there are cognitively meaningful, absolutely non Turing computable processes in the human brain   or human beings are fundamentally unsound, meaning specifically that $H$ is stably unsound. This theorem is indeed a mathematical fact, \footnote{Specifically a theorem of set theory, although we keep set theory implicit as usual.} given our formalization of $H$ and of stable soundness.
\end{theorem} 
By \emph{absolutely} we mean in any physical model. Note that even existence of absolutely non Turing computable processes in nature is not known. For example, we expect beyond reasonable doubt that solutions of fluid flow or $N$-body problems are generally non Turing computable (over $\mathbb{Z}$, if not over $\mathbb{R}$ cf. \cite{citeBlumShubSmalen}) as modeled in essentially classical mechanics.  But in a more physically accurate and fundamental model they may both become computable, possibly if the nature of the universe is ultimately discreet. It would be good to compare this theorem this with Deutch~\cite{citeDeutsch}, where computability of any suitably finite and discreet physical system is conjectured. Although this is not immediately at odds with us, as the hypothesis of that conjecture may certainly not be satisfiable. 

By strengthening the hypothesis of Theorem \ref{thm:1} from computability  to provable computability as in Theorem \ref{thm:negCon}, we can obtain more practical consequences. To the effect that not only is $H$ stably unsound but must in fact eventually stably assert $0=1$.
\subsection{The Penrose argument} \label{section:outline}
Following Lucas \cite{citeLucas}, Penrose has given variations of the argument for a no answer to Question 1 in his books \cite{citePenroseEmperor}, \cite{citePenroseShadows}. 
The final argument can be found in \cite{citePenroseBeyondShadow}, which we now re-interpret in a language closer to our subsequent argument. The following argument (really just an outline) is more elaborate then what was originally proposed by Penrose, but this is because we make some additional things explicit.
% For example, we remove the need to formalize statements of the form ``I am captured by the formal system \mathcal{F}'', which appear in the Penrose argument. 
% \footnote {It is not obvious to me that this problem can be solved at all, in the original argument of Penrose, since at the least this requires detailed knowledge of the physical-biological system underlying ``I''.} 
% Given a formal system $\mathcal{F}$ the statement $\Theta _{\mathcal{F}} $: \begin{equation*} \text{I am $\mathcal{F}$}, \end{equation*} % will mean that any statement in arithmetic that I assert to be true is provable in $\mathcal{F}$, e.g. ``There are infinitely many primes.'' may be such a statement. The statement $\Theta _{\mathcal{F}} $ for an $\mathcal{F}$ satisfying certain properties is equivalent to me being computable as a machine printing statements in arithmetic. We will call such an $\mathcal{F}$ \textbf{\emph{good}}. 
% \footnote {Explicitly, it is a condition for the axioms of $\mathcal{F}$ being recursively enumerable, plus another minor condition on $\mathcal{F}$ being able to prove enough basic things about numbers.} So we suppose from now on that $\mathcal{F}$ is good, since  computability is what we are interested in.
%
% Now I assert I am consistent, which entails more specifically that I assert:
%  \begin{equation} \label{eq:ThetaF} \text{If $\Theta _{\mathcal{F}}$ then $\mathcal{F}$  is consistent.} 
% \end{equation}
%  By $\mathcal{F}$ being consistent we just mean that the formal system $ \mathcal{F}$ does not prove a statement and its logical negation.   %  \begin{emark} %  Asserting ones own consistency is not completely irrational, as most people assert their consistency in some form by implication.  For if a human $H$ asserts $0 \neq 1$ in absolute faith, that is $H$ asserts that they will never assert $0=1$, while ``sane'', then by implication $H$ asserts a form of consistency.  For if $H$ is not consistent (but accepts basic logic) they must eventually assert everything, while ``sane'', in particular $0=1$.  Of course if we analyze this more deeply then it is not exactly classical consistency that $H$ asserts, but rather certain stable consistency, we will get back to this soon, and for now delve no further.
% \end{remark}
%  As I assert \eqref{eq:ThetaF} then I also assert by implication $I _{\mathcal{F}} $:
% \begin{equation*}
% \text{If $\Theta _{\mathcal{F}}$ then $G (\mathcal{F})$.} 
% \end{equation*}
% % <<<<<<< HEAD
% % where $G (F)$ is the G\"odel statement of $F$, since $G (F)$ is true if $F$ is consistent. 
% % There would be a contradiction if I assert $G (F)$, since $G (F)$ is something that $F$ cannot prove. Unfortunately, I  cannot assert $G (F)$, I can only assert $I _{F} $, so there is no contradiction here. But we fix this idea as follows.
% % Unfortunately, to fix this idea we need to get a bit more technical.
% % =======
% % where $G (F)$ is the arithmetic G\"odel statement of $F$, which can be constructed because $F$ is good, and this statement is true because $F$ is consistent.
% % >>>>>>> 60798006c341b01b38b0f2f3f78091e227eb95d1
% %
% If I assert $G (\mathcal{F})$, then this would be a contradiction to either my consistency or to $\Theta _{\mathcal{F}} $, since $G (\mathcal{F})$ is something that $\mathcal{F}$ cannot prove. Unfortunately I cannot rationally assert $G (\mathcal{F})$, since I don't know $\Theta _{\mathcal{F}} $. I only assert $I _{\mathcal{F}} $, so there is no meaningful contradiction here.  But we may try to fix this idea as follows. For this fix we need to get a bit more technical.  
%
% \subsection{Outline of a partial fix of the Lucas-Penrose argument} 

While this outline uses some of the language of formal systems, we will \emph{not} use this language in our main argument, which is based purely on the language of Turing machines and is much more elementary. 

Suppose a human subject $P$ is in contact with experimenter/operator $E$. The input strings that $E$ gives $P$ are pairs $(\Sigma _{T},n)$ for $\Sigma_{T} $ specification of a Turing machines $T$, and $n \in \mathbb{N}$. The output $P (\Sigma _{T}, n )$ is a statement of arithmetic printed by $P$. (For now there is no requirement on truth.) 

Given a Turing machine $T$ let $\Theta _{T} $ be the statement: 
\begin{equation} \label{eq:condition}
\text{$T$ computes } P. 
\end{equation} 
% We suppose that $P (\Sigma _{T},n)$, which he asserts to hold if $\Theta _{T} $ holds.
% We ask that each  $P (\Sigma _{T},n)$ is an element of $Strings$ - the set of finite strings on a fixed finite alphabet.

We ask that for each fixed $T$: 
$\{P (\Sigma _{T},n)\} _{n} $ is the complete list of statements that $P$ asserts to be true conditionally on $\Theta _{T} $. 
We also ask that $P$ satisfies what we call the arithmetic Penrose property. This says that $P$ asserts for each $T$ the statement $I _{T}$:
\begin{equation} \label{eq:Theta}
\Theta _{T} \implies T \text{ is sound},
\end{equation}
which means that $T (\Sigma _{T},n)$ is true for each $n$. 
% This can be deduced from a more fundamental property that any statement of arithmetic asserted by $P$ to be true is true. Since for each $m$: 
% $$\Theta _{T} \implies T (\Sigma _{T} ) \text{ is sound}$$
% By $T$ being consistent we mean here:  $$T (\Sigma _{T},n) \neq \neg (T (\Sigma _{T},m)),$$ for any $n,m$ with $\neg$ the logical negation of the statement, and where inequality is just string inequality of the corresponding sentences. 
We ignore for now whether $P$ making such an assertion is rational.
% The list is infinite but if $P$ is computable it is determined by a Turing machine, and all arguments refer to this machine. So that even in practice dealing with such a list should not be an issue.
% If the reasoning powers of $P$ could be totally captured by some fixed formal system then all sentences in this formal system could be enumerated, so that the above supposition is allowable for the purpose of what follows.  %
%
% \begin{itquote}
% Here is a specification of a Turing machine $T$,  print your statement that you assert to be true assuming the truth of :
% \end{itquote}
% , which in the current setting means that is he asserts $P (\Sigma)$ is true conditionally on $\Theta _{T} $ for all $\Sigma$.  To emphasize this is not an assumption by $P$, but is what $P$ asserts as \emph{truth}.  
% Now $P$ replies: 
% \begin{itquote}
% I know I am sound,  hence $T$ must be sound if it computes me, but I can then construct a G\"odel statement $G (T)$ for $T$, which is then a true statement in arithmetic, and which indirectly asserts ``$T$ cannot print $G (T)$''.  
% \end{itquote}
% This alone doesn't quite work however for $E$ counters: 
% \begin{itquote}
% I see, but do \emph{you} in fact in print $G (T)$? This is the only way you can presently reach a contradiction, as $T$ only computes what you print, not what you can meta-prove.
% \end{itquote}
%  $P$ has to say no! Because he does not in fact know $G (T)$ is true, since he has to know that $T$ is sound, and this only happens (from his point of view) if he knew for a fact: $T$ computes $P$. If $P$ does print $G (T)$ then he is patently unsound, as he has no basis to assert $G (T)$, so his very belief that he is sound would be absurd.  
% \subsubsection* {A possible fix} (Outline)
% We can try to fix the above argument as outlined in the following, and 

Let then $T _{0} $ be a specified Turing machine, and suppose that $E$ passes to $P$ input of the form $(\Sigma _{T _{0} }, n)$.  % Now $P$ reasons that since he is fundamentally sound, so that his deductions based on each $\Theta _{T} $ are sound, the following  must hold:
% \begin{equation} 
% \Theta _{T _{0} } \implies \forall n \, T _{0} (\Sigma _{T _{0}},n).
% \end{equation}
 Now, as is well known \footnote {I don't know a standard reference but see  for example \cite{citeFeferman2006-SFEATA}.}, the statements $\{T _{0} (\Sigma _{T _{0} },n)\} _{n}  $ \footnote {Strictly speaking after taking deductive closure.} must be the complete list of provable statements in a certain formal system $\mathcal{F} (T _{0} )$, explicitly constructible given $T _{0} $. 
Loosely, a formal system consists of a language: alphabet and grammar, a collection of sentences in this language understood as axioms,   and finally a deductive system.  

By construction $\mathcal{F} (T _{0} )$ would be sound if $\Theta _{T _{0} } $ and if $I _{T _{0} } $. In particular if $\Theta _{T _{0}} \land I _{T _{0} } $ then by the celebrated G\"odel incompleteness theorem there would be a true  G\"odel statement $G (T _{0})$ for this $\mathcal{F} (T _{0} )$,  such that $$T _{0} (\Sigma _{T _{0} }, n ) \neq G(T _{0}), \quad \text{ for all $n$.}$$     
% This is at least assuming some additional properties of $P$ so that $\mathcal{F} (T _{0} )$ would satisfy the other condition of G\"odel's theorem, (we need that $\mathcal{F} (T _{0} )$ could interpret certain arithmetic).
% >>>>>>> 781e40d42a1b58a417d15c4c5061821de1338b27

But $P$ asserts $I _{T _{0} } $, hence he must assert by implication that $$ \Theta_{T_{0}} \implies G(T_{0}).$$ And so assuming $P$ knows how to construct $G (T _{0} )$ then this statement must be in the list $\{P (\Sigma _{T _{0} },n)\} _{n}  $, and so in the list $\{T _{0}  (\Sigma _{T _{0} },n)\} _{n}  $,  so we would get a contradiction. 
% Direct constructibility of $G (T _{0} )$ by $P$ is likely not an issue, since the formal system $\mathcal{F} (T _{0} )$ is after all known to $P$. But this is a potential problem best studied by an expert logician.  So assuming $G (T _{0} )$ is indeed constructible by $P$, 
So we conclude that either not $\Theta _{T _{0} } $, that is $P$ is not computed by $T _{0} $ or $P$ is not consistent, but $T _{0} $ is arbitrary so we obtain an obstruction to computability of $P$.  
  

Even if it was in essence correct, the above argument is unsatisfactory because all it claims to prove is:  either we are non-computable or inconsistent, which we appear to be anyway. Of course as we have argued we must talk of fundamental soundness, interpreted here as stable soundness.
But then the argument cannot work exactly as above, since G\"odel's theorem necessitates total consistency. This is a highly  non-trivial issue, as while we can abstractly extract from a stably sound machine an absolutely sound machine, the latter may not be computable even if the former was, cf. Remark \ref{remark:stable}.  

We will delve no further into critiquing the Lucas-Penrose argument. One such critique is given in Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4},  see also Penrose~\cite{citePenroseBeyondShadow}, and Chalmers~\cite{citeChalmers} for discussions of some issues.  Note of course that our version of the Penrose argument is slightly different, and so the issues might be different.  

So motivated by the discussion above, the ideal thing to do is to formally define stable soundness, and construct a new type of G\"odel statements which works under this weaker hypothesis. This is actually what we will do, in the limited setting above.
% Unfortunately we cannot even be certain that such a statement exists, since $\Theta _{T} $ are not  well defined statements since $P$ is not defined. Consequently $\mathcal{F} (T _{0} )$ at least a priori is not a well defined formal system, and we cannot use G\"odel incompleteness theorem. 
% formally defining fundamental soundness in terms of a certain notion of stable soundness, and \emph{explicit} construction of the ``G\"odel statement'', which crucially works under this stable soundness hypothesis. 
To this end, we reformulate the above idea using a more elementary approach, more heavily based in Turing machines. We first isolate a certain class of Turing machines that we name diagonalization machines.
They print strings with a certain property $C$. As the name suggests, their behavior is related to the Cantor diagonalization argument.  Next we explicitly construct a ``G\"odel string'' $\mathcal{G}$ which is universal for this whole class. 
This string $\mathcal{G}$ has property $C$ but cannot be printed by a Turing diagonalization machine. Crucially, this is then extended to stable diagonalization machines, which print property  $C$ \footnote {The property is not exactly the same, it has to be suitably stabilized.} strings only stably. Given this, our main result follows by an argument similar to the one in the outline above.  

This is essentially as far as we can go in trying to outline the argument, as most of it just concerns the construction of the class of diagonalization machines and of $\mathcal{G}$, and this is hard to describe without details. However, technically the paper is mostly elementary, and should be widely readable in entirety. 
\section {Some preliminaries} \label{sec:prelims}
This section can be just skimmed on a first reading.
Really what we are interested in is not Turing machines per se, but computations that can be simulated by Turing machine computations. These can for example be computations that a mathematician performs with paper and pencil, and indeed is the original motivation for Turing's specific model. However to introduce Turing computations we need Turing machines. Here is our version, which is a computationally equivalent, minor variation of Turing's original machine.
\begin{definition} \label{def:Machine} A \textbf{\emph{Turing machine}} $M$ consists of:
  \begin{itemize} 
     \item Three infinite (1-dimensional) tapes $T _{i}, T _{o}, T _{c}   $, (input, output and computation) divided into discreet cells, next to each other. Each cell contains a symbol from some finite alphabet $\Gamma$. A special symbol $b \in \Gamma$ for blank, (the only symbol which may appear infinitely many often).
     \item Three  heads $H _{i}, H _{o}, H _{c}   $ (pointing devices),  $H _{i} $ can read each cell in $T _{i} $ to which it points, $H _{o}, H _{c}  $ can read/write each cell in $T _{o}, T _{c}  $ to which they point.
        The heads can then move left or right on the tape.
     \item A set of internal states $Q$, among these is ``start'' state $q _{0} $. And a non-empty set $F \subset Q$ of final states.
\item Input string $\Sigma$: the collection of symbols on the tape $T _{i} $, so that to the left and right of $\Sigma$ there are only symbols $b$. We assume that in state $q _{0} $ $H _{i} $ points to the beginning of the input string, and that the $T _{c} $, $T _{o} $ have only $b$ symbols.
\item A finite set of instructions: $I$, that given the state $q$ the machine is in currently, and given the symbols the heads are pointing to, tells $M$ to do the following. The actions taken, 1-3 below, will be (jointly) called an \textbf{\emph{executed instruction set}} or just \textbf{\emph{step}}:
\begin{enumerate} \label{enumerate}
   \item Replace symbols with another symbol in the cells to which the heads $H _{c}, H _{o}  $ point (or leave them).
   \item Move each head $H _{i}, H _{c}, H _{o}   $ left, right, or leave it in place, (independently).
   \item Change state $q$ to another state or keep it.
\end{enumerate}
\item Output string $\Sigma _{out} $,  the collection of symbols on the tape $T _{o} $, so that to the left and right of $\Sigma _{out} $ there are only symbols $b$, when the machine state is final. When the internal state is one of the final states we ask that the instructions are to do nothing, so that these are frozen states.  
  \end{itemize} 
\end{definition}
% So a Turing machine $M$ determines a function:
% \begin{equation} \label{eq:transition}
% \delta ^{M} : Q \times \Gamma \to Q \times \Gamma \times \{L,R,H\},
% \end{equation}
% where $L,R,H$ correspond to move head left, right, or hold in place.
% We also have the following minor variations on standard definitions, and notation.
\begin{definition} A \textbf{\emph{complete configuration}} of a Turing machine $M$ or \textbf{\emph{total state}} is the collection of all current symbols on the tapes, position of the heads, and current internal state. Given a total state $s$, $\delta (s)$ will denote the successor state of $s$, obtained by executing the instructions set of $M$ on $s$, or in other words $\delta(s)  $ is one step forward from $s$.
\end{definition}
So a Turing machine determines a special kind of function:
\begin{equation*}
\delta ^{M} : \mathcal{C} (M)  \to \mathcal{C} (M),
\end{equation*}
where $\mathcal{C} (M)$ is the set of possible total states of $M$. 
%  It is moreover possible to define Turing machines more abstractly, by formalizing properties of these functions. 
\begin{definition}
   A \textbf{\emph{Turing computation}}, or \textbf{\emph{computation sequence}} for $M$ is a possibly not eventually constant sequence $$*M (\Sigma):= \{s _{i} \} _{i=0} ^{i=\infty} $$  of total states of $M$,  determined by the input $\Sigma$ and $M$,  with $s _{0}  $ the initial configuration whose internal state is $q _{0} $, and where $s _{i+1} = \delta (s _{i} ) $.
If elements of $\{s _{i} \} _{i=0} ^{i=\infty}$ are eventually in some final machine state, so that the sequence is eventually constant, then we say that the computation \textbf{\emph{halts}}.  In this case we denote by $s _{f} $ the final configuration, so that the sequence is eventually constant with terms $s _{f} $. We define the \textbf{\emph{length}} of a computation sequence to be the first occurrence of $n>0$ s.t. $s _{n}=s _{f}  $.
For a given Turing computation $* M (\Sigma)$, we will write \begin{equation*}
   * M (\Sigma) \to x, 
   \end{equation*}
if $* M (\Sigma)$ halts and $x$  is the output string. 
\end{definition}
We write $M (\Sigma)$ for the output string of $M$, given the input string $\Sigma$, if the associated Turing computation $*M (\Sigma)$  halts. 

\begin{definition} Let $Strings$ denote the set of all finite strings, including the empty string $\epsilon$, of symbols in some fixed finite alphabet, with at least 2 elements.
Given a partial function $f: Strings \to Strings$, that is a function defined on some subset of $Strings$ - we say that a Turing machine $M$ \textbf{\emph{computes}} $f$ if  $$*M (\Sigma) \to f (\Sigma) \text{ whenever $f (\Sigma)$ is defined}.
   $$ \end{definition}

 So a Turing machine $T$ itself determines a partial function, which is defined on all $\Sigma \in Strings$ s.t. $*T (\Sigma)$ halts, by $\Sigma \mapsto T (\Sigma)$.  
The following definition is purely for writing purposes.
\begin{definition} \label{def:equivalent} Given Turing computations (for possibly distinct Turing machines) $*T _{1} (\Sigma _{1} ) $, $* T _{2} (\Sigma _{2} ) $ we say that they are \textbf{\emph{equivalent}} if they both halt with the same output string or both do not halt. We write $T _{1} (\Sigma _{1} )  = T _{2} (\Sigma _{2} ) $ if $*T _{1} (\Sigma _{1} ) $, $* T _{2} (\Sigma _{2} ) $ both halt with the same value.
% We say a pair of Turing machines $T _{1}, T _{2}  $  are \textbf{\emph{equivalent}} if they compute the same operator.
\end{definition} 
In practice we will allow our Turing machine $T$ to reject some elements of $Strings$ as valid input. We may formalize this by asking that there is a special final machine state $q _{reject} $, so that $T (\Sigma)$ halts with $q _{reject} $ for $$\Sigma \notin {I} \subset Strings,$$ where ${I}$ is some set of all valid, that is $T$-\textbf{\emph{permissible}} input strings.  We do not ask that for $\Sigma \in I$ $*T (\Sigma)$ halts. If $*T (\Sigma)$ does halt then we will say that $\Sigma$ is $T$-\textbf{\emph{acceptable}}.
It will be convenient to forget $q _{reject} $ and instead write $$T: {I} \to O,$$ where ${I} \subset Strings$ is understood as the subset of all $T$-permissible strings, or just \textbf{\emph{input set}} and $O$ is the set output strings or \textbf{\emph{output set}}.
% Vj, keeping all other data implicit.  The specific interpretation should be clear in context.  

We will sometimes use abstract sets to refer to input and output sets.  However, these are understood to be subsets of $Strings$ under some implicit, \emph{fixed} encoding. Concretely an \textbf{\emph{encoding}}
of $A$ is an injective set map $i: A \to Strings$. For example if the input set is $Strings ^{2} $, we may encode it as a subset of $Strings$ as follows. The encoding string of $\Sigma \in Strings ^{2} $ will be of the type: ``this string encodes an element $ Strings ^{2} $, whose components are $\Sigma _{1}$ and $\Sigma _{2}  $.'' In particular the sets of integers $\mathbb{N}, \mathbb{Z}$, which we use often,  will under some encoding correspond to subsets of $Strings$.  Indeed this abstracting of sets from their encoding in $Strings$ is partly what computer languages do. The fixing of the encoding can be understood as fixing the computer language.  

 The above will allow us to work with a set $\mathcal{T}$ of Turing machines, with abstract sets of inputs and outputs implicitly encoded as subsets of $Strings$ as above. Note that $\mathcal{T}$ itself has an induced encoding, called its program. Of course, concretely $\mathcal{T}$ is nothing more then the set of Turing machines, with a distinguished final state called $q _{reject} $.  \begin{definition}  We say that a Turing machine $T$ computes a partial function $f: I \to J$, if $I$ is contained in the set of permissible inputs of $T$  and $*T (\Sigma) \to f (\Sigma)$,  whenever $f (\Sigma)$ is defined, for $\Sigma \in I$.
\end{definition} 

Given Turing machines $$M _{1}: {I} \to {O}, M _{2}: {J} \to {P},$$ we may naturally \textbf{\emph{compose}} them to get a Turing machine $M_2 \circ M _{1}: C \to P $, for $C=M _{1} ^{-1} ({O} \cap {J})$, ($O \cap J$ is understood as intersection of subsets of $Strings$). $C$ can be empty in which case this is a Turing machine which rejects all input. Let us not elaborate further.
\subsection {Join of Turing machines} Our Turing machine of Definition \ref{def:Machine} is a multi-tape enhancement of a more basic notion of a Turing machine with a single tape,
but we need to iterate this further.  

We replace a single tape by tapes $T ^{1}, \ldots, T ^{n}  $
in parallel, which we denote by $(T ^{1} \ldots T ^{n})$ and call this $n$-tape.
The head $H$ on the $n$-tape has components $H ^{i} $ pointing on the corresponding tape $T ^{i} $. When moving a head we move all of its components separately. A string of symbols on $(T ^{1} \ldots T ^{n})$ is an $n$-string, 
formally just an element $\Sigma \in Strings ^{n} $, with $i$'th component of $\Sigma$
specifying a string of symbols on $T ^{i} $. The blank symbol $b$ is the symbol $(b ^{1}, \ldots, b ^{n} )$  with  $b ^{i} $ blank symbols of $T ^{i} $.









Given Turing machines $M ^{1}, M ^{2}  $ we can construct what we call a \textbf{\emph{join}} $M ^{1} \star M ^{2}  $, which is roughly  a Turing machine where we alternate the operations of $M ^{1}, M  ^{2}  $. In what follows symbols with superscript $1,2$ denote the corresponding objects of $M ^{1} $, respectively $M ^{2} $, cf. Definition \ref{def:Machine}. 


$M ^{1} \star M ^{2}  $ has three 2-tapes: $$(T ^{{1} } _{i}  T ^{{2} } _{i}),    (T ^{{1} } _{c}  T ^{{2} } _{c}  ), (T ^{{1} } _{o}  T ^{2}  _{o} ),   $$ three heads $H _{i}, H _{c}, H _{o}   $ which have component heads $H ^{j} _{i}, H ^{j} _{c}, H ^{j} _{o}      $, $j=1,2$. It has machine states: $$Q _{M ^{1} \star M ^{2}  }   = Q ^{1} \times Q ^{2} \times (\mathbb{Z}_{2} = \{0,1\}),  $$ with initial state $(q _{0} ^{1}, q _{0} ^{2},0)$ and final states:
$$F _{M ^{1} \star M ^{2}  } = F ^{1} \times Q ^{2} \times \{1\} \sqcup Q ^{1} \times F ^{2} \times \{0\}.  $$

Clearly we have a natural splitting $$\mathcal{C} (M ^{1} \star M ^{2}  ) = \mathcal{C} (M ^{1} ) \times \mathcal{C} (M _{2} ) \times \mathbb{Z} _{2}.
$$ In terms of this splitting we define the transition function 
\begin{equation*}
\delta ^{M ^{1} \star M ^{2}  }: \mathcal{C} (M ^{1} \star M ^{2}  ) \to \mathcal{C} (M ^{1} \star M ^{2}  ),
\end{equation*}
for our Turing machine $M ^{1} \star M ^{2}  $ by:
\begin{align*}
   & \delta ^{M ^{1} \star M ^{2}  } (s ^{1}, s ^{2}, 0  ) = (\delta ^{M ^{1} } (s _{1}), s ^{2},1  ) ), \\
   & \delta ^{M ^{1} \star M ^{2}  } (s ^{1}, s ^{2}, 1  ) = ( s _{1}, \delta ^{M ^{2} } (s ^{2}),0 )).
\end{align*}
Or, concretely this means the following. Given machine state $q=(q ^{1}, q ^{2}, 0)$ and the symbols $$(\sigma _{i} ^{1} \sigma _{i} ^{2}), (\sigma _{c} ^{1} \sigma _{c} ^{2}), (\sigma _{o} ^{1} \sigma _{o} ^{2})      $$ to which the heads $H _{i}, H _{c}, H _{o}   $ are currently pointing, we first check instructions in $I ^{1} $ for $q ^{1} $, $ \sigma _{i} ^{1} ,  \sigma _{c} ^{1}, \sigma _{o} ^{1}    $, and given those instructions as step 1 execute:
\begin{enumerate}
 \item Replace symbols $\sigma ^{1}  _{c}, \sigma ^{1}  _{o}  $ to which the head components $H ^{1}  _{c}, H ^{1}  _{o}  $ point, or leave them  unchanged, while leaving unchanged the symbols to which $H ^{2}  _{c}, H ^{2}  _{o}  $ point.
\item Move each head component $H ^{1}  _{i}, H ^{1}  _{c}, H ^{1}  _{o}   $ left, right, or leave it in place, (independently). (The second components of the heads are unchanged.)
   \item Change the first component of $q$ to another machine state in $Q ^{1} $ or keep it, based on the instruction in $I ^{1} $. Leave the second component of $q$ unchanged. The third component of $q$ is changed to $1$.  
\end{enumerate} 
Then likewise given machine state $q=(q ^{1}, q ^{2}, 1)$,  we check instructions in $I ^{2} $ for $q ^{2} $, $ \sigma _{i} ^{2} ,  \sigma _{c} ^{2}, \sigma _{o} ^{2}$ and given those instructions as step 2 execute:
\begin{enumerate}
 \item 
Replace symbols $\sigma ^{2}  _{c}, \sigma ^{2}  _{o}  $ to which the head components $H ^{2}  _{c}, H ^{2}  _{o}  $ point, or leave them  unchanged, while leaving unchanged the symbols to which $H ^{1}  _{c}, H ^{1}  _{o}  $ point.
\item Move each head component $H ^{2}  _{i}, H ^{2}  _{c}, H ^{2}  _{o}   $ left, right, or leave it in place.
\item Change the second component of $q$ to another or keep it, based on instruction in $I ^{2} $. Leave the first component unchanged, and change the third component of $q$ to $0$.  
\end{enumerate} 
% So the above 2-step procedure applied to a total state $s$ gives two consecutive terms of the corresponding computation sequence.
\subsubsection {Input}
The input for $M ^{1} \star M ^{2}  $ is a 2-string or in other words pair $(\Sigma _{1}, \Sigma _{2}  )$, with $\Sigma _{1} $ an input string for $M ^{1} $, and $\Sigma _{2} $ an input string for $M ^{2} $.
\subsubsection {Output} The output for $$*M ^{1} \star M ^{2} (\Sigma _{1}, \Sigma _{2}  )  $$ is defined as follows. If this computation halts then the 2-tape $(T ^{1} _{o} T ^{2} _{o}    )$ contains a 2-string, bounded by $b$ symbols, with $T ^{1} _{o}  $ component $\Sigma ^{1} _{o}$ and $T ^{2} _{o}  $ component $\Sigma ^{2} _{o}$.
Then the output $M ^{1} \star M ^{2} (\Sigma _{1}, \Sigma _{2}  )$ is defined to be $\Sigma ^{1} _{o}  $ if the final state is of the form $(q _{f},  q, 1) $ for $q _{f} $ final, or $\Sigma ^{2} _{o}  $ if the final state is of the form $(q,  q _{f},0) $, for $q _{f} $ likewise final. 
\subsection {Universal Turing machines} It will be convenient to refer to the universal Turing machine $$U: \mathcal{T} \times Strings \to Strings,$$ for $\mathcal{T}$ the set of Turing machines as already indicated above.
This universal Turing machine already appears in Turing's \cite{TuringComputableNumbers}. It permits as input a pair $(T,\Sigma)$ for $T$ an encoding of a Turing machine and $\Sigma$ input to this $T$. It can be partially characterized by the property that for every Turing machine $T$ and string $\Sigma$ we have: \begin{equation*} *T (\Sigma) \text{ is equivalent to } *U (T,\Sigma).
\end{equation*}
\subsection {Notation}
In what follows $\mathbb{Z}$ is the set of all integers and $\mathbb{N}$ non-negative integers. 
 We will sometimes specify a Turing machine simply by specifying a function $$T: {I} \to {O},$$ with the full data of the underlying Turing machine being implicitly specified, in a way that should be clear from context.  
When we intend to suppress dependence of a variable $V$ on some parameter $p$ we often write $V=V (p)$, this equality is then an equality of notation not of mathematical objects.
\section {Preliminary setup for the proof of Theorem \ref{thm:1}}
This section can be understood to be a warm up, as we will not yet work with stable soundness. But most of this will carry on to the more technical 
setup of Section \ref{section:fundamentalSoundness}.
\begin{definition} A \textbf{\emph{machine}} \footnote {For some authors and in some of the writing of Turing and G\"odel ``machine'' is synonymous with Turing machine. For us the term machine is just abstraction for a process.} will be a synonym for a partial function  $A: I \to O$, with $I,O$ abstract sets with a fixed, prescribed encoding as subsets of $Strings$, (cf. Preliminaries).  
\end{definition} $\mathcal{M}$ will denote the set of machines.  Given a Turing machine $T: I \to O$,  we have an associated machine $fog(T)$ by forgetting all structure except the structure of a partial function.  $\mathcal{T}$ will denote the set of machines, which in addition have the structure of a Turing machine.  So we have a forgetful map $fog: \mathcal{T} \to \mathcal{M}$.

  
\subsection {Diagonalization machines} \label{sec:diagonalizationmachines}
There is a well known connection between Turing machines and formal systems, to which we already alluded in Section \ref{section:outline}. So G\"odel statements  can already be interpreted in Turing machine language as certain G\"odel strings. But we will be aiming to construct, in a specific setting relevant to our goals, a more flexible and in a certain sense universal (for our class of Turing machines) such G\"odel string $\mathcal{G}$.  Extending this construction to more general classes of Turing machines / formal systems would be very interesting, but at the moment it is not clear what that would entail.  

 To make this $\mathcal{G}$ exceptionally simple we will need to formulate some specific properties for our machines, which will require a bit of setup.  We denote by $\mathcal{T} _{\mathbb{Z}} \subset \mathcal{T} $ the subset of Turing machines of the type: \begin{equation*}
   X:  (S _{X}  \times \mathbb{N} \subset Strings \times \mathbb{N}) \to \mathbb{Z}.
\end{equation*}
In other words, the input set of $X \in \mathcal{T} _{\mathbb{Z}}$ is of the form
$S _{X}  \times \mathbb{N}$, for $S _{X} \subset Strings $, and the output set of $X$ is $\mathbb{Z}$.
% , having the form:  % \begin{equation} \label{eq:SX}
%    S _{X}  \times \mathbb{N} \subset Strings _{0},
% \end{equation}

Let $\mathcal{O} \subset  \mathcal{T} _{\mathbb{Z}} \times Strings$ 
consist of $(X, \Sigma) \in \mathcal{T} _{\mathbb{Z}} \times Strings   $ with $\Sigma \in S _{X} $, defined as above. And
set $$\mathcal{O}' := \mathcal{O} \times \mathbb{N} \subset \mathcal{T} _{\mathbb{Z}} \times Strings \times \mathbb{N}.
$$ 
 
Let 
$$D_1: \mathbb{Z} \sqcup \{\infty\}   \to \mathbb{Z}, 
$$ 
be a fixed Turing machine which satisfies 
\begin{align} \label{eq:decision} D_1 (x) & =x+1  \text{ if } x \in  \mathbb{Z} \subset \mathbb{Z} \sqcup \{\infty\}  \\
D_1 (\infty) & =1.
\end{align}
Here $\{\infty\}$ is the one point set containing the element $\infty$,  which is just a particular distinguished symbol, also implicitly encoded as an element of $Strings$, s.t. $\{\infty\} \cap \mathbb{Z} = \emptyset$, where the intersection is taken in $Strings$. In what follows we sometimes understand $D_1 $ as an element of $\mathcal{T} _{\mathbb{Z}}  $, denoting the Turing machine: 
\begin{equation} \label{eq:D1m}
(x,m ) \mapsto D_1 (x), 
\end{equation}
 for all $(x,m) \in (\mathbb{Z} \sqcup \{\infty\}) \times \mathbb{N}$.


We need one more Turing machine.  
\begin{definition}
We say that a Turing machine 
\begin{equation*}
   R: D \supset \mathcal{O}'    \to  \mathbb{Z} \sqcup \{\infty\}, 
\end{equation*}
has 
\textbf{\emph{property $G$}} if the following is satisfied:
\begin{itemize}
   \item  $R$ halts on the entire $\mathcal{O}' $, that is $\mathcal{O}'$ is contained in the set of $R$-acceptable strings.
   \item  $R (X, \Sigma,m) \neq \infty \implies R (X,\Sigma,m) = X (\Sigma,m )$, for $(\Sigma,m) \in S _{X}  \times \mathbb{N} $, and $X \in \mathcal{T} _{\mathbb{Z}} $.
\item   
$\forall m: R (D_1, \infty, m)  \neq \infty,$
and so $\forall m: R (D_1, \infty,m) = 1$, by the previous property.
\end{itemize}
\end{definition}
%
%
% $R _{\mathcal{C}} (X, \Sigma ^{1}, m) $ signifies what $S$ obtains as a result of waiting on $*X (\Sigma ^{1},m )$ to halt on $\mathcal{C}$, if this is the computation he ran.  
% We set $$R _{\mathcal{C}} (X, \Sigma ^{1}, m) = \infty$$  if $*X (\Sigma ^{1},m )$ does not halt in time $t ^{W}$, and $$R _{\mathcal{C}} (X, \Sigma ^{1}, m) = X (\Sigma ^{1},m )$$ if it does.
%
% If $S  _{1,D} $ is as before, then we suppose that 
%   the printed string $A (T)$ satisfies
% \begin{equation} \label{eq:A}
%    {A} (T)=  (S  _{0,D} (T),  S   _{1,D}  (R _{\mathcal{C}} (D_0 (T))))
% \end{equation}
% so that ${A} \in \mathcal{M}_{0} $.
%
%    denotes the machine representing the final
%        ``decision map'' of $S$. Its input is meant to be what $S$ obtains from $R _{\mathcal{C}} $. \textcolor{blue}{big change to $D_1 $} 
% We suppose that this map  satisfies: 
% \begin{equation} S   _{1,D} ^{\mathbb{Z}}  (x)= x+1  \text{ if $x \in \mathbb{Z}$} 
% \end {equation}
% and
% \begin {equation}
% pr _{1} \circ S   _{1,D}  (x) = D_0 (T),
% \end{equation}
% for $pr _{1}: \mathcal{T} \times Strings \times \mathbb{Z} \to \mathcal{T} \times Strings  $ the projection.
% Therefore the above system $A$ and the protocol determine some machine satisfying:
%
%
% We may understand the ``wait operation'' by $S$ as a machine:
% $$W:  \mathcal{T} \times Strings \times \mathcal{I}     \to \{\infty \} \times \mathbb{N},$$ 
% or  $$W:  \mathcal{T} \times Strings \times \mathcal{I}     \to \{\infty \},$$ suppressing the $\mathbb{N}$ component. Here $\{\infty\}$ is the one point set as above, so that the first component of the output is only symbolic. What follows is a very elementary lemma.  
\begin{lemma} \label{lemma:computeWait} There is a Turing machine
$R$
satisfying property $G$. 
\end{lemma}
\begin{proof}
% Recall from Section \ref{sec:prelims} that when we write a Turing machine $T: I \to O$, the set $I$ is an abstract set (implicitly) encoded as a subset of $Strings$, consisting of all strings that are permitted by $T$, that is strings $\Sigma$ s.t. $*T (\Sigma) $ does not halt with final state $q _{reject} $. So long as $I \subset Strings$ is computable, that is its characteristic function is computable, to specify such a Turing machine it suffices to specify a Turing machine $T| _{I}$, with the latter meaning that the input strings to $T$ are restricted to be in $I$.
% We need to specify a Turing machine $R: Strings \to \mathbb{Z} \sqcup \{\infty\}$, and show that the set of $R$-permissible strings $D$ contains 
% $\mathcal{O}'$.
   % We this understanding we specify a Turing machine $R|_ {\mathcal{T} \times Strings}$ as follows. 
 Let $W _{n} $ be some Turing machine $W _{n} : \{\epsilon\} \to \{\infty\}$, for $\epsilon \in Strings$ the empty string. So as a function it is not very interesting since the input and output sets are singletons. We ask that the length of $*W _{n}  (\epsilon)$ is $n>0$, (cf. Preliminaries).  
Let $R _{n} $ be the Turing machine specified as:
  \begin{equation*}
   R _{n}  (Z):=   W _{n}   \star U (\epsilon, Z),
\end{equation*}
   in the language of the join operation described in Section \ref{sec:prelims}, for $Z \in Strings$, and for $U$ the universal Turing machine. Clearly $R _{n} $ always halts,  although it may halt with machine state $q _{reject} $. Moreover by construction every $Z = (X, \Sigma,m) \in \mathcal{O}' \subset Strings$ is permitted.
Additionally, for $ (X, \Sigma,m) \in \mathcal{O}'$, $$R _{n}  (X, \Sigma,m) \neq \infty \implies R _{n}  (X,\Sigma,m ) = X (\Sigma,m), $$ in particular every $(X,\Sigma, m) \in \mathcal{O}'$ is $R _{n} $-acceptable.  As a function $\mathbb{Z} \sqcup \{\infty\}   \to \mathbb{Z}$, $D _{1} $ is completely determined but it could have various implementations as a Turing machine,  so that the length $l _{m}  $  of $*D _{1} (\infty,m) $ depends on this implementation.
Clearly we may assume that $ \forall m: l=l _{m}   $ for some $l$, by definition of $D _{1} $ as an element of $\mathcal{T} _{\mathbb{Z}} $, as in \eqref{eq:D1m}.
   We  then ask that $n _{0}  > l$ is fixed. Then by construction we get: $$\forall m: R _{n _{0} } (D_1 , \infty,m)= D_1 (\infty,m)=1.  $$  So set $R:= R _{n _{0} }$, and this gives the desired Turing machine. Note that the domain $D \subset \mathcal{T} \times Strings$ of $R$-permissible strings is not explicitly determined by our construction, as we cannot tell without additional information when a general $Z$ is rejected by $R$. We can only say that $D \supset \mathcal{O}'$. 
% Less formally $R$ is determined by the following properties.   % The first $p$ terms of the computation sequence $* R'  _{s} (Y, T) $ corresponds to the first $p$ terms of  $* W'     (Y, T)$. The following $q$ 
% terms of $* R'   _{s} (Y, T) $ correspond to the first $q$ terms of $* X    (\Sigma ^{1})$, followed by the next $p$ terms of  $* W'  (Y, T) $ and then terms $q+1$ to $2q$ of $* X  (\Sigma ^{1})$, and so on.
% The halting condition is either we reach a final state of $W'$ or a final state of $X $. If $* R'  _{s} (Y, T) $ halts with a final state of $X$ then $$R'   _{s} (Y, T) = X  (\Sigma ^{1} ), $$ otherwise if it halts with a final state of $W $ then  $$ R'  _{ s} (Y, T)= \infty.$$
% Thus, $R' _{s}$ computes $R _{ \mathcal{C}} $, moreover it is clear by construction that it strongly computes $R _{\mathcal{C}} $ on $C _{p+q} $.
\end{proof}
Define $\mathcal{M} _{0} $ to be the set of machines whose input set is $\mathcal{I}= \mathcal{T}  \times \mathbb{N}$ and whose output set is $Strings $. That is $$\mathcal{M} _{0} := \{M \in \mathcal{M}| M: \mathcal{T} \times \mathbb{N}  \to Strings \}.
$$ 
We set $$\mathcal{T} _{0}:= \{T \in \mathcal{T}| fog (T) \in \mathcal{M} _{0} \},
$$ and we set $\mathcal{I} _{0} := \mathcal{T} _{0} \times \mathbb{N}  $.  % \begin{definition} \label{def:totallycomputed} %    We say that  $M \in \mathcal{M} _{0} $ is \textbf{\emph{computed}} by a $M' \in \mathcal{T} _{0} $ if $D_0 $ is Turing computed by $D'_0 $ for $D_0, D'_0  $ the components of $M$ respectively $M'$ as above. Meaning that $$    M (T) = pr _{0} \circ D_0 (T)$$ and 
% $$M' (T) = pr _{0} \circ D'_0 (T).
% $$ 
% % We suppose that $S' _{1,D} $ is fixed once and for all elements of $\mathcal{T} _{0} $ since it computes a fixed elementary function, while the component machines $D'_0, R' $ may depend on $M'$. 
% %    if there are 
% % \begin{equation} \label{eq:A}
% %    M (\Sigma)=  S   _{1,D}  (R(S    _{0,D} (\Sigma), \Sigma), \Sigma),
% % \end{equation}
% %
% %
% %    \eqref{eq:A} is satisfied for every  $\Sigma \in \mathcal{T} _{st} $, and that  $W$ strongly computes the ``waiting operation'' of $S$ on $C _{1} $, as in the proof of Lemma \ref{lemma:computeWait}. 
%    % And consequently if $\mathcal{C}=C _{s} $ then $R _{\mathcal{C}} $ is strongly computed by $R' _{s} $ on $C _{s+1} $.
%    % And suppose further that $S  _{i,D}$ are strongly computed on $C _{1} $ by $S' _{i,D} $.   Then we say that the physical $S$ is \textbf{\emph{totally computable relative to $\mathcal{A}$}}.
% \end{definition}
Given $M \in \mathcal{M} _{0} $ and $M' \in \mathcal{T} _{0} $ let $\Theta _{M,M'} $ be the statement:
\begin{equation}
\begin{split} \label{eq:assertion1}
   &  \text {$M$ is computed by $M'$}.
   % \\ % &  \text{furthermore } S _{i,D}  \text{ are strongly computed }  \text{ on } C _{1}, 
   % \\
\end{split}   
 \end{equation}
% where $C _{1} $ is a specified digital computer.
% And additionally satisfying that:
% \begin{equation} \label{eq:permissible1}
% \forall (B,m)  \in \mathcal{I} \quad M ^{Strings}  (B,m) \in S _{M ^{\mathcal{T} _{\mathbb{Z}} } (B,m) },
% \end{equation}
% for $M ^{Strings}$, $M ^{\mathcal{T} _{\mathbb{Z}} } $ the $Strings$ and $\mathcal{T} ^{\mathbb{Z}}    $ components of $M$.
% To write this another way, this also means that:
% \begin{equation} \label{eq:permissible}
%    \forall (B,m) \in \mathcal{I} \quad \{M (B,m)\} \times \mathbb{N} \subset I' _{0} \times \mathbb{N} \subset (\mathcal{T} _{\mathbb{Z}} \times  Strings) \times \mathbb{N},
% \end{equation}
For each $M \in \mathcal{M} _{0}$, we define a machine: 
$$\widetilde{M}: \mathcal{I} \to Strings \times \mathbb{N}  $$ 
\begin{equation} \label{eq:S0D1}
\widetilde{M}   (B,m) = (M (B,m),m),
\end{equation}
which is naturally a Turing machine when $M$ is a Turing machine.

In what follows, when we write $M' (M', m)$, we mean $M' (\Sigma _{M'},m )$ for $\Sigma _{M'} $ the string encoding of the specification of the Turing machine $M'$. So we conflate the notation for the Turing machine and its string specification, i.e. program.
\begin{definition} \label{def:propertyO} For $M \in \mathcal{M} _{0} $, $M' \in \mathcal{T} _{0} $,  an abstract string $O \in Strings$  is said to have \textbf{\emph{property $C=C (M,M')$}} if: \begin{align*} & \Theta _{M,M'} \implies \forall m: (*M'(M',m) \text{ does not halt} )  \lor (M' (M',m) \notin \mathcal{O}) \\  & \lor ( M' (M',m) \in \mathcal{O},O \in \mathcal{O} \text{ and } X(\Sigma,m) = D_1 \circ R \circ  \widetilde{M}' (M', m)),
\end{align*}
where $(X, \Sigma)=O$
and where $\widetilde{M}'  $ is determined by $M'$ as in \eqref{eq:S0D1}. 
\end {definition} 

   At a glance, this is a somewhat complicated property,  but essentially it just says that if $\Theta _{M,M'} $ then for all $m$  ``$O \neq {M}' (M', m)$'' unless either $*  {M}' (M', m)$ does not halt, or the output does not have the right (data) type, or $R (O,m) = \infty$.  Thus the string $O$ with property $C (M,M')$ is ``diagonal'' in a certain sense, where  by ``diagonal'' we mean that something analogous to Cantor's diagonalization is happening, but we will not elaborate. 
   \begin{remark}
   The fact that data types get intricated is perhaps not surprising. On one hand there is a well known correspondence, the Curry-Howard correspondence \cite{citeCurry}, between proof theory in logic and type theory in computer science, and on the other hand we are doing something at least loosely related to G\"odel incompleteness, but in the language of Turing machines.
\end{remark}
\begin{definition} \label{def:Psound}
   We say that $M \in \mathcal{M} _{0} $ is \textbf{\emph{$C$-sound}}, or 
is a \textbf{\emph{diagonalization machine}}, if for each $(M',m) \in \mathcal{I} _{0} $, with $M (M',m) = O$  defined,  $O$ has property $C (M,M')$.  We say that $M$ is $C$-sound on $M'$ if the list $\{M (M',m)\} _{m} $ has only elements with property $C (M,M')$. 
% A string $$(X, \Sigma _{1}, n) \in \mathcal{T} _{1} \times Strings \times \mathbb{Z} $$ is defined to have property $O (M,M')$, if $ (X, \Sigma _{1})$ has property $O (M,M')$ and $n= D_1 \circ R(X, \Sigma _{1}) $.
 % In this case we also say that $M (T)$ has property $O$.  %          We also say in this case that $D_0 (T) $ has property $O$, so that $M (T)$ has property $O$ iff $pr _{1} (M (T)) $ has property $O$ for 
%         $pr _{1}:  \mathcal{T} \times Strings \times \mathbb{Z} \to \mathcal{T} \times Strings$ the projection map.
 \end{definition}



Define a $C$-sound $M' \in \mathcal{T} _{0} $ analogously. 
\begin{definition}
 If $M,M'$ as above are $C$-sound we will say that $sound (M)$, $sound (M')$ hold. If $M$ is $C$-sound on $M'$ we say that $sound (M,M')$ holds.
\end{definition}
 \begin{example} \label{example:trivial}
A trivially $C$-sound machine $M$ is one for which $$M (M',m) =  (D_1 \circ R \circ  \widetilde{M}', M') $$ for every $(M',m) \in \mathcal{I} $. 
As $(D_1 \circ R \circ  \widetilde{M}', M') $ automatically has property $C (M,M')$ 
% \begin{equation*}
% \forall m:  \left((X(\Sigma,m) = D_1 \circ R \circ  \widetilde{M}' (M', m))   \lor ( *M'(M',m) \text{ does not halt} ) \lor (M' (M',m) \notin \mathcal{O}) \right),
% \end{equation*}
for each $M' \in \mathcal{T}_{0} $.
In general, for any $M \in \mathcal{M} _{0} $, $M' \in \mathcal{T} _{0} $ the list of all strings $O$ with property $C (M,M')$ is always infinite, as by this example there is at least one such string $(D_1 \circ R \circ  \widetilde{M}', M')$, which can then be modified to produce infinitely many such strings. 
 \end{example}      
 % \begin{lemma} If $M$ $C$-sound then it has property $P$ for some $M' \in \mathcal{I} _{0} $ only if it is not totally computable.
% \end{lemma}
% \begin{proof} Suppose otherwise that $M$ has property $P$ for some $M'$, then $R' (D'_0, M') = x \in \mathbb{Z}$ for $D'_0 $ the component machine.
% So we get:
% $$x = M' ^{\mathbb{Z}} (M') = (S' _{1,D}) ^{\mathbb{Z}} (x) = x+1 $$ with first equality $M$ by being $C$-sound and second by \eqref{eq:decision}, so we would get a contradiction.
%    
% \end{proof}
    \begin{theorem} \label{thm:diagonalization} Given any $M \in \mathcal{M} _{0} $, if  $sound (M,M') \land \Theta _{M,M'} $ for some $M' \in \mathcal{T} _{0} $ then 
   $$\forall m:  M (M',m) \neq \mathcal{G}, $$   
where $\mathcal{G}:= (D_1,\infty).$
   On the other hand, for any $M \in \mathcal{M} _{0} $:
\begin{equation*}
\forall M' \in \mathcal{T} _{0}: sound (M,M') \implies \text{$\mathcal{G}$ has property $C (M,M')$}.
\end{equation*}
In particular if $sound (M)$ then $\mathcal{G}$ has property $C (M,M')$ for all $M'$.
% So that $$\mathcal{G} (M')=(S' _{1,D}, \infty, D_1 \circ R'(D'_0(M')))$$ has property $O$.
\end{theorem}
So given any $C$-sound $M \in \mathcal{M} _{0} $ there is a certain string $\mathcal{G}$ with property $C (M,M')$ for all $M'$, such that for each $M'$ if $\Theta _{M,M'} $ then $$\mathcal{G}  \neq M (M',m),$$ for all $m$.  This ``G\"odel string'' $\mathcal{G} $  is what we are going to use further on. What makes $\mathcal{G}$ particularly suitable for our application is that it is independent of the particulars of $M$, all that is needed is $\mathcal{M} \in \mathcal{M} _{0} $ and is $C$-sound. So $\mathcal{G}$ is in a sense universal. 
% \begin{question}
%    It would be interesting to understand what is the analogue of such universal G\"odel strings for formal systems in logic. In other words is there a notion of universal G\"odel statements? This would have to do with certain collections of formal systems with a certain property, (perhaps generalizing our $C$-sound property).
% \end{question}
   
\begin{proof} Suppose not and let $M' _{0} $ be such that
$\Theta _{M,M' _{0} } \land sound (M,M' _{0} )$ and such that
\begin{equation*} 
M (M' _{0},m _{0} ) = \mathcal{G}  \text{ for some $m _{0}$},
\end{equation*}
so that $\mathcal{G}$ has property $C (M,M' _{0})$.
Set $I _{0}:= (M' _{0} ,m _{0} )$ then we have that:
   % . Since $sound (M,M' _{0} )$, since $\Theta _{M,M' _{0} } $, and since $*M' _{0} (T) \to \mathcal{G} \in \mathcal{O} $ since $M (T) = \mathcal{G} $ is defined, 
\begin{align*} \label{eq:MS}
      & 1= D_1 (\infty, m _{0} ), \\
      &  D_1 (\infty, m _{0}) = D_1 \circ R \circ  \widetilde{M}'(I _{0} ),  \text{ by $\mathcal{G}$ having property $C (M,M')$} , \text{ and by } *M'  (I _{0} ) \to \mathcal{G} \in \mathcal{O} \text{ since $\Theta _{M,M'} $},  \\
 &  D_1 \circ R \circ  \widetilde{M}'  (I _{0}) = D_1 \circ R (D_1, \infty, m _{0} )   \quad \text{ by $M' (I _{0} ) = \mathcal{G}$}, \\
 &  D_1 \circ R (D_1, \infty, m _{0} )=2 \quad \text{ by property $G$ of $R$ and by \eqref{eq:decision}}, \\
& 1=2.
\end{align*}
So we obtain a contradiction.
%
%
% Then after denoting by $M ^{\mathbb{Z}}, (M') ^{\mathbb{Z}}   $ the $\mathbb{Z}$ components we have:  
%    \begin{equation}
% \begin{split}
%    S' _{1,D} (\infty) = & 1= (M' _{0}) ^{\mathbb{Z}}     (T) \text{ since $\Theta _{M,M'}$ }   \\
%    &  = S' _{1,D}(R' (S' _{1,D}, \infty))  \text{ by \eqref{eq:Amachine}  and \eqref{eq:GS}} \\
%    &  = S' _{1,D}(S' _{1,D} (\infty)) \quad  \text{ by property $G$}\\
%    &  = 1+1 \quad \text{ by \eqref{eq:decision}}. \\
% \end{split}
% \end{equation}
% So we obtain a contradiction.
%

We now verify the second part of the theorem. 
We show that: 
   \begin{equation} \label{eq:SecondPart2}
      \forall m, \forall M' \in \mathcal{T} _{0}:    \left(sound (M,M') \land (M'(M',m) \in \mathcal{O}) \land \Theta _{M,M' }    \implies R (\widetilde{M}'(M',m)) = \infty \right).
\end{equation}
Suppose otherwise that for some $m _{0},M' _{0}  $ and $I _{0}:= (M' _{0} , m _{0}) $ we have: 
   \begin{equation*}    sound (M,M' _{0} ) \land (* M' _{0} (I _{0}) \text{ halts}) \land (M' _{0} (I _{0} ) \in \mathcal{O}) \land \Theta _{M,M' _{0}  } \land (R (\widetilde{M}' _{0}   (I _{0} )) \neq \infty).
   \end{equation*}
So we have:
\begin{equation} \label{eq:datatype1}
   *M'_{0} (I _{0} ) \to (X, \Sigma ) \in \mathcal{O},
\end{equation}
   for some $(X, \Sigma )$ having property $C (M,M' _{0} )$.
And so, since $R$ is defined on all of $\mathcal{O}'$: $$R (\widetilde{M}' _{0}  (I _{0} )) = R (X, \Sigma, m _{0}) =  X (\Sigma,m _{0}  ) =x \in \mathbb{Z}, \text{ for some $x$}, 
$$ 
   by Property $G$ of $R$ and by $R (\widetilde{M}' _{0}  (I _{0} )) \neq \infty$.

   Then we get: $$x = X (\Sigma,m _{0}) =  D_1 \circ R \circ \widetilde{M} ' _{0}  (I _{0} ) = D _{1} (x) =  x+1 $$  by $(X, \Sigma)$ having property $C (M,M' _{0} )$, and by \eqref{eq:datatype1}. So we get a contradiction and \eqref{eq:SecondPart2} follows.
Our conclusion readily follows.
\end{proof}

% Formally $*$ is characterized by a pair of a Turing machine  and input  to this Turing machine.   This is again a string which we denote by  $D_0 (\Sigma) $, as it functionally depends on $\Sigma$.
% \item The if $D'_0  $ denotes 
%           the component of $A' $ which computes the operator $D_0 $, and you can show that the statement: \begin{equation*}
%       *D'_0 (\Sigma) \text{ is equivalent to } *A' (\Sigma)
%       \end{equation*} 
%       does not hold conditionally on $\Theta _{\Sigma} $, you will also be freed. We will explain $D_0,  D'_0  $ in more detail further on. At the moment this last condition will not play a role.
\subsection{A system with a human subject $S$ as a machine in $\mathcal{M} _{0}$}
\label{section:AsystemWithS}
Let $S$ be a human subject, in a controlled environment, in communication with an experimenter/operator $E$ that as input passes to $S$ elements of $\mathcal{I} = \mathcal{T} \times \mathbb{N}$. Here \textbf{\emph{controlled environment}} means primarily that no information i.e. stimulus,
% =======
%       does not hold conditionally on $\Theta _{\Sigma} $, you will also be freed. We will explain $S _{0,D},  S' _{0,D}  $ in more detail further on. At the moment this last condition will not play a role.
that is not explicitly controlled by $E$ and that is usable by $S$, passes to $S$ while he is in this environment. This condition is only for simplicity, 
so long as we know in principle, or can compute in principle, what ``input'' our $S$ receives, it doesn't matter what kind of environment he is in.
For practical purposes $S$ has in his environment a general purpose digital computer with arbitrarily, as necessary, expendable memory, (in other words a universal Turing machine). 

We suppose that upon receiving any ${I} \in \mathcal{I} $, as a string in his computer, after possibly using his computer in some way,  $S$ instructs his computer to print after some indeterminate time a string $S (I)$.
We are not actually assuming that $S (I)$ is defined on every $I$. So $S$ in our language also denotes a machine: 
\begin{equation*}
   S: \mathcal{I} \to Strings,
\end{equation*} 
which we suppose satisfies the condition that for any fixed $T \in \mathcal{T} _{0}   $ $$\{S  (T,m)\} _{m} $$ is the complete list of strings that $S$ asserts to have property $C (S, T)$. (While being a part of the system above.) 
\begin{remark} \label{remark:simplification} The above is partially a simplification, because for a real world $S$ it may be that each $S (T,m)$ must be understood as a probability distribution on $Strings$. In other words the value $S (T,m)$ is only determined up to some dice roll, which we may expect if quantum mechanics plays a significant role. This extra complexity will be ignored,  as it does not meaningfully change any of our arguments, since dice rolls can be simulated completely with Turing machines.
\end{remark}

% , we only need that $S $ can list as many strings as we like, and that given any particular $T$, eventually any particular string that $S _{0} $ asserts to have property $C (S _{0}, T )$ will appear.  
%    \item $S$ then waits for a fixed time $$t ^{W} >0 $$ for $*$ to halt.
% \item $S$ receives the output of $*$, or he does not if the halt time of $*$ is more then $t ^{W} $.
% \item Based on what he has obtained $S$ then decides on his printed answer to $E$, which is unambiguously interpreted as an element of $\mathcal{T} _{1}  \times Strings \times \mathbb{Z}$.
% \end{itemize}
%  , and then, whether $*$ halts or not, All of these operations: ``waiting'', ``deciding'' are to be strongly computable if $S$ is totally computable in the informal sense discussed. 
% We now further formalize this.   
% Define $\mathcal{T}$ to be the set of Turing machines with permissible input some subset of $Strings$ and output in $\mathbb{Z}$. 
% We likewise understand $\mathcal{T}$ as a subset of ${Strings}  $ with respect to a particular chosen encoding, but then forget this.  
% <<<<<<< HEAD
% We further ask that the initial ``decision map'' of $S$ determines a machine:
%   $$D_0: \mathcal{I}  \to  {\mathcal{T}} _{1}  \times {Strings} _{0}, $$ 
% satisfying \eqref{eq:}.
% % The output $S   _{0,D} (T)$ is a tuple $(X, \Sigma ^{1},m  )$ of a Turing machine $X $ and input $(\Sigma ^{1},m) $ to this Turing machine. 
% If $D_0 (B,m) = (X, \Sigma ^{1},m ) $ then the computation $*X  (\Sigma ^{1},m) $ is what $S$ decides to run on $\mathcal{C}$ given $(B,m)$.
% In a more basic language,  we may say that $S   _{0,D} (B,m)$ is a pair of a computer program and input for this program that $S$ will run on $\mathcal{C} $.  
% Of course $D_1, R _{\mathcal{C}}  $ are Turing computable.
\begin{definition} We say that $S$ the human subject  is \textbf{\emph{computable}} if the corresponding machine $S$ above is computable.
\end{definition}
\subsubsection*{Additional condition for $S$}
Let $S $ be a subject as above, which additionally satisfies what we call the \emph{Penrose property}.
% In this case given any input $T = (B,m)$, given the chosen computation $D_0 (T) = (X, \Sigma _{1} ) $ and given the wait time $t ^{W} >0 $,  if the computation $* X (\Sigma _{1} )$ does not halt in time $t ^W $ he prints $(X, \Sigma _{1}, 1)$ in any time less then $t ^{W}  $. More specifically,
% the time to answer of $D_1 (\infty) $ is less than $t ^{W} $.  
We ask that the physical $S$ asserts that they are sound, which entails in this case that they assert $sound (S)$ for $S$ the above machine. And we ask that $S$ is aware of Theorem \ref{thm:diagonalization}, so that as a consequence $S$ asserts that $\mathcal{G}$ has property $C (S,T)$, for all $T \in \mathcal{T} _{0} $. Or still more concretely: for all $T$, $\mathcal{G}= S (T,m)$ for some $m$. This condition is preliminary, since asserting soundness is at least on the surface irrational, and we formally treat fundamental soundness only in the next section.  
% \begin{remark}  Although $S$ is not given a definition, it can be in principle defined in set theory once one knows everything there is to know about the physics and biology underlying the physical $S$. (And assuming set theory is enough to formalize everything.) In other words assuming the universe is deterministic, $S$ is determined by some rule, which we assume can be formalized in set theory.  
% \end{remark}
\begin{theorem} 
%  Let ${S} _{0} $ be the machine described above,  then 
\begin{equation*}
S  \text{ is computable } \implies \neg sound (S  ). 
\end{equation*}
In fact we prove more, for any $S' \in \mathcal{T} _{0} $:
\begin{equation*}
   \Theta _{S, S'} \implies   \neg sound (S ,S' ) .
\end{equation*}
\end{theorem} 
 This partly formalizes Theorem \ref{thm:1}, to completely formalize it we must wait till the following sections.
\begin{proof}
Suppose $\Theta _{S, S'}$ for some $S' \in \mathcal{T} _{0} $.
Suppose in addition $sound (S,S' )$.  Then  by Theorem \ref{thm:diagonalization} $$S   (S',m) \neq \mathcal{G} $$ for any $m$, which contradicts the Penrose property above.
%
% On the other hand $S  $ asserts  $sound (S  )$ and hence must assert that  $\mathcal{G}$ has property $C (S, S' )$, 
% by the second half of Theorem \ref{thm:diagonalization}.
% In particular $\mathcal{G}$ must be in the list $\{S  ({S'},m) \} _{m} $, since this list is assumed to be complete. So we have reached a contradiction.
\end {proof}

\section {Fundamental soundness as stable soundness} \label{section:fundamentalSoundness}
Imagine a machine $P$ which sequentially prints statements of arithmetic, which it asserts are true, but so that $P$ can also delete a printed statement, if $P$ decided the statement to be untrue. We say that $P$ is stably sound if any printed statement by $P$ that survives to infinity is in fact true.  More formally, for each $n \in \mathbb{N}$, $P (n)$ will correspond to an operation denoted by the string $(\Sigma,+)$ or $(\Sigma,-)$ meaning add $\Sigma$ to the list or remove $\Sigma$ from list, respectively, where $\Sigma$ is a statement of arithmetic. 
If there is an $n  _{0} $  with $P (n _{0} ) = (\Sigma  ,+ )$, s.t. there is no $m>n _{0} $ with $P (m) = (\Sigma, -)$, then $\Sigma $ is called \textbf{\emph{$P$-stable}}  and we say that $P$ \textbf{\emph{prints $\Sigma$ stably}}. 
\begin{definition}
 We say that $P$ is \textbf{\emph{stably sound}}  if every  $P$-stable $\Sigma$ is true.
  \end{definition}
\begin{remark} \label{remark:stable} Given a stably sound $P$, we may construct from it a sound machine $P ^{s} $ simply by enumerating, in order, all the $P$-stable $\Sigma$. However this is of no usefulness in our context, as in general $P ^{s} $ may not be computable even if $P$ is computable.  Explicit examples of this sort can be constructed by hand. We can in fact construct a Turing machine $A$, whose stabilization $A ^{s} $ enumerates every Diophantine equation with no integer solution, and this set is well known to be not computably enumerable, \cite{TuringComputableNumbers}.
\end{remark}

 We now translate this to our setting. The crucial point of our G\"odel string is that it will still function in this stable soundness context.
Let $\mathcal{M} ^{\pm}  $ denote the set of machines
\begin{align*}
{M}: \mathcal{I} = \mathcal{T} \times \mathbb{N} \to Strings \times \{\pm\},
% \\ & \textbf{M} (T, k) = M _{k} (T), \text{for all $k \in \mathbb{N}$, and $T \in \mathcal{I}$}.
\end{align*}
where $\{\pm\}$ is the set containing two symbols $+,-$, likewise implicitly encoded as a subset of $Strings$.
We set $$\mathcal{T}  ^{\pm} := \{T \in \mathcal{T}| fog (T) \in \mathcal{M} ^{\pm} \}.
$$  
% Note that we are again implicitly encoding $Strings \times \{\pm\}$ as a subset of $Strings$.
\begin{definition} 
   For ${M} \in \mathcal{M} ^{\pm}  $, and for $ (T,m) \in \mathcal{I} $, we say that an abstract $O \in Strings$ is $(M,T)$-\textbf{\emph{stable}}, and that \textbf{\emph{$M$ prints $O$ $T$-stably}}  if there exists an $m \in \mathbb{N}$ s.t.  ${M} (T,m) = (O, +) $ and there is no $k>m$ s.t. $M (T,k) = (O,-)$.  When $T \in \mathcal{T} ^{\pm} $  and $fog (T)=M$, instead of writing $(M,T)$-stable we just write $T$-stable.
\end{definition}
% \begin{notation} In addition, we sometimes write $M$-stable instead $(M,B)$-stable. Since usually it is clear what $B$ is supposed to be. Likewise we may say that $M$ prints $O$ stably, instead of $B$-stably.
% \end{notation}
Let $$pr: Strings \times \{\pm\} \to  Strings,$$ be the natural projection.
For each $M \in \mathcal{M} ^{\pm} $, we define a machine: 
%
%
% $$\underline{M}: \mathcal{I} \to \mathcal{T} _{Z} \times Strings    $$ 
% $\underline {M} (B, m) \pr _{\mathcal{T} _{Z} \times Strings} \circ   $
$$\widetilde{M}: \mathcal{I} \to Strings \times \mathbb{N},    $$ 
\begin{equation} \label{eq:S0D}
   \widetilde{M}   (T,m) = (pr \circ M (T,m),m),
\end{equation}
which is naturally a Turing machine when $M$ is a Turing machine. 

In what follows $\mathcal{O} \subset \mathcal{T} _{\mathbb{Z}} \times Strings $ is as before.
\begin{definition} \label{def:SpropertyO} 
For ${M} \in \mathcal{M} ^{\pm} $, ${M}' \in \mathcal{T} ^{\pm}  $,  an abstract string $O \in Strings$  is said to have property \textbf{\emph{ $sC=sC ({M}, {M}')$}} if:
\begin{align*}
   & \Theta _{M,M'} \implies \forall m: (*M'(M',m) \text{ does not halt} )  \lor (pr \circ M' (M',m) \notin \mathcal{O}) \lor (pr \circ M' (M',m) \text{ is not $M'$-stable}) \\  & \lor (pr \circ M' (M',m) \in \mathcal{O}, O \in \mathcal{O} \text{ and } X(\Sigma,m) = D_1 \circ R \circ  \widetilde{M}' (M', m), \text{ where $(X, \Sigma)=O$})),
\end{align*}
for $\widetilde{M}'  $ determined by $M'$ as in \eqref{eq:S0D}. 
\end {definition}
\begin{definition} \label{def:SPsound}
   We say that ${M} \in \mathcal{M} ^{\pm}  $ is \textbf{\emph{stably $C$-sound}} on ${M}'$, and we write that $s-sound ({M}, {M}')$ holds, if every  $(M,M')$-stable $O$ has property $sC ({M}, {M}')$. We say that ${M}$ is \textbf{\emph{stably $C$-sound}} if it is stably $C$-sound on all ${M}'$, and in this case we write that $s-sound ({M})$ holds.
% A string $$(X, \Sigma _{1}, n) \in \mathcal{T} _{1} \times Strings \times \mathbb{Z} $$ is defined to have property $O (M,M')$, if $ (X, \Sigma _{1})$ has property $O (M,M')$ and $n= D_1 \circ R(X, \Sigma _{1}) $.
 % In this case we also say that $M (T)$ has property $O$.  %          We also say in this case that $D_0 (T) $ has property $O$, so that $M (T)$ has property $O$ iff $pr _{1} (M (T)) $ has property $O$ for 
%         $pr _{1}:  \mathcal{T} \times Strings \times \mathbb{Z} \to \mathcal{T} \times Strings$ the projection map.
 \end{definition}
\begin{example} \label{example:strivial}
  As before an example of a trivially stably $C$-sound machine $M$ is one for which $$M (M',m) =  (D_1 \circ R \circ  \widetilde{M}', M',+) $$ for every $(M',m) \in \mathcal{I} $. 
\end {example}
\begin{theorem} \label{thm:stablediagonalization} For all $M \in \mathcal{M} ^{\pm} $:
\begin{equation*}
   (\exists M' \in \mathcal{T} ^{\pm}: s-sound ({M}, {M}')) \land \Theta _{{M}, {M}'} \implies ((\text{$O$ is $(M,M')$-stable}) \implies O \neq \mathcal{G})
\end{equation*}
where $$\mathcal{G}:=(D_1, \infty) \in \mathcal{O}.$$
On the other hand, 
\begin{equation} 
\forall M \in \mathcal{M} ^{\pm}, \forall M' \in \mathcal{T} ^{\pm}: s-sound ({M}, {M}')  \implies \text{$\mathcal{G}$ has property $sC ({M},{M}')$}.
\end{equation}
 In particular if $s-sound ({M})$ then $\mathcal{G}$ has property $sC ({M},{M}')$ for all $M'$.
% So that $$\mathcal{G} (M')=(S' _{1,D}, \infty, D_1 \circ R'(D'_0(M')))$$ has property $O$.
\end{theorem}
\begin{proof}  This is mostly analogous to the proof of Theorem \ref{thm:diagonalization}. Suppose not, let $M$ be fixed and let ${M}' _{0} $ be such that $s-sound ({M},{M}' _{0} ) \land \Theta _{{M}, {M}' _{0} }$ and such that for some $m _{0} $:
\begin{equation*} 
   M ({M}' _{0} ,m _{0} ) = (\mathcal{G}, +)  \text{ and $\mathcal{G}$ is $(M,M' _{0} )$-stable},
\end{equation*}
with $\mathcal{G}$ consequently having property $sC (M,M' _{0} )$, by $s-sound (M,M' _{0} )$.

If we set $I _{0}: = ({M}' _{0} , m _{0})$, then 
   by  $\mathcal{G}$ having property $sC (M,M' _{0} )$, by $*M' _{0}   (I _{0} ) \to (\mathcal{G},+)$, $\mathcal{G} \in \mathcal{O}$ since $\Theta _{M,M' _{0} } $ and by  $\mathcal{G}$ being $M' _{0} $-stable as $\mathcal{G}$ is $(M,M' _{0} )$-stable:
\begin {equation} \label{eq:basic}
   D_1 (\infty, m _{0}) = D_1 \circ R \circ  \widetilde{M}' _{0} (I _{0} ).
\end{equation}
On the other hand:
\begin{align} \label{eq:MS}
      &  D_1 \circ R \circ  \widetilde{M}' _{0}   (I _{0} ) = D_1 \circ R (D_1, \infty, m _{0} )   \quad \text{ by $M' _{0}  (I _{0} ) = (\mathcal{G},+)$}, \\
 &  D_1 \circ R (D_1, \infty, m _{0} )=2 \quad \text{ by property $G$ of $R$ and by \eqref{eq:decision}}, \label{eq:MS} \\
& D_1 (\infty, m _{0} ) =1, \\ 
& 1=2, \text{by \eqref{eq:basic} and by \eqref{eq:MS}.
   }
\end{align}
 So we obtain a contradiction.
%
%
% Then after denoting by $M ^{\mathbb{Z}}, (M') ^{\mathbb{Z}}   $ the $\mathbb{Z}$ components we have:  
%    \begin{equation}
% \begin{split}
%    S' _{1,D} (\infty) = & 1= (M' _{0}) ^{\mathbb{Z}}     (T) \text{ since $\Theta _{M,M'}$ }   \\
%    &  = S' _{1,D}(R' (S' _{1,D}, \infty))  \text{ by \eqref{eq:Amachine}  and \eqref{eq:GS}} \\
%    &  = S' _{1,D}(S' _{1,D} (\infty)) \quad  \text{ by property $G$}\\
%    &  = 1+1 \quad \text{ by \eqref{eq:decision}}. \\
% \end{split}
% \end{equation}
% So we obtain a contradiction.
%

We now verify the second part of the theorem. 
Given any ${M}' \in \mathcal{T} _{0} $, for any $m \in \mathbb{N}$, setting $I:= (M',m)$ we show that: 
   \begin{equation} \label{eq:SecondPart}
   s-sound ({M},{M}') \land (pr \circ      M' (I) \in \mathcal{O})  \land ( pr \circ \text{$M' (I)$ is $M'$-stable} ) \land \Theta _{{M}, {M}'}   \implies R (\widetilde{M}'(I)) = \infty.  \end{equation}
Suppose otherwise that for some $M' _{0}, m _{0} $ and $I _{0}:= ({M}' _{0}, m _{0}) $ 
   we have: 
    \begin{multline*}   s-sound ({M}, {M}' _{0} ) \land (* M' _{0}  (I _{0}) \text{ halts}) \land  (pr \circ M' _{0} (I _{0} ) \in \mathcal{O}) \land ( pr \circ \text{$M' _{0}  (I _{0} )$ is $M' _{0} $-stable} )  \\ \land \Theta _{{M}, {M}' _{0}  } \land (R (\widetilde{M}' _{0}   (I _{0} )) \neq \infty).
    \end{multline*}
  Then by the above condition we get: 
   \begin{equation} \label{eq:datatype}
  *M' _{0}  (I _{0} ) \to (O,+), \text{ or } *M' _{0}  (I _{0} ) \to (O,-),
\end{equation}
   for some  $O = (X,\Sigma) \in \mathcal{O}$, which is $(M,M' _{0} )$-stable, and with property $sC ({M}, {M}' _{0} )$. We can of course guarantee that there is some $m _{0}'$ with $M' (M' _{0} , m _{0}' ) = (O,+)$, but we arranged the details so that this is not necessary. 

   Since $R$ is defined on all of $\mathcal{O}'$ we get: $$R (\widetilde{M}' _{0}   (I _{0} )) = R (O, m _{0}) =  X   (\Sigma, m _{0}  ) =x \in \mathbb{Z}, \text{ for some $x$},  $$ 
   by Property $G$ of $R$ and by $R (\widetilde{M}' _{0}  (I _{0} )) \neq \infty$.
Then we have: $$
    x=X (\Sigma, m _{0}) =   D_1 \circ R \circ \widetilde{M}' _{0}   (I _{0} )= D _{1} (x)= x+1,
   $$  
by $(X, \Sigma)$ having property $sC (M,M' _{0} )$, and by \eqref{eq:datatype}.
% But then we get:
% $$
% x= X  (\Sigma _{1},m _{0} )  = D_1 \circ R \circ \widetilde{M}'    (T _{0} ) = D _{1} (x) =  x+1,
%    $$  
So we get a contradiction and \eqref{eq:SecondPart} follows.  Our conclusion readily follows.
% So
% \begin{equation} \label{eq:SecondPart2}
%    sound (M) \land  \Theta _{M,M' }    \implies M' (M') = S' _{1,D} (\infty,M'),
% \end {equation}
%   from which the conclusion follows.
% % Then since $\halt M (T _{0} )$, and since $M$ has property $P$, we have 
% %   \begin{equation*}
% %   \neg (sound (T _{0} ) \land \Theta _{M,T _{0} }).
% % \end{equation*} 
% % But $T _{0} $ computes $M$ which is $C$-sound so $sound (T _{0} )$, and hence $\neg \Theta _{M, T _{0} } $ a contradiction.
\end{proof}

\section{A system with a human subject $S$ as a machine in $\mathcal{M} ^{\pm}$} \label{section:systemMpm}
Let $S$ be a human subject in a controlled environment as before. For the moment $S$ is not in any way idealized. We may then suppose,  as in Section  \ref{section:AsystemWithS}, that $S$ determines an element of $ \mathcal{M} ^{\pm} $: 
\begin{equation} \label{eq:Smachine}
{S}: \mathcal{I} \to Strings \times \{\pm\}. 
\end{equation}
Once again $S$ is only a partial function.
% Where for each $(T,m) \in \mathcal{I}$, $S (T,m)$ is a string that $S$ asserts to have property $sC (S,T)$, at 
We suppose $S$ satisfies the condition that for any fixed ${T} \in \mathcal{T} ^{\pm} $  the list $\{S (T,m)\} _{m} $ is complete, in the sense that if the physical $S$, while part of the environment above, eventually stably asserts that some $O$ has property $sC (S,T)$ then $$  S ({T},m)=(O, +)  $$ for some $m$, and that moreover $O$ is $(S,T)$-stable. 
And conversely if $O$ is $(S,T)$-stable, then $S$ stably asserts that $O$ has property $sC (S,T)$. Here, ``stably asserts'', analogously to previous usage,  means that $S$ is never to change their mind on this. 

As $S$ now denotes two things: the human subject and the corresponding machine, we will say \textbf{\emph{physical $S$}} when we want to clarify that we are talking of the actual  human.
\begin{definition} As before, we say that the physical $S$  is \textbf{\emph{computable}} if the corresponding machine ${S}$ above is computable.
\end{definition}
\begin{definition} We say that $M \in \mathcal{M} ^{\pm} $ has \textbf{\emph{the stable Penrose property}} if $\mathcal{G}$ is $(M,T)$-stable for every $T \in \mathcal{T} ^{\pm} $.
In particular if the physical $S $ stably asserts $s-sound ({S})$ and is aware of the second half of Theorem \ref{thm:stablediagonalization} then the associated  $S \in \mathcal{M} ^{\pm} $ has the stable Penrose property, by the condition above.
\end{definition} 
We suppose from now on that $S$ has the stable Penrose property.
% In this case given any input $T = (B,m)$, given the chosen computation $D_0 (T) = (X, \Sigma _{1} ) $ and given the wait time $t ^{W} >0 $,  if the computation $* X (\Sigma _{1} )$ does not halt in time $t ^W $ he prints $(X, \Sigma _{1}, 1)$ in any time less then $t ^{W}  $. More specifically,
% the time to answer of $D_1 (\infty) $ is less than $t ^{W} $.  
% \begin{remark}
% Technically, for our results, we don't need the list $\{S (T,m)\} _{n} $ to be complete in the sense above. We only need that this list contains a particular string. 
%    \end{remark} 
  % Conversely if $S (T,m) = (O, +)$ for some $m$ then at some point the physical $S$ asserts that $O$ has property $sC (S,T)$. Similarly,
% if the physical $S$, after at some point asserting that $O$ has property $sC (S,T)$, later asserts that it does not, then  $$  S ({T},m)=(O, -)  $$ for some $m>k$, where  Conversely if $S (T,m) = (O, -)$ for some $m$ then at some point the physical $S$ asserts that $O$ does not have property $sC (S,T)$.
We further justify this property below.
The following theorem is an immediate consequence of Theorem \ref{thm:stablediagonalization}. 
% That said our idealization is very tame, for if $S$ is computable then for our purpose we may ``replace him'' by a physical computer $IS$. This $IS$ could then be understood as the idealized $S$, at least pretending that computers do not deteriorate. Then applying the theorem to $IS$, we get that $IS$ is not stably sound, since it is of course computable. 

\begin{theorem} \label{thm:2} Let $M \in \mathcal{M} ^{\pm} $ have the stable Penrose property then 
\begin{equation*}
M \text{ is computable } \implies \neg s-sound ({M}). 
\end{equation*}
In fact, for any $ {M'} \in \mathcal{T} ^{\pm} $:
\begin{equation*}
   \Theta _{ {M}, {M'}} \implies   \neg s-sound ( {M}, {M'} ).
\end{equation*}
In particular if our physical $S$ is computable, they cannot be fundamentally sound,  specifically meaning stably sound.
\end{theorem} 
% If we define a \emph{human} as a subject whose associated partial function $S$ has the stable Penrose property then this formalizes Theorem \ref{thm:1}. \footnote {This very limited definition is of course only for the purposes of our theorem. 
% } 
\subsection {Justifying the stable Penrose property} \label{section:justify}
It remains to explain however how the stable Penrose property is justified. The interpretation of this for a given $S$ is that such a human is simply asserting that the list of certain mathematical statements, that they assert to be true, converges in the exact sense above to a list of things which are actually true.  For example I assert in absolute faith $L$: $5$ is an odd number. This statement $L$ is likely stably on my list, unless I would have lost my sanity and hence would no longer be me. On the other hand, the statement $0=1$ should not be stably on my list. 

% A non idealized $S$ can have the stable Penrose property, and rationally so, if they were extremely conservative. As an extreme example let us say they assert only $L$ and $\mathcal{G}$ and then retire.
% Note that it can be rational for a non-idealized $S$ to assert their soundness, provided they stopped making statements before loin particular to have the stable Penrose property, if they are very conservative. For example let's say $S$ asserts only $L$.

To make further sense of this, we could idealize our $S$ so that their brain is not subject to deterioration, and so that $S$ aware of this. But then we have to understand the implications of our theorem for idealized $S$, for non-idealized $S$. In principle this shouldn't be a problem, since we can imagine a process of idealization that does not magically introduce non-computability in the limit, where the was none before.  But this discussion is outside our scope.

% \begin{remark}
% We only need to effectively idealize, this can mean for example that we can guarantee that all $(S,T)$-stable $O$, with generation number $m < N$, (the smallest $m$ so that $O = pr \circ S (T,m)$  have property $sC$.
% We can then construct an effective version of our theory so that our argument can be adapted to apply to such a partial idealization, but this is outside our scope.  
% \end{remark}
Or we may say more concretely that the idealized human is represented by ``the evolving scientific community'' $H$, as we have already mentioned in the introduction. The fact that it is ``evolving'' because its members change (death/birth) presents no problems. If each individual human is Turing computable, then so is this $H$ itself understood as machine: 
\begin{equation*}
{H}: \mathcal{I} \to Strings \times \{\pm\},
\end{equation*}
where the output $H (I)$ is determined by, for example, majority consensus.

It is important to note that each $H (T,m)$ does \emph{not} need to be printed in absolute faith,  since we allow latter corrections.
On the other hand, $H$ believes and must believe if science is to exist that scientific or at least mathematical progress converges on truth. 
So it is natural to postulate that $H$ makes a preliminary assertion $s-sound (H)$, and so $$\forall T, \exists m _{T} : H (T,m _{T} ) = (\mathcal{G},+).
$$ Moreover, 
$$\exists m > m _{T}: H (T,m ) = (\mathcal{G},-),$$
only if $H$ discovers \footnote {Discovering your own unsoundness is possibly paradoxical, but such issues do not concern us here.} at a later time that $\neg s-sound (H)$. So if this does not happen $\mathcal{G}$ will be $(H,T)$-stable for all $T$. In other words we postulate that $H$ has the stable Penrose property.  % \footnote {$H$ knowing that $H$ is unsound is indeed very paradoxical. Concretely, for us, this just means $H$ removes $\mathcal{G}$ from its list.}   
Then we may apply Theorem \ref{thm:2} above to this $H$, which then formalizes Theorem \ref{thm:1}.  
\begin{proof} [Proof of Theorem \ref{thm:2}] Suppose $\Theta _{ {M}, {M'}}$ for some $ {M}' \in \mathcal{T} ^{\pm}  $.
   Suppose in addition $s-sound ({M}, {M'})$.  Then  by Theorem \ref{thm:stablediagonalization} for all $m$ s.t. $pr \circ M ({M}',m)$ is $(M,M')$-stable: $$M ( {M}',m) \neq \mathcal{G},
   $$ but this contradicts the stable Penrose property.
\end{proof}
% Observe also that by the discussion above if $H$
% \begin{remark} We had mentioned that $\mathcal{G}$ should be $(H,T)$-stable 
%   unless at some point $H$ discovers that it is unsound. This is indeed as paradoxical as it sounds. For if $H$ ``knows'' that it is unsound, it presumably knows specifically in what way it is unsound, and understand how to fix this issue, so that it is not actually unsound. Unless, $H$ 
% \end{remark}
\subsection{The unreasonable complexity of a computable $S$} Let us now not assume any idealizations of $S$. We want to give the reader some intuition into behavior of the function $S$, which will also give 
intuition for the theorem above, beyond the formal consequence. 

Let $T \in \mathcal{T} ^{\pm} $ be given to the physical $S$. Suppose that  $S$ is able to determine $T (T,n _{0} )$ for some $n _{0} $, before printing any of his strings. For example $S$ may do this by brute force, using his computer to do the calculation $*T (T,n _{0} )$. Recall from Section \ref{section:AsystemWithS} that $S$ refers to the entire controlled environment of $S$, containing his computer. $T$ computes $S$ if it computes the answers of this system. So there is nothing wrong with $S$ using his computer in this way. Or $S$ may deduce $T (T,n _{0} )$ by some mathematical argument.

In this case, $S (T,n)$ for all $n$ can have absolutely arbitrary values so long as $S (T,n _{0} ) \neq T (T,n _{0} )$, since then automatically $\neg \Theta _{S,T} $, and so any string has property $sC (S,T)$! In other words if the physical $S$ is able to a priori determine some value $T (T, n _{0} )$, then $S$ immediately disproves $\Theta _{S,T} $, and so can print anything he wants for the values $S (T,n)$. By ``a priori'' we mean more specifically that the physical $S$ has determined $T (T, n _{0})$ before $S (T, n _{0} )$ is printed. 
% (After $S (T, n _{0} )$ is already printed, if $T$ computes $S$ then the computation $*T (T, n _{0} )$ must halt, and the value $T (T, n _{0} )$ can be empirically found by $S$.) 

So if $S$ is computable then any $T$ computing $S$ must be so complex that the physical $S$ cannot a priori determine any of $T$'s values!
Indeed, even without Theorem \ref{thm:2} this seems unlikely. 
The same would apply to an idealized $S$ but becomes more extreme, since $S$ is no longer time constrained.
\section {Formal system interpretation} \label{section:formalsystem}
Let us fix our interpretation of an idealized human as $H$ from before, postulated to have the stable Penrose property. As before, we will say physical $H$ when we want to emphasize that we are talking of the physical thing representing the partial function $H$. Theorem \ref{thm:2}, allows us to conclude that if $H$ is computable then $H$ not stably sound. The one string $\mathcal{G}$ that $H$ is guaranteed to stably print, which expresses unsoundness of $H$, while elementary is slightly esoteric. Can we see more clearly that $H$ is unsound? Yes, but we need stronger assumptions, and some language of formal systems. This section can be safely omitted as it is only of secondary interest.

For simplicity we will base everything of standard set theory $\mathcal{ST}$ (Zermelo-Fraenkel axioms). Turing machines, and arithmetic are assumed to be naturally formalized in $\mathcal{ST}$. 
In what follows, for a statement $L$, $\mathcal{F} \vdash L$ means that $L$ is provable in the formal system $\mathcal{F}$.

Let $\mathcal{A}$ denote the set of sentences of arithmetic, as formalized by $\mathcal{ST}$. Let
\begin{equation*} P: \mathbb{N} \to  \mathcal{A} \times \{+, -\},
\end{equation*}
be a machine associated to scientific community $H$, analogously to the previous discussion, and as in the preamble to Section \ref{section:fundamentalSoundness}.
\begin{definition}
  We will say that the physical $H $ \textbf{\emph{is captured by a formal system}} $\mathcal{F}  \supset \mathcal{ST}$ if the following are satisfied:
\begin{enumerate}
\item  For any $T \in \mathcal{T} ^{\pm} $:
\begin{equation*}
   (O \text{ is $(H,T)$-stable}) \iff \mathcal{F} \vdash (O \text{ has property } sC (H,T)).
\end{equation*}
% The right hand side only makes sense after the partial function $S$ has been  given a set theoretic, or $\mathcal{F}$ theoretic construction. So existence of such a construction is part of the hypothesis. But we do not ask that this construction is known to the physical $S$.
\item  
\begin{equation*}
   (A \in \mathcal{A} \text{ is $P$-stable}) \iff \mathcal{F} \vdash A.
\end{equation*}
\end{enumerate}
\end{definition}
We will suppose from now on that the physical $H$ accepts $\mathcal{ST}$  as sound, meaning more specifically that $H$ stably asserts its theorems as true, where the meaning of this is as in previous sense. 
In this case a formal system $\mathcal{F}$ in the language of set theory, that captures $H$, always exists. We may simply define $\mathcal{F} (H)$ capturing $H$, by adding to $\mathcal{ST}$ as axioms the $P$-stable statements, and adding as an axiom, for each $O$ $(H,T)$-stable, the statement:
\begin{equation*}
\text{$O$ has property $sC (H,T)$.}
\end{equation*}
 The resulting formal system $\mathcal{F} (H)$ is in fact minimal, in the sense that any other $\mathcal{F}$ which captures $H$ contains $\mathcal{F} (H)$.
\footnote {$\mathcal{F} (H)$ may not however be effectively axiomatized, cf.
 Remark \ref{remark:stable}, but this is not relevant to our present discussion.} 
Let $Con (H)$ denote the statement:
\begin{equation*}
   \exists \mathcal{F}: (\mathcal{F} \supset \mathcal{ST} \text{ s.t. $\mathcal{F}$ captures $H$}) \land  (\text {$\mathcal{F}$ is consistent}).
\end{equation*}
This is of course equivalent to the condition that $\mathcal{F} (H)$ is consistent by the above discussion.
% We suppose that $\mathcal{F} (S)$ contains standard set theory, enough so that Turing machines can be formalized.  
% In what follows by ``provably'' we mean provably in $\mathcal{ST}$. 
% (Or we can say that there is a model of Turing machines in the sense of model theory, and $S$ accepts this model.) 
\begin{theorem} \label{thm:negCon} Let $H $ be as above then:
\begin{equation*}
 \mathcal{ST} \vdash (\exists H' \in \mathcal{T} ^{\pm}: 
 \Theta _{H, H'})  \implies \neg Con (H).
\end{equation*} 
In other words if $H$ is provably computable then they are not consistent. 
\end{theorem}
 Note that the statement $K$: $$\mathcal{ST} \vdash (\exists H' \in \mathcal{T} ^{\pm}: 
 \Theta _{H, H'})$$ does not mean that the physical $H $ can prove the statement $M$:
\begin{equation} \label{eq:M}
\exists H' \in \mathcal{T} ^{\pm}: 
 \Theta _{H, H'}
\end{equation}
  in the practical sense. It just means that after the term $H$ in the statement $\Theta _{H, H' } $ has been suitably interpreted in set theory $\mathcal{ST}$, $M$ is provable in $\mathcal{ST}$.  But a set theoretic, in other words mathematical, interpretation of the term $H$ may not be practically attainable. At the least this necessitates detailed knowledge of the physics and biology underlying our humans. And even if this interpretation was attainable, $H$ may not be clever enough to find the proof of $M$, again in the practical sense. Also note that $\neg Con (H)$ expresses \emph{fundamental} inconsistency of $H$, as we only take stable assertions of $H$ above.  
 \begin{example} \label{example:0=1} Suppose that $H$ is provably computable as in the hypothesis of the theorem above. Then $\mathcal{F} (H)$ captures $H$ and $\neg Con (\mathcal{F} (H))$ by the theorem, and so $\mathcal{F} (H)$ proves $0=1$. Since $\mathcal{F} (H)$  captures $H$ the physical $H$ must \emph{stably} assert $0=1$.
\end{example}
\begin{proof}[Proof of Theorem \ref{thm:negCon}]
 Let $\mathcal{F} $ capture $H$ as above. By the proof of the second part of Theorem \ref{thm:2}:
\begin{equation*}
   \mathcal{ST} \vdash ((\exists H' \in \mathcal{T} ^{\pm}: 
 \Theta _{H, H'})  \implies L),
\end{equation*}
where 
   $L$ is: 
\begin{align*}
\exists m \in \mathbb{N}, \exists H' \in \mathcal{T} ^{\pm}: (pr \circ H    (H',m) \text{ is defined and is $(H,H')$-stable}) \land \\ \neg (pr \circ H (H',m) \text{ has property $sC (H, H' )$}).
\end{align*}
   So
\begin{equation*}
   (\mathcal{ST} \vdash M) \implies (\mathcal{ST} \vdash L) \implies (\mathcal{F} \vdash L),
\end{equation*}
where $M$ is as in \eqref{eq:M}.

On the other hand, by the assumption that $H $ is captured by $\mathcal{F}$:
\begin{align*}
\mathcal{F} \vdash
   (\forall m \in \mathbb{N}, \forall H' \in \mathcal{T} ^{\pm}: (pr \circ H    (H',m) \text{ is defined and is $(H,H')$-stable}) \implies \\ (pr \circ H (H',m) \text{ has property $sC (H, H' )$})).
\end{align*}
So $\mathcal{F} \vdash \neg L$.
\end{proof}
\section{Relationship with the Penrose argument and its previous criticism} \label{section:Penrose}
The most lucid criticism of the Penrose argument known to me appears in Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}. Although our argument is very different it is worthwhile to consider it in light of that existing criticism. Brushing aside for the moment concerns such as soundness of human reasoning, the reason that the argument of Penrose is susceptible criticism is that it is only a meta-argument, meaning principally that it partly relies on interpretation of truth and knowledge. In other words, it is not written as a proof in some formal system, even implied one.  And there may be logical subtleties to interpretation of truth that a non-logician such as myself or Penrose may simply miss. 

So what of the main argument of this paper? 
Here the situation is rather different. With the possible exception of the inessential Section \ref{section:formalsystem}, where we touch on some logic, our theorems are in fact theorems of set theory, just classical Zermelo-Fraenkel set theory. For example our G\"odel string $\mathcal{G}$ for a stably $C$-sound $M$ is proved in set theory to have property $sC$. In contrast, in  \cite{citePenroseBeyondShadow} Penrose asserts the truth of a certain analogously used G\"odel statement by a meta-proof. And this is exactly what is contested by Koellner. 
% So essentially instead of arguing
% in terms of truth of some sentences, we argue in terms of set theoretic properties of certain objects. This makes our argument more concrete.
% \footnote {As far as I can see the version of the Penrose argument I give in the introduction is free of the particular objection intended by Koellner, but this is a red herring since I don't propose it as an actual argument.} 

This is not to say that there are no issues of interpretation in this paper.  One must interpret our definition of stable soundness and more to the point the stable Penrose property as it applies to actual human beings.
We of course have already partly addressed this. For the moment my position is that the idealized human being of this paper is represented by the world scientific community $H$ (considered as evolving). As already discussed, it makes perfect sense for $H$ to have the stable Penrose property, so under the postulate that $H$ really does have it, our theorem can be interpreted to directly apply to this $H$.  

It is always the case that we must interpret mathematical theorems when applied to the real world. What one looks for is whether there is any meaningful physical obstruction to carrying out the necessary idealization in principle. In our specific case I see no such obstruction. 
Of course if the universe and humanity must eventually go extinct then our idealized humans cannot even in principle exist. But to me this is not a meaningful obstruction. The potential mortality of the universe is very unlikely to have any causal relation with computability of intelligence. So we can imagine an eternal universe, an immortal $H$ and run the argument, then translate to our universe.
\section{Concluding remark} While it can be argued that humans are not sound,  it would be very difficult to argue that we are not stably sound.  Scientists operate on the unshakeable faith that scientific progress converges on truth. And our interpretation above of this convergence as stable soundness is very simple and natural. Thus our results put a very serious obstruction to computability of intelligence.  

In addition, at least under the stronger hypothesis of Theorem \ref{thm:negCon}, stable unsoundness is testable/observable, at least in principle. 
For if $H$ is provably computable as in Example \ref{example:0=1} then $H$  must eventually \emph{stably}  assert $0=1$.  If we knew in addition that a given $H'$ computes $H$ then as $H'$ is a Turing machine we can simulate it on a powerful computer and see if such non-sense statements really do appear. Given our basic understanding of humanity, such a possibility seems too ridiculous. 
\subsection*{Acknowledgements} Dennis Sullivan, Bernardo Ameneyro Rodriguez, David Chalmers, and Peter Koellner for comments and helpful discussions.
% Bibliography
% \bibliography{pnas-sample}
%  \printbibliography
\bibliographystyle{siam}  
%  \bibliography{/root/texmf/bibtex/bib/link} 
   \bibliography{/home/yashasavelyev/texmf/bibtex/bib/link} 
\end{document}
