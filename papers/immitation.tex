\documentclass{amsart}  %[12pt] %\textwidth=125mm
\usepackage{etoolbox}

% \makeatletter
% \patchcmd{\@settitle}{\uppercasenonmath\@title}{}{}{}
%  \patchcmd{\@setauthors}{\MakeUppercase}{}{}{}
% % \patchcmd{\section}{\scshape}{}{}{}
% \makeatother
%\textheight=185mm
%\headheight=10mm
\usepackage{graphicx}
\newenvironment{itquote}
  {\begin{quote}\itshape}
  {\end{quote}\ignorespacesafterend}
\newenvironment{itpars}
  {\par\itshape}
  {\par}
\usepackage[autostyle]{csquotes}
\usepackage {appendix}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{hyperref} 
\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true}
\usepackage{amsmath}
\usepackage{amssymb}
% \usepackage[
%     backend=biber,
%     % defernumbers=true,
%     style=numeric,
%     % autocite=plain, 
%     sorting=none,
%     % sortlocale=us_US,
%     % natbib=true,
%     url=true, 
%     doi=false,
%     eprint=true
% ]{biblatex}
% \addbibresource{~/workspacemodules/link.bib}
\usepackage{amscd}
\usepackage{color}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{indentfirst}
\usepackage[hmargin=3cm,vmargin=3cm]{geometry}
% \usepackage[all, cmtip]{xy}
\numberwithin{equation}{section}
\newtheorem{thm}[equation]{Theorem} 
\newtheorem{axiom}[equation]{Axiom} 
\newtheorem{theorem}[equation]{Theorem} 
\newtheorem{proposition}[equation]{Proposition}
\newtheorem{lma}[equation]{Lemma} 
\newtheorem{lemma}[equation]{Lemma} 
\newtheorem{cpt}[equation]{Computation} 
\newtheorem{corollary}[equation]{Corollary} 
\newtheorem{remark}[equation]{Remark}
\newtheorem{clm}[equation]{Claim} 
\newtheorem{conjecture}{Conjecture}
\newtheorem{definition}[equation]{Definition}
\theoremstyle{definition}
% \newtheorem{definition}[equation]{Definition}
\newtheorem{ft}{Fact}
\newtheorem{notation}{Notation}
\newtheorem{descr}{Description}[equation]

\theoremstyle{remark}
\newtheorem*{pf}{Proof}
\newtheorem*{pfs}{Proof (sketch)}
\newtheorem{example}[equation]{Example}
\newtheorem{question}{Question}
\newtheorem{objection}{Objection}

\newcommand{\R}{{\mathbb{R}}}
\newcommand{\Z}{{\mathbb{Z}}}
% \newcommand{\C}{{\mathbb{C}}}
\newcommand{\Q}{{\mathbb{Q}}}
\newcommand{\D}{{\mathbb{D}}}
\newcommand{\HH}{{\mathbb{H}}}

\newcommand{\bs}{\bigskip}
\newcommand{\ra}{\rightarrow}
\newcommand{\del}{\partial}
\newcommand{\ddel}[1]{\frac{\partial}{\partial{#1}}}
\newcommand{\sm}[1]{C^\infty(#1)}

\newcommand{\delbar}{\overline{\partial}}
\newcommand{\Sum}{\Sigma}
% \newcommand{\G}{\mathcal{G}}
\newcommand{\Pe}{\mathcal{P}}
\newcommand{\X}{\mathfrak{X}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\K}{\mathcal{K}}

\newcommand{\ZZ}{\mathcal{Z}}
\newcommand{\eL}{\mathcal{L}}

\newcommand{\mone}{{-1}}
\newcommand{\st}{{^s_t}}
\newcommand{\oi}{_0^1}
\newcommand{\intoi}{\int_0^1}
\newcommand{\til}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\arr}[1]{\overrightarrow{#1}}
\newcommand{\paph}[1]{\{ #1 \}_{t=0}^1}
\newcommand{\con}{\#\;}
\newcommand{\codim}{\text{codim}}
\newcommand {\ham} {\text{Ham} (M, \omega)}
\newcommand {\isom} {\text{Isom} ^{h}  (M, \omega, j)}
\newcommand {\lham} {lie \text{Ham} (M, \omega)}
\newcommand {\hamcp} {\text{Ham} (\mathbb{CP} ^{r-1}, \omega )}
\newcommand{\overbar}{\overline}
\newcommand {\vM} {{(T^*)} ^{vert} \cM}
\newcommand{\om}{\omega}
\newcommand{\al}{\alpha}
\newcommand{\la}{\lambda}
\newcommand{\Om}{\Omega}
\newcommand{\ga}{\gamma}
\newcommand{\eps}{\epsilon}
\newcommand{\Cal}{\tex{Cal}}

\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cI}{\mathcal{I}}
% \newcommand{\cJ}{\mathcal{J}}

%\newcommand{\cO}{\mathcal{O}}
\newcommand{\cS}{\mathcal{S}}

\newcommand{\cU}{\mathcal{U}}

\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cM}{\bm{M}}
\newcommand{\cP}{\bm{P}}
\newcommand{\cL}{\bm{L}}

\newcommand{\fS}{\mathfrak{S}}
\newcommand{\fk}{\mathfrak{k}}
\newcommand{\fg}{\mathfrak{g}}
% \newcommand{\fz}{\mathfrak{z}}
\newcommand{\fZ}{\mathfrak{Z}}
\newcommand\vol{\operatorname{vol}}
\newcommand {\hatcp}{\widehat{\mathbb {CP}} ^{r-1} }
\newcommand{\rJ}{\mathrm{J}}
\newcommand{\rB}{\mathrm{B}}
\newcommand{\rT}{\mathrm{T}}
\newcommand {\Hpm} {\mathcal{H}^{\pm}}
\newcommand{\bP}{\mathbb{P}}

\DeclareMathOperator {\period} {period}
\DeclareMathOperator {\sign} {sign}
\DeclareMathOperator {\Id} {Id}
\DeclareMathOperator {\halt} {halt}

\DeclareMathOperator {\floor} {floor}
\DeclareMathOperator {\ceil} {ceil}
\DeclareMathOperator {\mult} {mult}
\DeclareMathOperator {\Symp} {Symp}
\DeclareMathOperator {\Det} {Det}
\DeclareMathOperator {\comp} {comp}
\DeclareMathOperator {\growth} {growth}
\DeclareMathOperator {\energy} {energy}
\DeclareMathOperator {\Reeb} {Reeb}
\DeclareMathOperator {\Lin} {Lin}
\DeclareMathOperator {\Diff} {Diff}
\DeclareMathOperator {\fix} {fix}
% \newcommand{\M}{\mathbb{CP} ^{r-1} }
\DeclareMathOperator {\grad} {grad}
\DeclareMathOperator {\area} {area}
\DeclareMathOperator {\diam} {diam}
% \DeclareMathOperator {\rank} {rank}
\DeclareMathOperator {\dvol} {dvol}
\DeclareMathOperator {\quant} {Quant}
\DeclareMathOperator {\ho} {ho}
\DeclareMathOperator {\length} {length}
\DeclareMathOperator {\Proj} {P}
\renewcommand{\i}{\sqrt{-1}}
\DeclareMathOperator{\mVol}{\mathrm{Vol}(M_0,\omega_0)}
\DeclareMathOperator{\Lie}{\mathrm{Lie}}
\DeclareMathOperator{\lie}{\mathrm{lie}}
\DeclareMathOperator{\op}{\mathrm{op}}
\DeclareMathOperator{\rank}{\mathrm{rank}}
\DeclareMathOperator{\ind}{\mathrm{ind}}
\DeclareMathOperator{\trace}{\mathrm{trace}}
\DeclareMathOperator{\image}{\mathrm{image}}
\DeclareMathOperator{\Sym}{\mathrm{Sym}}
\DeclareMathOperator{\Ham}{\mathrm{Ham}}
\DeclareMathOperator{\Aut}{\mathrm{Aut}}
\DeclareMathOperator{\Quant}{\mathrm{Quant}}
\DeclareMathOperator{\Fred}{\mathrm{Fred}}
\DeclareMathOperator{\id}{\mathrm{1}}
\DeclareMathOperator{\lcs}{l.c.s.}
\DeclareMathOperator{\lcsm}{l.c.s.m.}
% \DeclareMathOperator{\ker}{ker}
\DeclareMathOperator{\coker}{coker}

\begin{document}
\title {Stably sound Turing machines and intelligence} 
% less provocative
% Use letters for affiliations, numbers to show equal authorship (if applicable) and to indicate the corresponding author
\author{Yasha Savelyev} 
\href{http://yashamon.github.io/web2/papers/immitation.pdf} {Direct link to author's version}
\address{University of Colima, Department of Sciences, CUICBAS}
\email {yasha.savelyev@gmail.com}
\begin{abstract}
% We significantly extend the original disjunction of G\"odel, stating that either the idealized human mind is not computable or there exists  true Diophantine statements that a human mind will never decide to be true.
% The main issue is what means ``idealized'' 
We first develop a mathematical notion of stable soundness intended to reflect the soundness property of human beings. Then we formally extend a disjunction of G\"odel to show that given an abstract query machine $M$ the following cannot hold simultaneously: $M$ is stably sound, $M$ is computable, $M$ can stably decide the truth of any arithmetic statement. In practice this $M$ is meant to represent a human being so that the above gives an obstruction to computability of intelligence. To this end, we develop in a specific setting an analogue of a G\"odel statement for stably sound Turing machines.  
\end{abstract}
\maketitle
% \thispagestyle{firststyle}
% \ifthenelse{\boolean{shortarticle}}{\ifthenelse{\boolean{singlecolumn}}{\abscontentformatted}{\abscontent}}{}
% If your first paragraph (i.e. with the \dropcap) contains a list environment (quote, quotation, theorem, definition, enumerate, itemize...), the line after the list may have some extra indentation. If this is the case, add \parshape=0 to the end of the list environment.
% \dropcap{T}his PNAS journal template is provided to help you write your work in the correct journal format.  Instructions for use are provided below. 
%
% Note: please start your introduction without including the word ``Introduction'' as a section heading (except for math articles in the Physical Sciences section); this heading is implied in the first paragraphs. 
% We will give a complete definition of a Turing machine after the introduction.
In what follows we understand {\emph{human intelligence}  very much like Turing in \cite{TuringComputingMachines}, as a black box which receives inputs and produces outputs. More specifically, this black box $B$ is meant to be some system which contains a human subject. We do not care about what is happening inside $B$.
So we are not directly concerned here with such intangible things as understanding, intuition, consciousness - the inner workings of human intelligence that are supposed as special.  The only thing that concerns us is what output $B$ produces given an input, not how it is produced. Given this \emph{very} limited interpretation, the question that we are interested in is this: 
\begin{question} \label{quest1}
 Can human intelligence  be completely modelled by a Turing machine?  
\end{question}
An informal definition of a  Turing machine (see \cite{TuringComputableNumbers}) is as follows: 
it is an abstract machine which permits certain inputs, and produces outputs. The outputs are determined from the inputs by a fixed finite algorithm, defined in a certain precise sense. 
For a non-expert reader we point out that this ``fixed'' does not preclude the algorithm from ``learning'', \footnote {In the sense of ``machine learning''.} it just means that how it ``learns'' is completely determined by the initial algorithm. In particular anything that can be computed by computers as we know them can be computed by a Turing machine.  For our purposes the reader may simply understand a Turing machine as a digital computer with unbounded memory running some particular program. Unbounded memory is just a mathematical convenience.  In specific arguments, also of the kind we make, we can work with non-explicitly bounded memory.  
Turing himself has started on a form of Question 1 in his ``Computing machines and Intelligence'', \cite{TuringComputingMachines}, where he also informally outlined a  possible obstruction to a yes answer coming from G\"odel's incompleteness theorem. 


For the incompleteness theorem to have any relevance we need some assumption on the soundness or consistency of human reasoning.  
Informally, a human is sound if whenever they asserts something in absolute faith, this something is indeed true. This requires context as truth in general is undefinable.  For our arguments later on the context will be in certain mathematical models. 
However, we cannot honestly hope for soundness, as even mathematicians are not on the surface sound at all times, they may assert mathematical untruths at various  times, (but usually not in absolute faith). But we can certainly hope for some kind of fundamental soundness.


In this work we will formally interpret fundamental soundness as stable soundness. 
% For preliminary understanding of this  ``fundamental'' is as follows. We are on the surface unsound not because of fundamental internal inconsistencies of our mental constructions, but for the following pair of reasons.  First, due to time constraints humans make certain leaps of faith without fully vetting their logic. Second, the physically noisy, faulty, biological nature of our brain may lead to interpretation errors of our mental constructions. By ``faulty'' we mean the possibly common occurrence of faults in brain processes, coming from things like brain cell death, signaling noise between neurons, neurotransmitter imbalance, etc. Let us call all these possible fault vectors ``brain noise''. In other words, according to us to say that a human being is fundamentally sound, is to say that after ``stripping out'' the ``brain noise'',  this human being will be sound and have undiminished reasoning powers.  
% Later on we formally interpret fundamental soundness in terms of a certain mathematically precise notion of stable soundness. 
Essentially, our machine \footnote {Here we use the term machine as an abstraction for a process acting on inputs, but it need not be a  computational process, in contrast to Turing machines.} $B$ is now allowed to make corrections, and if a statement printed by $B$ is never corrected then this statement is true if $B$ has our stable soundness property. The negation of stably sound is stated as either stably unsound or not stably sound, synonymously. This stable soundness reflects our basic understanding of how science progresses. Of course even stable soundness needs idealizations to make sense for humans. The human brain deteriorates and eventually fails, so that either we idealize the human brain to never deteriorate in particular die, or $B$ now refers not to an individual human but to the evolving scientific community.  We call such a human \textbf{\emph{weakly idealized}}.

Around the same time as Turing, G\"odel argued for a no answer to Question 1, see \cite[310]{citeGodel}, relating the question to existence of absolutely unsolvable Diophantine problems, see also Feferman~\cite{citeFeferman2006-SFEATA}, and Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4} for a discussion.  
Essentially, G\"odel argues for a disjunction:
\begin{equation*}
   \neg ((S \text{ is computable}) \land (S \text{ is sound}) \land A),
\end{equation*}
where $S$ refers to a certain idealized subject, and where $A$ says that $S$ can decide any Diophantine problem. This is in essence correct, that is can be formalized, see  \cite{citeKoellnerII2018-KOEOTQ-4}.

However, what is meaning of idealized above?  If idealized just means stabilized in the sense of this paper then there is a Turing machine $T $ whose stabilization $T ^{s} $ provably solves the halting problem, cf. Example \ref{remark:dio}, and so $T ^{s} $ is no longer a Turing machine. In that case, the above disjunction becomes meaningless because we introduced non-computability by passing to the idealization.
So in this context one must be extremely detailed with what ``idealized'' means physically. 
The process of the physical idealization must be such that non-computability is not introduced in the ideal limit. In the case of weak idealization mentioned about it should certainly be possible, especially under the assumption of computability: the corresponding Turing machine / computer would be such a weak idealization! But this not what is needed by G\"odel, he needs an idealization that is plausibly sound otherwise the disjunction would again be meaningless. In this case, it is absolutely not clear if and how this can work since we have no idea what is happening in the human brain.

Alternatively, one can try to enrich the argument of G\"odel so that it explicitly allows for just fundamental soundness, understood here as stable soundness. But then we may worry: if stable soundness is such a loose concept that a Turing machine machine can stably soundly decide the halting problem, maybe Turing machines can stably soundly decide anything? No, we show here that there is a certain decision problem $\mathcal{P}$ that no Turing machine can stably soundly decide. And this is one ingredient for the following theorem.

% Since existence of absolutely undecidable problems is such a difficult and contentious issue, even if G\"odel's argument is in essence correct, it is not completely compelling. Interestingly, for G\"odel fundamental unsoundness of human reasoning is not even a possibility, it does not seem to be stated in \cite{citeGodel}.  A more in depth analysis of G\"odel versus Turing on computability and the mind appears for example in \cite{citeCopelandShagrirComputability}.  

After G\"odel, Lucas \cite{citeLucas} and later again and more robustly Penrose \cite{citePenroseBeyondShadow} argued for a no answer based only on soundness, and by further elaborating the obstruction from the G\"odel incompleteness theorem.   
% They further elaborated the obstruction coming from G\"odel's incompleteness theorem. And they reject the possibility that humans could be unsound on a fundamental level, as does G\"odel but for him it   
% \footnote {It is likely most mathematicians would sympathize with G\"odel, after all the entirety mathematics is meaningless if mathematicians are fundamentally unsound.} 
% For disclosure this author does believe in consistency of human beings, but to me consistency always seemed to be an emergent feature of something deeper, (consciousness perhaps).  The main common objections to their argument concern the meta-logic of the argument, see for instance \cite{citeChalmers}, \cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}.  
It should also be noted that for Penrose, in particular, non-computability of intelligence is evidence for new physics, and he has specific and \emph{very} intriguing proposals with Hameroff~\cite{citeHAMEROFF201439} on how this can take place in the human brain.  Here is also a partial list of some partially related work on mathematical models of brain activity and or quantum collapse models: \cite{cite:Quanta}, \cite{citeKremnizer2015}, \cite{citeHoffmanAgents}, \cite{cite:GrindfordConsciousnessPerspective}.

A number of authors, particularly Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}, argue that there are likely unresolvable meta-logical issues with the Penrose argument, even allowing for soundness. See also Penrose~\cite{citePenroseBeyondShadow}, and Chalmers~\cite{citeChalmers} for discussions of some issues. After sincerely attempting to resolve these issues from a more elementary perspective (in the language of Turing machines) I concede that Koellner is right.  
The issue, as I see it, is loosely speaking the following. The kind of argument that Penrose proposes is a meta-algorithm $P$ that takes as input specification of a Turing machine or a formal system, and has as output a natural number (or a string, sentence).  Moreover, each step of this meta-algorithm is constructive (computably constructive). But the goal of the meta-algorithm $P$ is to prove $P$ is not computable as a function! So even on this surface level this appears impossible, unless $P$ does something non-constructive, but then we must prove that our human can carry out this non-constructive step, and we are back to where we started.

What we argue here is that there is much more compelling version of the original G\"odel disjunction, which only needs stable soundness. 
The following is a slightly informal version of our main Theorem \ref{thm:3}.
% , taking the view that our weakly idealized human is represented by the evolving scientific community or just $H$ for short.  
% The sole formal property that we postulate for $H$, what we call the stable Penrose property, will be explained in Section \ref{section:systemMpm}. It is analogous to the arithmetic Penrose property, we describe just below in the outline of the Penrose argument.
% Essentially this property just says that $H$ asserts that $H$ is stably sound. (This is quiet rational given our definition of stable soundness.) 
\begin{theorem} \label{thm:1} Either there are cognitively meaningful, absolutely non Turing computable processes in the human brain or human beings are fundamentally unsound meaning specifically stably unsound, or for any (could be weakly idealized) $S$ there exists a certain true arithmetic statement, let's call it $\mathcal{H} (S)$ \footnote {$\mathcal{H} (S)$ is a statement in the language of Turing machines and so is number theoretic, however it is not a Diophantine problem. Of course it cannot be, by Example \ref{remark:dio}.}, that $S$ will never stably soundly determine to be true. This theorem is indeed a mathematical fact \footnote{Specifically a theorem of set theory, although we keep set theory implicit as usual.}, given our formalizations.  
\end{theorem} By \emph{absolutely} we mean in any sufficiently accurate physical model. Note that even existence of absolutely non Turing computable processes in nature is not known. For example, we expect beyond reasonable doubt that solutions of fluid flow or $N$-body problems are generally non Turing computable (over $\mathbb{Z}$, if not over $\mathbb{R}$ cf. \cite{citeBlumShubSmalen}) as modeled in essentially classical mechanics.  But in a more physically accurate and fundamental model they may both become computable, possibly if the nature of the universe is ultimately discreet. It would be good to compare this theorem with Deutch~\cite{citeDeutsch}, where computability of any suitably finite and discreet physical system is conjectured. Although this is not immediately at odds with us, as the hypothesis of that conjecture may certainly not be satisfiable. 

% Clearly, the weakest link in the above theorem is determinability of $\mathcal{H}$. After all the halting problem is not decidable by a Turing machine, so perhaps the conclusion of the theorem is not really surprising? But here we must be careful, for in the above theorem we only need $H$ to \emph{stably} decide $\mathcal{P}$, the meaning of which is given in Section \ref{section:systemMpm}.  On the other hand, as mentioned there is a Turing machine which can stably decide the halting problem, cf. Remark \ref{remark:stable}. 
% So already on this level there is perhaps something surprising happening in the above theorem. 
%
% Like the halting problem for a particular Turing machine, $\mathcal{P}$ would be part of a collection of problems $\{\mathcal{P} (S')\} _{S'} $ indexed by certain Turing machines. We will in addition explain that if $H$ is stably sound and computable then there exists $H'$ computing $H$ so that $\mathcal{P} (H')$ is trivial. This  $H'$ may not be practically constructable, since first need to know that some particular $H''$ computes $H$, and then we need to know that $H$ is stably sound, to construct the reduction $H'$ of $H''$. But $H'$ would exist in principle. So if we make a certain simple assumption on $H$ this disproves the last disjunct of the 
% theorem. We discuss this in Section \ref{}. 
%
% theorem. if we make an assumption on $H$ that it can 
% if we assume that $H$ can solve all these trivial 
% Only in principle, because no matter how trivial the problem I cannot \emph{know} that I can (stably soundly) solve it, until I do.
% By strengthening the hypothesis of Theorem \ref{thm:1} from computability  to provable computability as in Theorem \ref{thm:negCon}, we can obtain more practical consequences. To the effect that not only is $H$ stably unsound but must in fact eventually stably assert $0=1$.  % \subsection{The Penrose argument} \label{section:outline}
% Following Lucas \cite{citeLucas}, Penrose has given variations of the argument for a no answer to Question 1 in his books \cite{citePenroseEmperor}, \cite{citePenroseShadows}. 
% The final argument can be found in \cite{citePenroseBeyondShadow}, which we now re-interpret in a language closer to our subsequent argument. The following argument (really just an outline) is more elaborate then what was originally proposed by Penrose, but this is because we make some additional things explicit.
% % For example, we remove the need to formalize statements of the form ``I am captured by the formal system \mathcal{F}'', which appear in the Penrose argument. 
% % \footnote {It is not obvious to me that this problem can be solved at all, in the original argument of Penrose, since at the least this requires detailed knowledge of the physical-biological system underlying ``I''.} 
% % Given a formal system $\mathcal{F}$ the statement $\Theta _{\mathcal{F}} $: \begin{equation*} \text{I am $\mathcal{F}$}, \end{equation*} % will mean that any statement in arithmetic that I assert to be true is provable in $\mathcal{F}$, e.g. ``There are infinitely many primes.'' may be such a statement. The statement $\Theta _{\mathcal{F}} $ for an $\mathcal{F}$ satisfying certain properties is equivalent to me being computable as a machine printing statements in arithmetic. We will call such an $\mathcal{F}$ \textbf{\emph{good}}. 
% % \footnote {Explicitly, it is a condition for the axioms of $\mathcal{F}$ being recursively enumerable, plus another minor condition on $\mathcal{F}$ being able to prove enough basic things about numbers.} So we suppose from now on that $\mathcal{F}$ is good, since  computability is what we are interested in.
% %
% % Now I assert I am consistent, which entails more specifically that I assert:
% %  \begin{equation} \label{eq:ThetaF} \text{If $\Theta _{\mathcal{F}}$ then $\mathcal{F}$  is consistent.} 
% % \end{equation}
% %  By $\mathcal{F}$ being consistent we just mean that the formal system $ \mathcal{F}$ does not prove a statement and its logical negation.   %  \begin{emark} %  Asserting ones own consistency is not completely irrational, as most people assert their consistency in some form by implication.  For if a human $H$ asserts $0 \neq 1$ in absolute faith, that is $H$ asserts that they will never assert $0=1$, while ``sane'', then by implication $H$ asserts a form of consistency.  For if $H$ is not consistent (but accepts basic logic) they must eventually assert everything, while ``sane'', in particular $0=1$.  Of course if we analyze this more deeply then it is not exactly classical consistency that $H$ asserts, but rather certain stable consistency, we will get back to this soon, and for now delve no further.
% % \end{remark}
% %  As I assert \eqref{eq:ThetaF} then I also assert by implication $I _{\mathcal{F}} $:
% % \begin{equation*}
% % \text{If $\Theta _{\mathcal{F}}$ then $G (\mathcal{F})$.} 
% % \end{equation*}
% % % <<<<<<< HEAD
% % % where $G (F)$ is the G\"odel statement of $F$, since $G (F)$ is true if $F$ is consistent. 
% % % There would be a contradiction if I assert $G (F)$, since $G (F)$ is something that $F$ cannot prove. Unfortunately, I  cannot assert $G (F)$, I can only assert $I _{F} $, so there is no contradiction here. But we fix this idea as follows.
% % % Unfortunately, to fix this idea we need to get a bit more technical.
% % % =======
% % % where $G (F)$ is the arithmetic G\"odel statement of $F$, which can be constructed because $F$ is good, and this statement is true because $F$ is consistent.
% % % >>>>>>> 60798006c341b01b38b0f2f3f78091e227eb95d1
% % %
% % If I assert $G (\mathcal{F})$, then this would be a contradiction to either my consistency or to $\Theta _{\mathcal{F}} $, since $G (\mathcal{F})$ is something that $\mathcal{F}$ cannot prove. Unfortunately I cannot rationally assert $G (\mathcal{F})$, since I don't know $\Theta _{\mathcal{F}} $. I only assert $I _{\mathcal{F}} $, so there is no meaningful contradiction here.  But we may try to fix this idea as follows. For this fix we need to get a bit more technical.  
% %
% % \subsection{Outline of a partial fix of the Lucas-Penrose argument} 
%
% While this outline uses some of the language of formal systems, we will \emph{not} use this language in our main argument, which is based purely on the language of Turing machines and is much more elementary. 
%
% Suppose a human subject $P$ is in contact with experimenter/operator $E$. The input strings that $E$ gives $P$ are pairs $(\Sigma _{T},n)$ for $\Sigma_{T} $ specification of a Turing machines $T$, and $n \in \mathbb{N}$. The output $P (\Sigma _{T}, n )$ is a statement of arithmetic printed by $P$. (For now there is no requirement on truth.) 
%
% Given a Turing machine $T$ let $\Theta _{T} $ be the statement: 
% \begin{equation} \label{eq:condition}
% \text{$T$ computes } P. 
% \end{equation} 
% % We suppose that $P (\Sigma _{T},n)$, which he asserts to hold if $\Theta _{T} $ holds.
% % We ask that each  $P (\Sigma _{T},n)$ is an element of $Strings$ - the set of finite strings on a fixed finite alphabet.
%
% We ask that for each fixed $T$: 
% $\{P (\Sigma _{T},n)\} _{n} $ is the complete list of statements that $P$ perceives \footnote{``Perceive'' can be understood to mean here ``assert to be true with absolute faith'', later on we give it a formal meaning.} to be true conditionally on $\Theta _{T} $. This may look somewhat self referential,  but this can be fixed, cf. Section \ref{section:systemMpm}.  It follows by the above that $P$ must also perceive for each $T$ the statement $I _{T}$: \begin{equation} \label{eq:Theta} \Theta _{T} \implies T \text{ is sound},
% \end{equation}
% which means that $T (\Sigma _{T},n)$ is true for each $n$. 
% % This can be deduced from a more fundamental property that any statement of arithmetic asserted by $P$ to be true is true. Since for each $m$: 
% % $$\Theta _{T} \implies T (\Sigma _{T} ) \text{ is sound}$$
% % By $T$ being consistent we mean here:  $$T (\Sigma _{T},n) \neq \neg (T (\Sigma _{T},m)),$$ for any $n,m$ with $\neg$ the logical negation of the statement, and where inequality is just string inequality of the corresponding sentences. 
% % We ignore for now whether $P$ making such an assertion is rational.
% % The list is infinite but if $P$ is computable it is determined by a Turing machine, and all arguments refer to this machine. So that even in practice dealing with such a list should not be an issue.
% % If the reasoning powers of $P$ could be totally captured by some fixed formal system then all sentences in this formal system could be enumerated, so that the above supposition is allowable for the purpose of what follows.  %
% %
% % \begin{itquote}
% % Here is a specification of a Turing machine $T$,  print your statement that you assert to be true assuming the truth of :
% % \end{itquote}
% % , which in the current setting means that is he asserts $P (\Sigma)$ is true conditionally on $\Theta _{T} $ for all $\Sigma$.  To emphasize this is not an assumption by $P$, but is what $P$ asserts as \emph{truth}.  
% % Now $P$ replies: 
% % \begin{itquote}
% % I know I am sound,  hence $T$ must be sound if it computes me, but I can then construct a G\"odel statement $G (T)$ for $T$, which is then a true statement in arithmetic, and which indirectly asserts ``$T$ cannot print $G (T)$''.  
% % \end{itquote}
% % This alone doesn't quite work however for $E$ counters: 
% % \begin{itquote}
% % I see, but do \emph{you} in fact in print $G (T)$? This is the only way you can presently reach a contradiction, as $T$ only computes what you print, not what you can meta-prove.
% % \end{itquote}
% %  $P$ has to say no! Because he does not in fact know $G (T)$ is true, since he has to know that $T$ is sound, and this only happens (from his point of view) if he knew for a fact: $T$ computes $P$. If $P$ does print $G (T)$ then he is patently unsound, as he has no basis to assert $G (T)$, so his very belief that he is sound would be absurd.  
% % \subsubsection* {A possible fix} (Outline)
% % We can try to fix the above argument as outlined in the following, and 
%
% Let then $T _{0} $ be a specified Turing machine, and suppose that $E$ passes to $P$ input of the form $(\Sigma _{T _{0} }, n)$.  % Now $P$ reasons that since he is fundamentally sound, so that his deductions based on each $\Theta _{T} $ are sound, the following  must hold:
% % \begin{equation} 
% % \Theta _{T _{0} } \implies \forall n \, T _{0} (\Sigma _{T _{0}},n).
% % \end{equation}
%  Now, as is well known \footnote {I don't know a standard reference but see  for example \cite{citeFeferman2006-SFEATA}.}, the statements $\{T _{0} (\Sigma _{T _{0} },n)\} _{n}  $  must be the complete list of provable statements \footnote {Strictly speaking after taking deductive closure.} in a certain formal system $\mathcal{F} (T _{0} )$, explicitly constructible given $T _{0} $. 
% Loosely, a formal system consists of a language: alphabet and grammar, a collection of sentences in this language understood as axioms,   and finally a deductive system.  
%
% By construction $\mathcal{F} (T _{0} )$ would be sound if $\Theta _{T _{0} } $ and if $I _{T _{0} } $. In particular if $\Theta _{T _{0}} \land I _{T _{0} } $ then by the celebrated G\"odel incompleteness theorem there would be a true  G\"odel statement $G (T _{0})$ for this $\mathcal{F} (T _{0} )$,  such that $$T _{0} (\Sigma _{T _{0} }, n ) \neq G(T _{0}), \quad \text{ for all $n$.}$$     
% % This is at least assuming some additional properties of $P$ so that $\mathcal{F} (T _{0} )$ would satisfy the other condition of G\"odel's theorem, (we need that $\mathcal{F} (T _{0} )$ could interpret certain arithmetic).
% % >>>>>>> 781e40d42a1b58a417d15c4c5061821de1338b27
%
% But $P$ perceives $I _{T _{0} } $, hence he must perceive by implication that $$ \Theta_{T_{0}} \implies G(T_{0}).$$ And so assuming $P$ knows how to construct $G (T _{0} )$ then this statement must be in the list $\{P (\Sigma _{T _{0} },n)\} _{n}  $, and so in the list $\{T _{0}  (\Sigma _{T _{0} },n)\} _{n}  $,  so we would get a contradiction. 
% % Direct constructibility of $G (T _{0} )$ by $P$ is likely not an issue, since the formal system $\mathcal{F} (T _{0} )$ is after all known to $P$. But this is a potential problem best studied by an expert logician.  So assuming $G (T _{0} )$ is indeed constructible by $P$, 
% So we conclude that either not $\Theta _{T _{0} } $, that is $P$ is not computed by $T _{0} $ or $P$ is not sound, but $T _{0} $ is arbitrary so we obtain an obstruction to computability of $P$.  
%   
%
% Even if it was in essence correct, the above argument is unsatisfactory because all it claims to prove is:  either we are non-computable or unsound, which we appear to be anyway. Of course as we have argued we must talk of fundamental soundness, interpreted here as stable soundness.
% But then the argument cannot work exactly as above, since G\"odel's theorem necessitates total soundness. This is a highly  non-trivial issue, as while we can abstractly extract from a stably sound machine an absolutely sound machine, the latter may not be computable even if the former was, cf. Remark \ref{remark:stable}. So we cannot just hope to fix things by saying our human is idealized, without being extremely detailed what ``idealized'' means physically. For if idealized just means stabilized as in Remark \ref{remark:stable} then such an idealization may introduce non-computability.
%
% We will delve no further into critiquing the Lucas-Penrose argument. One such critique is given in Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4},  .  Note of course that our version of the Penrose argument is slightly different, and so the issues might be different.  

The thrust of the paper is to formally define stable soundness, and construct a new type of G\"odel statements which works under this weaker hypothesis. Although our notion of stable soundness is general the G\"odel statement is only constructed in a limited setting. Indeed it would be interesting to understand if this can be extended.
% Unfortunately we cannot even be certain that such a statement exists, since $\Theta _{T} $ are not  well defined statements since $P$ is not defined. Consequently $\mathcal{F} (T _{0} )$ at least a priori is not a well defined formal system, and we cannot use G\"odel incompleteness theorem.  % formally defining fundamental soundness in terms of a certain notion of stable soundness, and \emph{explicit} construction of the ``G\"odel statement'', which crucially works under this stable soundness hypothesis. 

We first isolate a certain class of Turing machines that we name diagonalization machines. They print strings with a certain property $C$. As the name suggests, their behavior is related to the Cantor diagonalization argument.  Next we explicitly construct a ``G\"odel string'' $\mathcal{G}$ which is universal for this whole class. 
This string $\mathcal{G}$ has property $C$ but cannot be printed by a Turing diagonalization machine. Crucially, this is then extended to stable diagonalization machines, which print property  $C$ \footnote {The property is not exactly the same, it has to be suitably stabilized.} strings only stably. This $\mathcal{G}$ is then used for the proof of the above theorem.
Strictly speaking we can prove the theorem more directly, but most of the setup needed for the construction of $\mathcal{G}$ would still be necessary, and using $\mathcal{G}$ makes the argument more conceptual. In addition it may be of independent interest.

This is essentially as far as we can go in trying to outline the argument, as most of it just concerns the construction of the class of diagonalization machines and of $\mathcal{G}$, and this is hard to describe without details. However, technically the paper is mostly elementary and should be widely readable in entirety. 
\section {Some preliminaries} \label{sec:prelims}
This section can be just skimmed on a first reading.
Really what we are interested in is not Turing machines per se, but computations that can be simulated by Turing machine computations. These can for example be computations that a mathematician performs with paper and pencil, and indeed is the original motivation for Turing's specific model. However to introduce Turing computations we need Turing machines. Here is our version, which is a computationally equivalent, minor variation of Turing's original machine.
\begin{definition} \label{def:Machine} A \textbf{\emph{Turing machine}} $M$ consists of:
  \begin{itemize} 
     \item Three infinite (1-dimensional) tapes $T _{i}, T _{o}, T _{c}   $, (input, output and computation) divided into discreet cells, next to each other. Each cell contains a symbol from some finite alphabet $\Gamma$. A special symbol $b \in \Gamma$ for blank, (the only symbol which may appear infinitely many often).
     \item Three  heads $H _{i}, H _{o}, H _{c}   $ (pointing devices),  $H _{i} $ can read each cell in $T _{i} $ to which it points, $H _{o}, H _{c}  $ can read/write each cell in $T _{o}, T _{c}  $ to which they point.
        The heads can then move left or right on the tape.
     \item A set of internal states $Q$, among these is ``start'' state $q _{0} $. And a non-empty set $F \subset Q$ of final states.
\item Input string $\Sigma$: the collection of symbols on the tape $T _{i} $, so that to the left and right of $\Sigma$ there are only symbols $b$. We assume that in state $q _{0} $ $H _{i} $ points to the beginning of the input string, and that the $T _{c} $, $T _{o} $ have only $b$ symbols.
\item A finite set of instructions: $I$, that given the state $q$ the machine is in currently, and given the symbols the heads are pointing to, tells $M$ to do the following. The actions taken, 1-3 below, will be (jointly) called an \textbf{\emph{executed instruction set}} or just \textbf{\emph{step}}:
\begin{enumerate} \label{enumerate}
   \item Replace symbols with another symbol in the cells to which the heads $H _{c}, H _{o}  $ point (or leave them).
   \item Move each head $H _{i}, H _{c}, H _{o}   $ left, right, or leave it in place, (independently).
   \item Change state $q$ to another state or keep it.
\end{enumerate}
\item Output string $\Sigma _{out} $,  the collection of symbols on the tape $T _{o} $, so that to the left and right of $\Sigma _{out} $ there are only symbols $b$, when the machine state is final. When the internal state is one of the final states we ask that the instructions are to do nothing, so that these are frozen states.  
  \end{itemize} 
\end{definition}
% So a Turing machine $M$ determines a function:
% \begin{equation} \label{eq:transition}
% \delta ^{M} : Q \times \Gamma \to Q \times \Gamma \times \{L,R,H\},
% \end{equation}
% where $L,R,H$ correspond to move head left, right, or hold in place.
% We also have the following minor variations on standard definitions, and notation.
\begin{definition} A \textbf{\emph{complete configuration}} of a Turing machine $M$ or \textbf{\emph{total state}} is the collection of all current symbols on the tapes, position of the heads, and current internal state. Given a total state $s$, $\delta (s)$ will denote the successor state of $s$, obtained by executing the instructions set of $M$ on $s$, or in other words $\delta(s)  $ is one step forward from $s$.
\end{definition}
So a Turing machine determines a special kind of function:
\begin{equation*}
\delta ^{M} : \mathcal{C} (M)  \to \mathcal{C} (M),
\end{equation*}
where $\mathcal{C} (M)$ is the set of possible total states of $M$. 
%  It is moreover possible to define Turing machines more abstractly, by formalizing properties of these functions. 
\begin{definition}
   A \textbf{\emph{Turing computation}}, or \textbf{\emph{computation sequence}} for $M$ is a possibly not eventually constant sequence $$*M (\Sigma):= \{s _{i} \} _{i=0} ^{i=\infty} $$  of total states of $M$,  determined by the input $\Sigma$ and $M$,  with $s _{0}  $ the initial configuration whose internal state is $q _{0} $, and where $s _{i+1} = \delta (s _{i} ) $.
If elements of $\{s _{i} \} _{i=0} ^{i=\infty}$ are eventually in some final machine state, so that the sequence is eventually constant, then we say that the computation \textbf{\emph{halts}}.  In this case we denote by $s _{f} $ the final configuration, so that the sequence is eventually constant with terms $s _{f} $. We define the \textbf{\emph{length}} of a computation sequence to be the first occurrence of $n>0$ s.t. $s _{n}=s _{f}  $.
For a given Turing computation $* M (\Sigma)$, we will write \begin{equation*}
   * M (\Sigma) \to x, 
   \end{equation*}
if $* M (\Sigma)$ halts and $x$  is the output string. 
\end{definition}
We write $M (\Sigma)$ for the output string of $M$, given the input string $\Sigma$, if the associated Turing computation $*M (\Sigma)$  halts. 

\begin{definition} Let $Strings$ denote the set of all finite strings, including the empty string $\epsilon$, of symbols in some fixed finite alphabet, with at least 2 elements.
Given a partial function $f: Strings \to Strings$, that is a function defined on some subset of $Strings$ - we say that a Turing machine $M$ \textbf{\emph{computes}} $f$ if  $$*M (\Sigma) \to f (\Sigma) \text{ whenever $f (\Sigma)$ is defined}.
   $$ \end{definition}

 So a Turing machine $T$ itself determines a partial function, which is defined on all $\Sigma \in Strings$ s.t. $*T (\Sigma)$ halts, by $\Sigma \mapsto T (\Sigma)$.  
The following definition is purely for writing purposes.
\begin{definition} \label{def:equivalent} Given Turing computations (for possibly distinct Turing machines) $*T _{1} (\Sigma _{1} ) $, $* T _{2} (\Sigma _{2} ) $ we say that they are \textbf{\emph{equivalent}} if they both halt with the same output string or both do not halt. We write $T _{1} (\Sigma _{1} )  = T _{2} (\Sigma _{2} ) $ if $*T _{1} (\Sigma _{1} ) $, $* T _{2} (\Sigma _{2} ) $ both halt with the same value.
% We say a pair of Turing machines $T _{1}, T _{2}  $  are \textbf{\emph{equivalent}} if they compute the same operator.
\end{definition} 
In practice we will allow our Turing machine $T$ to reject some elements of $Strings$ as valid input. We may formalize this by asking that there is a special final machine state $q _{reject} $, so that $T (\Sigma)$ halts with $q _{reject} $ for $$\Sigma \notin {I} \subset Strings,$$ where ${I}$ is some set of all valid, that is $T$-\textbf{\emph{permissible}} input strings.  We do not ask that for $\Sigma \in I$ $*T (\Sigma)$ halts. If $*T (\Sigma)$ does halt then we will say that $\Sigma$ is $T$-\textbf{\emph{acceptable}}.
It will be convenient to forget $q _{reject} $ and instead write $$T: {I} \to O,$$ where ${I} \subset Strings$ is understood as the subset of all $T$-permissible strings, or just \textbf{\emph{input set}} and $O$ is the set output strings or \textbf{\emph{output set}}.
% Vj, keeping all other data implicit.  The specific interpretation should be clear in context.  

We will sometimes use abstract sets to refer to input and output sets.  However, these are understood to be subsets of $Strings$ under some implicit, \emph{fixed} encoding. Concretely an \textbf{\emph{encoding}}
of $A$ is an injective set map $i: A \to Strings$. For example if the input set is $Strings ^{2} $, we may encode it as a subset of $Strings$ as follows. The encoding string of $\Sigma \in Strings ^{2} $ will be of the type: ``this string encodes an element $ Strings ^{2} $, whose components are $\Sigma _{1}$ and $\Sigma _{2}  $.'' In particular the sets of integers $\mathbb{N}, \mathbb{Z}$, which we use often,  will under some encoding correspond to subsets of $Strings$.  Indeed this abstracting of sets from their encoding in $Strings$ is partly what computer languages do. The fixing of the encoding can be understood as fixing the computer language.  

 The above will allow us to work with a set $\mathcal{T}$ of Turing machines, with abstract sets of inputs and outputs implicitly encoded as subsets of $Strings$ as above. Note that $\mathcal{T}$ itself has an induced encoding, called its program. Of course, concretely $\mathcal{T}$ is nothing more then the set of Turing machines, with a distinguished final state called $q _{reject} $.  \begin{definition}  We say that a Turing machine $T$ computes a partial function $f: I \to J$, if $I$ is contained in the set of permissible inputs of $T$  and $*T (\Sigma) \to f (\Sigma)$,  whenever $f (\Sigma)$ is defined, for $\Sigma \in I$.
\end{definition} 

Given Turing machines $$M _{1}: {I} \to {O}, M _{2}: {J} \to {P},$$ we may naturally \textbf{\emph{compose}} them to get a Turing machine $M_2 \circ M _{1}: C \to P $, for $C=M _{1} ^{-1} ({O} \cap {J})$, ($O \cap J$ is understood as intersection of subsets of $Strings$). $C$ can be empty in which case this is a Turing machine which rejects all input. Let us not elaborate further.
\subsection {Join of Turing machines} Our Turing machine of Definition \ref{def:Machine} is a multi-tape enhancement of a more basic notion of a Turing machine with a single tape,
but we need to iterate this further.  

We replace a single tape by tapes $T ^{1}, \ldots, T ^{n}  $
in parallel, which we denote by $(T ^{1} \ldots T ^{n})$ and call this $n$-tape.
The head $H$ on the $n$-tape has components $H ^{i} $ pointing on the corresponding tape $T ^{i} $. When moving a head we move all of its components separately. A string of symbols on $(T ^{1} \ldots T ^{n})$ is an $n$-string, 
formally just an element $\Sigma \in Strings ^{n} $, with $i$'th component of $\Sigma$
specifying a string of symbols on $T ^{i} $. The blank symbol $b$ is the symbol $(b ^{1}, \ldots, b ^{n} )$  with  $b ^{i} $ blank symbols of $T ^{i} $.









Given Turing machines $M ^{1}, M ^{2}  $ we can construct what we call a \textbf{\emph{join}} $M ^{1} \star M ^{2}  $, which is roughly  a Turing machine where we alternate the operations of $M ^{1}, M  ^{2}  $. In what follows symbols with superscript $1,2$ denote the corresponding objects of $M ^{1} $, respectively $M ^{2} $, cf. Definition \ref{def:Machine}. 


$M ^{1} \star M ^{2}  $ has three 2-tapes: $$(T ^{{1} } _{i}  T ^{{2} } _{i}),    (T ^{{1} } _{c}  T ^{{2} } _{c}  ), (T ^{{1} } _{o}  T ^{2}  _{o} ),   $$ three heads $H _{i}, H _{c}, H _{o}   $ which have component heads $H ^{j} _{i}, H ^{j} _{c}, H ^{j} _{o}      $, $j=1,2$. It has machine states: $$Q _{M ^{1} \star M ^{2}  }   = Q ^{1} \times Q ^{2} \times (\mathbb{Z}_{2} = \{0,1\}),  $$ with initial state $(q _{0} ^{1}, q _{0} ^{2},0)$ and final states:
$$F _{M ^{1} \star M ^{2}  } = F ^{1} \times Q ^{2} \times \{1\} \sqcup Q ^{1} \times F ^{2} \times \{0\}.  $$

Clearly we have a natural splitting $$\mathcal{C} (M ^{1} \star M ^{2}  ) = \mathcal{C} (M ^{1} ) \times \mathcal{C} (M _{2} ) \times \mathbb{Z} _{2}.
$$ In terms of this splitting we define the transition function 
\begin{equation*}
\delta ^{M ^{1} \star M ^{2}  }: \mathcal{C} (M ^{1} \star M ^{2}  ) \to \mathcal{C} (M ^{1} \star M ^{2}  ),
\end{equation*}
for our Turing machine $M ^{1} \star M ^{2}  $ by:
\begin{align*}
   & \delta ^{M ^{1} \star M ^{2}  } (s ^{1}, s ^{2}, 0  ) = (\delta ^{M ^{1} } (s _{1}), s ^{2},1  ) ), \\
   & \delta ^{M ^{1} \star M ^{2}  } (s ^{1}, s ^{2}, 1  ) = ( s _{1}, \delta ^{M ^{2} } (s ^{2}),0 )).
\end{align*}
Or, concretely this means the following. Given machine state $q=(q ^{1}, q ^{2}, 0)$ and the symbols $$(\sigma _{i} ^{1} \sigma _{i} ^{2}), (\sigma _{c} ^{1} \sigma _{c} ^{2}), (\sigma _{o} ^{1} \sigma _{o} ^{2})      $$ to which the heads $H _{i}, H _{c}, H _{o}   $ are currently pointing, we first check instructions in $I ^{1} $ for $q ^{1} $, $ \sigma _{i} ^{1} ,  \sigma _{c} ^{1}, \sigma _{o} ^{1}    $, and given those instructions as step 1 execute:
\begin{enumerate}
 \item Replace symbols $\sigma ^{1}  _{c}, \sigma ^{1}  _{o}  $ to which the head components $H ^{1}  _{c}, H ^{1}  _{o}  $ point, or leave them  unchanged, while leaving unchanged the symbols to which $H ^{2}  _{c}, H ^{2}  _{o}  $ point.
\item Move each head component $H ^{1}  _{i}, H ^{1}  _{c}, H ^{1}  _{o}   $ left, right, or leave it in place, (independently). (The second components of the heads are unchanged.)
   \item Change the first component of $q$ to another machine state in $Q ^{1} $ or keep it, based on the instruction in $I ^{1} $. Leave the second component of $q$ unchanged. The third component of $q$ is changed to $1$.  
\end{enumerate} 
Then likewise given machine state $q=(q ^{1}, q ^{2}, 1)$,  we check instructions in $I ^{2} $ for $q ^{2} $, $ \sigma _{i} ^{2} ,  \sigma _{c} ^{2}, \sigma _{o} ^{2}$ and given those instructions as step 2 execute:
\begin{enumerate}
 \item 
Replace symbols $\sigma ^{2}  _{c}, \sigma ^{2}  _{o}  $ to which the head components $H ^{2}  _{c}, H ^{2}  _{o}  $ point, or leave them  unchanged, while leaving unchanged the symbols to which $H ^{1}  _{c}, H ^{1}  _{o}  $ point.
\item Move each head component $H ^{2}  _{i}, H ^{2}  _{c}, H ^{2}  _{o}   $ left, right, or leave it in place.
\item Change the second component of $q$ to another or keep it, based on instruction in $I ^{2} $. Leave the first component unchanged, and change the third component of $q$ to $0$.  
\end{enumerate} 
% So the above 2-step procedure applied to a total state $s$ gives two consecutive terms of the corresponding computation sequence.
\subsubsection {Input}
The input for $M ^{1} \star M ^{2}  $ is a 2-string or in other words pair $(\Sigma _{1}, \Sigma _{2}  )$, with $\Sigma _{1} $ an input string for $M ^{1} $, and $\Sigma _{2} $ an input string for $M ^{2} $.
\subsubsection {Output} The output for $$*M ^{1} \star M ^{2} (\Sigma _{1}, \Sigma _{2}  )  $$ is defined as follows. If this computation halts then the 2-tape $(T ^{1} _{o} T ^{2} _{o}    )$ contains a 2-string, bounded by $b$ symbols, with $T ^{1} _{o}  $ component $\Sigma ^{1} _{o}$ and $T ^{2} _{o}  $ component $\Sigma ^{2} _{o}$.
Then the output $M ^{1} \star M ^{2} (\Sigma _{1}, \Sigma _{2}  )$ is defined to be $\Sigma ^{1} _{o}  $ if the final state is of the form $(q _{f},  q, 1) $ for $q _{f} $ final, or $\Sigma ^{2} _{o}  $ if the final state is of the form $(q,  q _{f},0) $, for $q _{f} $ likewise final. 
\subsection {Universal Turing machines} It will be convenient to refer to the universal Turing machine $$U: \mathcal{T} \times Strings \to Strings,$$ for $\mathcal{T}$ the set of Turing machines as already indicated above.
This universal Turing machine already appears in Turing's \cite{TuringComputableNumbers}. It permits as input a pair $(T,\Sigma)$ for $T$ an encoding of a Turing machine and $\Sigma$ input to this $T$. It can be partially characterized by the property that for every Turing machine $T$ and string $\Sigma$ we have: \begin{equation*} *T (\Sigma) \text{ is equivalent to } *U (T,\Sigma).
\end{equation*}
\subsection {Notation}
In what follows $\mathbb{Z}$ is the set of all integers and $\mathbb{N}$ non-negative integers. 
 We will sometimes specify a Turing machine simply by specifying a function $$T: {I} \to {O},$$ with the full data of the underlying Turing machine being implicitly specified, in a way that should be clear from context.  
When we intend to suppress dependence of a variable $V$ on some parameter $p$ we often write $V=V (p)$, this equality is then an equality of notation not of mathematical objects.
\section {Preliminary setup for the proof of Theorem \ref{thm:1}}
This section can be understood to be a warm up, as we will not yet work with stable soundness. But most of this will carry on to the more technical 
setup of Section \ref{section:fundamentalSoundness}.
\begin{definition} A \textbf{\emph{machine}} \footnote {For some authors and in some of the writing of Turing and G\"odel ``machine'' is synonymous with Turing machine. For us the term machine is just abstraction for a process.} will be a synonym for a partial function  $A: I \to O$, with $I,O$ abstract sets with a fixed, prescribed encoding as subsets of $Strings$, (cf. Preliminaries).  
\end{definition} $\mathcal{M}$ will denote the set of machines.  Given a Turing machine $T: I \to O$,  we have an associated machine $fog(T)$ by forgetting all structure except the structure of a partial function.  $\mathcal{T}$ will denote the set of machines, which in addition have the structure of a Turing machine.  So we have a forgetful map $fog: \mathcal{T} \to \mathcal{M}$.

  
\subsection {Diagonalization machines} \label{sec:diagonalizationmachines}
There is a well known connection between Turing machines and formal systems, see for instance \cite{citeFeferman2006-SFEATA}. So G\"odel statements  can already be interpreted in Turing machine language as certain G\"odel strings. But we will be aiming to construct, in a specific setting relevant to our goals, a more flexible and in a certain sense universal (for our class of Turing machines) such G\"odel string $\mathcal{G}$.  Extending this construction to more general classes of Turing machines / formal systems would be very interesting, but at the moment it is not clear what that would entail.  

 To make this $\mathcal{G}$ exceptionally simple we will need to formulate some specific properties for our machines, which will require a bit of setup.  We denote by $\mathcal{T} _{\mathbb{Z}} \subset \mathcal{T} $ the subset of Turing machines of the type: \begin{equation*}
   X:  (S _{X}  \times \mathbb{N} \subset Strings \times \mathbb{N}) \to \mathbb{Z}.
\end{equation*}
In other words, the input set of $X \in \mathcal{T} _{\mathbb{Z}}$ is of the form
$S _{X}  \times \mathbb{N}$, for $S _{X} \subset Strings $, and the output set of $X$ is $\mathbb{Z}$.
% , having the form:  % \begin{equation} \label{eq:SX}
%    S _{X}  \times \mathbb{N} \subset Strings _{0},
% \end{equation}

Let $\mathcal{O} \subset  \mathcal{T} _{\mathbb{Z}} \times Strings$ 
consist of $(X, \Sigma) \in \mathcal{T} _{\mathbb{Z}} \times Strings   $ with $\Sigma \in S _{X} $, defined as above. And
set $$\mathcal{O}' := \mathcal{O} \times \mathbb{N} \subset \mathcal{T} _{\mathbb{Z}} \times Strings \times \mathbb{N}.
$$ 
 
Let 
$$D_1: \mathbb{Z} \sqcup \{\infty\}   \to \mathbb{Z}, 
$$ 
be a fixed Turing machine which satisfies 
\begin{align} \label{eq:decision} D_1 (x) & =x+1  \text{ if } x \in  \mathbb{Z} \subset \mathbb{Z} \sqcup \{\infty\}  \\
D_1 (\infty) & =1.
\end{align}
Here $\{\infty\}$ is the one point set containing the element $\infty$,  which is just a particular distinguished symbol, also implicitly encoded as an element of $Strings$, s.t. $\{\infty\} \cap \mathbb{Z} = \emptyset$, where the intersection is taken in $Strings$. In what follows we sometimes understand $D_1 $ as an element of $\mathcal{T} _{\mathbb{Z}}  $, denoting the Turing machine: 
\begin{equation} \label{eq:D1m}
(x,m ) \mapsto D_1 (x), 
\end{equation}
 for all $(x,m) \in (\mathbb{Z} \sqcup \{\infty\}) \times \mathbb{N}$.


We need one more Turing machine.  
\begin{definition}
We say that a Turing machine 
\begin{equation*}
   R: D \supset \mathcal{O}'    \to  \mathbb{Z} \sqcup \{\infty\}, 
\end{equation*}
has 
\textbf{\emph{property $G$}} if the following is satisfied:
\begin{itemize}
   \item  $R$ halts on the entire $\mathcal{O}' $, that is $\mathcal{O}'$ is contained in the set of $R$-acceptable strings.
   \item  $R (X, \Sigma,m) \neq \infty \implies R (X,\Sigma,m) = X (\Sigma,m )$, for $(\Sigma,m) \in S _{X}  \times \mathbb{N} $, and $X \in \mathcal{T} _{\mathbb{Z}} $.
\item   
$\forall m: R (D_1, \infty, m)  \neq \infty,$
and so $\forall m: R (D_1, \infty,m) = 1$, by the previous property.
\end{itemize}
\end{definition}
%
%
% $R _{\mathcal{C}} (X, \Sigma ^{1}, m) $ signifies what $S$ obtains as a result of waiting on $*X (\Sigma ^{1},m )$ to halt on $\mathcal{C}$, if this is the computation he ran.  
% We set $$R _{\mathcal{C}} (X, \Sigma ^{1}, m) = \infty$$  if $*X (\Sigma ^{1},m )$ does not halt in time $t ^{W}$, and $$R _{\mathcal{C}} (X, \Sigma ^{1}, m) = X (\Sigma ^{1},m )$$ if it does.
%
% If $S  _{1,D} $ is as before, then we suppose that 
%   the printed string $A (T)$ satisfies
% \begin{equation} \label{eq:A}
%    {A} (T)=  (S  _{0,D} (T),  S   _{1,D}  (R _{\mathcal{C}} (D_0 (T))))
% \end{equation}
% so that ${A} \in \mathcal{M}_{0} $.
%
%    denotes the machine representing the final
%        ``decision map'' of $S$. Its input is meant to be what $S$ obtains from $R _{\mathcal{C}} $. \textcolor{blue}{big change to $D_1 $} 
% We suppose that this map  satisfies: 
% \begin{equation} S   _{1,D} ^{\mathbb{Z}}  (x)= x+1  \text{ if $x \in \mathbb{Z}$} 
% \end {equation}
% and
% \begin {equation}
% pr _{1} \circ S   _{1,D}  (x) = D_0 (T),
% \end{equation}
% for $pr _{1}: \mathcal{T} \times Strings \times \mathbb{Z} \to \mathcal{T} \times Strings  $ the projection.
% Therefore the above system $A$ and the protocol determine some machine satisfying:
%
%
% We may understand the ``wait operation'' by $S$ as a machine:
% $$W:  \mathcal{T} \times Strings \times \mathcal{I}     \to \{\infty \} \times \mathbb{N},$$ 
% or  $$W:  \mathcal{T} \times Strings \times \mathcal{I}     \to \{\infty \},$$ suppressing the $\mathbb{N}$ component. Here $\{\infty\}$ is the one point set as above, so that the first component of the output is only symbolic. What follows is a very elementary lemma.  
\begin{lemma} \label{lemma:computeWait} There is a Turing machine
$R$
satisfying property $G$. 
\end{lemma}
\begin{proof}
% Recall from Section \ref{sec:prelims} that when we write a Turing machine $T: I \to O$, the set $I$ is an abstract set (implicitly) encoded as a subset of $Strings$, consisting of all strings that are permitted by $T$, that is strings $\Sigma$ s.t. $*T (\Sigma) $ does not halt with final state $q _{reject} $. So long as $I \subset Strings$ is computable, that is its characteristic function is computable, to specify such a Turing machine it suffices to specify a Turing machine $T| _{I}$, with the latter meaning that the input strings to $T$ are restricted to be in $I$.
% We need to specify a Turing machine $R: Strings \to \mathbb{Z} \sqcup \{\infty\}$, and show that the set of $R$-permissible strings $D$ contains 
% $\mathcal{O}'$.
   % We this understanding we specify a Turing machine $R|_ {\mathcal{T} \times Strings}$ as follows. 
 Let $W _{n} $ be some Turing machine $W _{n} : \{\epsilon\} \to \{\infty\}$, for $\epsilon \in Strings$ the empty string. So as a function it is not very interesting since the input and output sets are singletons. We ask that the length of $*W _{n}  (\epsilon)$ is $n>0$, (cf. Preliminaries).  
Let $R _{n} $ be the Turing machine specified as:
  \begin{equation*}
   R _{n}  (Z):=   W _{n}   \star U (\epsilon, Z),
\end{equation*}
   in the language of the join operation described in Section \ref{sec:prelims}, for $Z \in Strings$, and for $U$ the universal Turing machine. Clearly $R _{n} $ always halts,  although it may halt with machine state $q _{reject} $. Moreover by construction every $Z = (X, \Sigma,m) \in \mathcal{O}' \subset Strings$ is permitted.
Additionally, for $ (X, \Sigma,m) \in \mathcal{O}'$, $$R _{n}  (X, \Sigma,m) \neq \infty \implies R _{n}  (X,\Sigma,m ) = X (\Sigma,m), $$ in particular every $(X,\Sigma, m) \in \mathcal{O}'$ is $R _{n} $-acceptable.  

   As a function $\mathbb{Z} \sqcup \{\infty\}   \to \mathbb{Z}$, $D _{1} $ is completely determined but it could have various implementations as a Turing machine,  so that the length $l _{m}  $  of $*D _{1} (\infty,m) $ depends on this implementation.
Clearly we may assume that $ \forall m: l=l _{m}   $ for some $l$, by definition of $D _{1} $ as an element of $\mathcal{T} _{\mathbb{Z}} $, as in \eqref{eq:D1m}.
   We  then ask that $n _{0}  > l$ is fixed. Then by construction we get: $$\forall m: R _{n _{0} } (D_1 , \infty,m)= D_1 (\infty,m)=1.  $$  So set $R:= R _{n _{0} }$, and this gives the desired Turing machine. 

   Note that the domain $D \subset \mathcal{T} \times Strings$ of $R$-permissible strings is not explicitly determined by our construction, as we cannot tell without additional information when a general $Z$ is rejected by $R$. We can only say that $D \supset \mathcal{O}'$. 
% Less formally $R$ is determined by the following properties.   % The first $p$ terms of the computation sequence $* R'  _{s} (Y, T) $ corresponds to the first $p$ terms of  $* W'     (Y, T)$. The following $q$ 
% terms of $* R'   _{s} (Y, T) $ correspond to the first $q$ terms of $* X    (\Sigma ^{1})$, followed by the next $p$ terms of  $* W'  (Y, T) $ and then terms $q+1$ to $2q$ of $* X  (\Sigma ^{1})$, and so on.
% The halting condition is either we reach a final state of $W'$ or a final state of $X $. If $* R'  _{s} (Y, T) $ halts with a final state of $X$ then $$R'   _{s} (Y, T) = X  (\Sigma ^{1} ), $$ otherwise if it halts with a final state of $W $ then  $$ R'  _{ s} (Y, T)= \infty.$$
% Thus, $R' _{s}$ computes $R _{ \mathcal{C}} $, moreover it is clear by construction that it strongly computes $R _{\mathcal{C}} $ on $C _{p+q} $.
\end{proof}
Define $\mathcal{M} _{0} $ to be the set of machines whose input set is $\mathcal{I}= \mathcal{T}  \times \mathbb{N}$ and whose output set is $Strings $. That is $$\mathcal{M} _{0} := \{M \in \mathcal{M}| M: \mathcal{T} \times \mathbb{N}  \to Strings \}.
$$ 
We set $$\mathcal{T} _{0}:= \{T \in \mathcal{T}| fog (T) \in \mathcal{M} _{0} \},
$$ and we set $\mathcal{I} _{0} := \mathcal{T} _{0} \times \mathbb{N}  $.  % \begin{definition} \label{def:totallycomputed} %    We say that  $M \in \mathcal{M} _{0} $ is \textbf{\emph{computed}} by a $M' \in \mathcal{T} _{0} $ if $D_0 $ is Turing computed by $D'_0 $ for $D_0, D'_0  $ the components of $M$ respectively $M'$ as above. Meaning that $$    M (T) = pr _{0} \circ D_0 (T)$$ and 
% $$M' (T) = pr _{0} \circ D'_0 (T).
% $$ 
% % We suppose that $S' _{1,D} $ is fixed once and for all elements of $\mathcal{T} _{0} $ since it computes a fixed elementary function, while the component machines $D'_0, R' $ may depend on $M'$. 
% %    if there are 
% % \begin{equation} \label{eq:A}
% %    M (\Sigma)=  S   _{1,D}  (R(S    _{0,D} (\Sigma), \Sigma), \Sigma),
% % \end{equation}
% %
% %
% %    \eqref{eq:A} is satisfied for every  $\Sigma \in \mathcal{T} _{st} $, and that  $W$ strongly computes the ``waiting operation'' of $S$ on $C _{1} $, as in the proof of Lemma \ref{lemma:computeWait}. 
%    % And consequently if $\mathcal{C}=C _{s} $ then $R _{\mathcal{C}} $ is strongly computed by $R' _{s} $ on $C _{s+1} $.
%    % And suppose further that $S  _{i,D}$ are strongly computed on $C _{1} $ by $S' _{i,D} $.   Then we say that the physical $S$ is \textbf{\emph{totally computable relative to $\mathcal{A}$}}.
% \end{definition}
Given $M \in \mathcal{M} _{0} $ and $M' \in \mathcal{T} _{0} $ let $\Theta _{M,M'} $ be the statement:
\begin{equation}
\begin{split} \label{eq:assertion1}
   &  \text {$M$ is computed by $M'$}.
   % \\ % &  \text{furthermore } S _{i,D}  \text{ are strongly computed }  \text{ on } C _{1}, 
   % \\
\end{split}   
 \end{equation}
% where $C _{1} $ is a specified digital computer.
% And additionally satisfying that:
% \begin{equation} \label{eq:permissible1}
% \forall (B,m)  \in \mathcal{I} \quad M ^{Strings}  (B,m) \in S _{M ^{\mathcal{T} _{\mathbb{Z}} } (B,m) },
% \end{equation}
% for $M ^{Strings}$, $M ^{\mathcal{T} _{\mathbb{Z}} } $ the $Strings$ and $\mathcal{T} ^{\mathbb{Z}}    $ components of $M$.
% To write this another way, this also means that:
% \begin{equation} \label{eq:permissible}
%    \forall (B,m) \in \mathcal{I} \quad \{M (B,m)\} \times \mathbb{N} \subset I' _{0} \times \mathbb{N} \subset (\mathcal{T} _{\mathbb{Z}} \times  Strings) \times \mathbb{N},
% \end{equation}
For each $M \in \mathcal{M} _{0}$, we define a machine: 
$$\widetilde{M}: \mathcal{I} \to Strings \times \mathbb{N}  $$ 
\begin{equation} \label{eq:S0D1}
\widetilde{M}   (B,m) = (M (B,m),m),
\end{equation}
which is naturally a Turing machine when $M$ is a Turing machine.

In what follows, when we write $T (T, m)$, we mean $T (\Sigma _{T},m )$ for $\Sigma _{T} $ the string encoding of the specification of the Turing machine $T$. So we conflate the notation for the Turing machine and its string specification, i.e. program.
\begin{definition} \label{def:propertyO} For $M \in \mathcal{M} _{0} $, $T \in \mathcal{T} _{0} $,  an abstract string $O \in Strings$  is said to have \textbf{\emph{property $C=C (M,T)$}} if: \begin{align*} & \Theta _{M,T} \implies \forall m: (*T(T,m) \text{ does not halt} )  \lor (T (T,m) \notin \mathcal{O}) \\  & \lor ( T (T,m) \in \mathcal{O},O \in \mathcal{O} \text{ and } X(\Sigma,m) = D_1 \circ R \circ  \widetilde{T} (T, m)),
\end{align*}
where $(X, \Sigma)=O$
and where $\widetilde{T}$ is determined by $T$ as in \eqref{eq:S0D1}. 
\end {definition} 

   At a glance, this is a somewhat complicated property,  but essentially it just says that if $\Theta _{M,T} $ then for all $m$  ``$O \neq T (T, m)$'' unless either $*  T (T,m)$ does not halt, or the output does not have the right (data) type, or $R (O,m) = \infty$.  Thus the string $O$ with property $C (M,T)$ is ``diagonal'' in a certain sense, where  by ``diagonal'' we mean that something analogous to Cantor's diagonalization is happening, but we will not elaborate. 
   \begin{remark}
   The fact that data types get intricated is perhaps not surprising. On one hand there is a well known correspondence, the Curry-Howard correspondence \cite{citeCurry}, between proof theory in logic and type theory in computer science, and on the other hand we are doing something at least loosely related to G\"odel incompleteness, but in the language of Turing machines.
\end{remark}
\begin{definition} \label{def:Psound}
   We say that $M \in \mathcal{M} _{0} $ is \textbf{\emph{$C$-sound}}, or 
is a \textbf{\emph{diagonalization machine}}, if for each $(T,m) \in \mathcal{I} _{0} $, with $M (T,m) = O$  defined,  $O$ has property $C (M,T)$.  We say that $M$ is $C$-sound on $T$ if the list $\{M (T,m)\} _{m} $ has only elements with property $C (M,T)$. 
% A string $$(X, \Sigma _{1}, n) \in \mathcal{T} _{1} \times Strings \times \mathbb{Z} $$ is defined to have property $O (M,M')$, if $ (X, \Sigma _{1})$ has property $O (M,M')$ and $n= D_1 \circ R(X, \Sigma _{1}) $.
 % In this case we also say that $M (T)$ has property $O$.  %          We also say in this case that $D_0 (T) $ has property $O$, so that $M (T)$ has property $O$ iff $pr _{1} (M (T)) $ has property $O$ for 
%         $pr _{1}:  \mathcal{T} \times Strings \times \mathbb{Z} \to \mathcal{T} \times Strings$ the projection map.
 \end{definition}



Define a $C$-sound $T \in \mathcal{T} _{0} $ analogously. 
\begin{definition}
 If $M$ as above is $C$-sound we will say that $sound (M)$ holds. If $M$ is $C$-sound on $T$ we say that $sound (M,T)$ holds.
\end{definition}
 \begin{example} \label{example:trivial}
A trivially $C$-sound machine $M$ is one for which $$M (T,m) =  (D_1 \circ R \circ  \widetilde{T}, T) $$ for every $(T,m) \in \mathcal{I} $. 
As $(D_1 \circ R \circ  \widetilde{T}, T) $ automatically has property $C (M,T)$ 
% \begin{equation*}
% \forall m:  \left((X(\Sigma,m) = D_1 \circ R \circ  \widetilde{M}' (M', m))   \lor ( *M'(M',m) \text{ does not halt} ) \lor (M' (M',m) \notin \mathcal{O}) \right),
% \end{equation*}
for each $T \in \mathcal{T}_{0} $.
In general, for any $M \in \mathcal{M} _{0} $, $T \in \mathcal{T} _{0} $ the list of all strings $O$ with property $C (M,T)$ is always infinite, as by this example there is at least one such string $(D_1 \circ R \circ  \widetilde{T}, T)$, which can then be modified to produce infinitely many such strings. 
 \end{example}      
 % \begin{lemma} If $M$ $C$-sound then it has property $P$ for some $M' \in \mathcal{I} _{0} $ only if it is not totally computable.
% \end{lemma}
% \begin{proof} Suppose otherwise that $M$ has property $P$ for some $M'$, then $R' (D'_0, M') = x \in \mathbb{Z}$ for $D'_0 $ the component machine.
% So we get:
% $$x = M' ^{\mathbb{Z}} (M') = (S' _{1,D}) ^{\mathbb{Z}} (x) = x+1 $$ with first equality $M$ by being $C$-sound and second by \eqref{eq:decision}, so we would get a contradiction.
%    
% \end{proof}
    \begin{theorem} \label{thm:diagonalization} Given any $M \in \mathcal{M} _{0} $, if  $sound (M,M') \land \Theta _{M,M'} $ for some $M' \in \mathcal{T} _{0} $ then 
   $$\forall m:  M (M',m) \neq \mathcal{G}, $$   
where $\mathcal{G}:= (D_1,\infty).$
On the other hand:
\begin{equation*}
\forall T \in \mathcal{T} _{0}: sound (T,T) \implies \text{$\mathcal{G}$ has property $C (T,T)$}.
\end{equation*}
In particular if $sound (M)$ then $\mathcal{G}$ has property $C (M,T)$ for all $T \in \mathcal{T} _{0} $.
% So that $$\mathcal{G} (M')=(S' _{1,D}, \infty, D_1 \circ R'(D'_0(M')))$$ has property $O$.
\end{theorem}
In the second half of the above theorem we may treat an element $T \in \mathcal{T} _{0} $ as an element of $\mathcal{M} _{0} $ via the map $fog$. So given any $C$-sound $M \in \mathcal{M} _{0} $ there is a certain string $\mathcal{G}$ with property $C (M,T)$ for all $T \in \mathcal{T} _{0} $, such that for each $M' \in \mathcal{T} _{0} $ if $\Theta _{M,M'} $ then $$\mathcal{G}  \neq M (M',m),$$ for all $m$.  This ``G\"odel string'' $\mathcal{G} $  is what we are going to use further on. What makes $\mathcal{G}$ particularly suitable for our application is that it is independent of the particulars of $M$, all that is needed is $\mathcal{M} \in \mathcal{M} _{0} $ and is $C$-sound. So $\mathcal{G}$ is in a sense universal.  % \begin{question}
%    It would be interesting to understand what is the analogue of such universal G\"odel strings for formal systems in logic. In other words is there a notion of universal G\"odel statements? This would have to do with certain collections of formal systems with a certain property, (perhaps generalizing our $C$-sound property).
% \end{question}
   
\begin{proof} Suppose not and let $M' _{0} $ be such that
$\Theta _{M,M' _{0} } \land sound (M,M' _{0} )$ and such that
\begin{equation*} 
M (M' _{0},m _{0} ) = \mathcal{G}  \text{ for some $m _{0}$},
\end{equation*}
so that $\mathcal{G}$ has property $C (M,M' _{0})$.
Set $I _{0}:= (M' _{0} ,m _{0} )$ then we have that:
   % . Since $sound (M,M' _{0} )$, since $\Theta _{M,M' _{0} } $, and since $*M' _{0} (T) \to \mathcal{G} \in \mathcal{O} $ since $M (T) = \mathcal{G} $ is defined, 
\begin{align*} 
      & 1= D_1 (\infty, m _{0} ), \\
      &  D_1 (\infty, m _{0}) = D_1 \circ R \circ  \widetilde{M}'(I _{0} ),  \text{ by $\mathcal{G}$ having property $C (M,M')$} , \text{ and by } *M'  (I _{0} ) \to \mathcal{G} \in \mathcal{O} \text{ since $\Theta _{M,M'} $},  \\
 &  D_1 \circ R \circ  \widetilde{M}'  (I _{0}) = D_1 \circ R (D_1, \infty, m _{0} )   \quad \text{ by $M' (I _{0} ) = \mathcal{G}$}, \\
 &  D_1 \circ R (D_1, \infty, m _{0} )=2 \quad \text{ by property $G$ of $R$ and by \eqref{eq:decision}}, \\
& 1=2.
\end{align*}
So we obtain a contradiction.
%
%
% Then after denoting by $M ^{\mathbb{Z}}, (M') ^{\mathbb{Z}}   $ the $\mathbb{Z}$ components we have:  
%    \begin{equation}
% \begin{split}
%    S' _{1,D} (\infty) = & 1= (M' _{0}) ^{\mathbb{Z}}     (T) \text{ since $\Theta _{M,M'}$ }   \\
%    &  = S' _{1,D}(R' (S' _{1,D}, \infty))  \text{ by \eqref{eq:Amachine}  and \eqref{eq:GS}} \\
%    &  = S' _{1,D}(S' _{1,D} (\infty)) \quad  \text{ by property $G$}\\
%    &  = 1+1 \quad \text{ by \eqref{eq:decision}}. \\
% \end{split}
% \end{equation}
% So we obtain a contradiction.
%

We now verify the second part of the theorem. 
We show that: 
\begin{equation} \label{eq:SecondPart2}
      \forall m, \forall T \in \mathcal{T} _{0}:  \left(sound (T,T) \land (T(T,m) \in \mathcal{O}) \implies R (\widetilde{T}(T,m)) = \infty \right).
\end{equation}
Suppose otherwise that for some $m _{0},T _{0}  $ and $I _{0}:= (T _{0} , m _{0}) $ we have: 
\begin{equation*}    sound (T _{0}, T _{0} ) \land (* T _{0} (I _{0}) \text{ halts}) \land (T _{0} (I _{0} ) \in \mathcal{O}) \land (R (\widetilde{T} _{0}   (I _{0} )) \neq \infty).
\end{equation*}
So we have:
\begin{equation} \label{eq:datatype1}
   *T_{0} (I _{0} ) \to (X, \Sigma ) \in \mathcal{O},
\end{equation}
 for some $(X, \Sigma )$ having property $C (T _{0},T _{0} )$, by $sound (T _{0}, T _{0}  )$.
And so, since $R$ is defined on all of $\mathcal{O}'$: $$R (\widetilde{T} _{0}  (I _{0} )) = R (X, \Sigma, m _{0}) =  X (\Sigma,m _{0}  ) =x \in \mathbb{Z}, \text{ for some $x$}, 
$$ 
   by Property $G$ of $R$ and by $R (\widetilde{T} _{0}  (I _{0} )) \neq \infty$.

   Then we get: $$x = X (\Sigma,m _{0}) =  D_1 \circ R \circ \widetilde{T} _{0}  (I _{0} ) = D _{1} (x) =  x+1 $$  by $(X, \Sigma)$ having property $C (T _{0}, T _{0} )$, and by \eqref{eq:datatype1}. So we get a contradiction and \eqref{eq:SecondPart2} follows.
Our conclusion readily follows. 

   The last part of the theorem follows by 
logic, for we have: 
\begin{equation*}
\forall T \in \mathcal{T} _{0}: sound (T,T) \implies \text{$\mathcal{G}$ has property $C (T,T)$}.
\end{equation*}
Also $$\forall T: \Theta _{M,T} \land sound (M) \implies sound (T,T),$$ 
therefore
   $$\forall T: sound (M) \implies (\Theta _{M,T} \implies \mathcal{G} \text{ has property $C (T,T)$}).
   $$ 
Which is the same as:
$$\forall T: sound (M) \implies \mathcal{G} \text{ has property $C (M,T)$},
   $$
by the definition of property $C (M,T)$.
% In particular if $sound (M)$ then $\mathcal{G}$ has property $C (M,T)$ for all $T \in \mathcal{T} _{0} $.

\end{proof}

% Formally $*$ is characterized by a pair of a Turing machine  and input  to this Turing machine.   This is again a string which we denote by  $D_0 (\Sigma) $, as it functionally depends on $\Sigma$.
% \item The if $D'_0  $ denotes 
%           the component of $A' $ which computes the operator $D_0 $, and you can show that the statement: \begin{equation*}
%       *D'_0 (\Sigma) \text{ is equivalent to } *A' (\Sigma)
%       \end{equation*} 
%       does not hold conditionally on $\Theta _{\Sigma} $, you will also be freed. We will explain $D_0,  D'_0  $ in more detail further on. At the moment this last condition will not play a role.
% \subsection{A system with a human subject $S$ as a machine in $\mathcal{M} _{0}$}
% \label{section:AsystemWithS}
% Let $S$ be a human subject, in a controlled environment, in communication with an experimenter/operator $E$ that as input passes to $S$ elements of $\mathcal{I} = \mathcal{T} \times \mathbb{N}$. Here \textbf{\emph{controlled environment}} means primarily that no information i.e. stimulus,
% % =======
% %       does not hold conditionally on $\Theta _{\Sigma} $, you will also be freed. We will explain $S _{0,D},  S' _{0,D}  $ in more detail further on. At the moment this last condition will not play a role.
% that is not explicitly controlled by $E$ and that is usable by $S$, passes to $S$ while he is in this environment. This condition is only for simplicity, 
% so long as we know in principle, or can compute in principle, what ``input'' our $S$ receives, it doesn't matter what kind of environment he is in.
% For practical purposes $S$ has in his environment a general purpose digital computer with arbitrarily, as necessary, expendable memory, (in other words a universal Turing machine). 
%
% We suppose that upon receiving any ${I} \in \mathcal{I} $, as a string in his computer, after possibly using his computer in some way,  $S$ instructs his computer to print after some indeterminate time a string $S (I)$.
% We are not actually assuming that $S (I)$ is defined on every $I$. So $S$ in our language also denotes a machine: 
% \begin{equation*}
%    S: \mathcal{I} \to Strings,
% \end{equation*} 
% which we suppose satisfies the condition that for any fixed $T \in \mathcal{T} _{0}   $ $$\{S  (T,m)\} _{m} $$ is the complete list of strings $O$, such that the physical $S$ asserts:
% \begin{equation*}
%    \Theta _{S,T} \implies O \text{ has property $C (T,T)$}.
% \end{equation*}
% In other words this is the list of strings that the physical $S$ asserts to have property $C (S,T)$. (While being a part of the system above.) 
% The reader may worry that the above is characterization of $S$ is self-referential. In Section \ref{section:systemMpm} we show how to fix this. For now, since this discussion is preliminary, we ignore the issue.
% \begin{remark} \label{remark:simplification} The above is partially a simplification, because for a real world $S$ it may be that each $S (T,m)$ must be understood as a probability distribution on $Strings$. In other words the value $S (T,m)$ is only determined up to some dice roll, which we may expect if quantum mechanics plays a significant role. This extra complexity will be ignored,  as it does not meaningfully change any of our arguments, since dice rolls can be simulated completely with Turing machines.
% \end{remark}
%
% % , we only need that $S $ can list as many strings as we like, and that given any particular $T$, eventually any particular string that $S _{0} $ asserts to have property $C (S _{0}, T )$ will appear.  
% %    \item $S$ then waits for a fixed time $$t ^{W} >0 $$ for $*$ to halt.
% % \item $S$ receives the output of $*$, or he does not if the halt time of $*$ is more then $t ^{W} $.
% % \item Based on what he has obtained $S$ then decides on his printed answer to $E$, which is unambiguously interpreted as an element of $\mathcal{T} _{1}  \times Strings \times \mathbb{Z}$.
% % \end{itemize}
% %  , and then, whether $*$ halts or not, All of these operations: ``waiting'', ``deciding'' are to be strongly computable if $S$ is totally computable in the informal sense discussed. 
% % We now further formalize this.   
% % Define $\mathcal{T}$ to be the set of Turing machines with permissible input some subset of $Strings$ and output in $\mathbb{Z}$. 
% % We likewise understand $\mathcal{T}$ as a subset of ${Strings}  $ with respect to a particular chosen encoding, but then forget this.  
% % <<<<<<< HEAD
% % We further ask that the initial ``decision map'' of $S$ determines a machine:
% %   $$D_0: \mathcal{I}  \to  {\mathcal{T}} _{1}  \times {Strings} _{0}, $$ 
% % satisfying \eqref{eq:}.
% % % The output $S   _{0,D} (T)$ is a tuple $(X, \Sigma ^{1},m  )$ of a Turing machine $X $ and input $(\Sigma ^{1},m) $ to this Turing machine. 
% % If $D_0 (B,m) = (X, \Sigma ^{1},m ) $ then the computation $*X  (\Sigma ^{1},m) $ is what $S$ decides to run on $\mathcal{C}$ given $(B,m)$.
% % In a more basic language,  we may say that $S   _{0,D} (B,m)$ is a pair of a computer program and input for this program that $S$ will run on $\mathcal{C} $.  
% % Of course $D_1, R _{\mathcal{C}}  $ are Turing computable.
% \begin{definition} We say that $S$ the human subject  is \textbf{\emph{computable}} if the corresponding machine $S$ above is computable.
% \end{definition}
% \subsubsection*{Penrose property}
% % Let $S $ be a subject as above, which additionally satisfies what we call the \emph{Penrose property}.
% % In this case given any input $T = (B,m)$, given the chosen computation $D_0 (T) = (X, \Sigma _{1} ) $ and given the wait time $t ^{W} >0 $,  if the computation $* X (\Sigma _{1} )$ does not halt in time $t ^W $ he prints $(X, \Sigma _{1}, 1)$ in any time less then $t ^{W}  $. More specifically,
% % the time to answer of $D_1 (\infty) $ is less than $t ^{W} $.  
% By the above conditions $S$ must also assert the statement $$\forall T \in \mathcal{T} _{0}: \Theta _{S,T} \implies sound (T)$$ for $S$ the above machine. And we ask that $S$ is aware of Theorem \ref{thm:diagonalization}, so that as a consequence $S$ asserts that 
% \begin{equation*}
%    \forall T \in \mathcal{T} _{0}: \Theta _{S,T} \implies \mathcal{G} \text{ has property $C (T,T)$},
% \end{equation*}
% which is the same as 
% \begin{equation*}
%    \forall T \in \mathcal{T} _{0}: \mathcal{G} \text{ has property $C (S,T)$},
% \end{equation*}
% by the definition of property $C (S,T)$. Again by our condition on $S$, we may state this more concretely as: 
% \begin{equation*}
%    \forall T \in \mathcal{T} _{0}: \mathcal{G}= S (T,m) \text{ for some $m$}.
% \end{equation*}
% % \begin{remark}  Although $S$ is not given a definition, it can be in principle defined in set theory once one knows everything there is to know about the physics and biology underlying the physical $S$. (And assuming set theory is enough to formalize everything.) In other words assuming the universe is deterministic, $S$ is determined by some rule, which we assume can be formalized in set theory.  
% % \end{remark}
% \begin{theorem} 
% %  Let ${S} _{0} $ be the machine described above,  then 
% \begin{equation*}
% S  \text{ is computable } \implies \neg sound (S  ). 
% \end{equation*}
% In fact we prove more, for any $T \in \mathcal{T} _{0} $:
% \begin{equation*}
%    \Theta _{S, T} \implies   \neg sound (S,T) .
% \end{equation*}
% \end{theorem} 
%  This partly formalizes Theorem \ref{thm:1}, to completely formalize it we must wait till the following sections.
% \begin{proof}
% Suppose $\Theta _{S, S'}$ for some $S' \in \mathcal{T} _{0} $.
% Suppose in addition $sound (S,S' )$.  Then  by Theorem \ref{thm:diagonalization} $$S   (S',m) \neq \mathcal{G} $$ for any $m$, which contradicts the Penrose property above.  %
% % On the other hand $S  $ asserts  $sound (S  )$ and hence must assert that  $\mathcal{G}$ has property $C (S, S' )$, 
% % by the second half of Theorem \ref{thm:diagonalization}.
% % In particular $\mathcal{G}$ must be in the list $\{S  ({S'},m) \} _{m} $, since this list is assumed to be complete. So we have reached a contradiction.
% \end {proof}
%
\section {Fundamental soundness as stable soundness} \label{section:fundamentalSoundness}
Imagine a machine $P$ which sequentially prints statements of arithmetic, which it asserts are true, but so that $P$ can also delete a printed statement, if $P$ decided the statement to be untrue. We say that $P$ is stably sound if any printed statement by $P$ that is never deleted is in fact true.  More formally, for each $n \in \mathbb{N}$ $P (n)$ will correspond to an operation denoted by the string $(\Sigma,+)$ or $(\Sigma,-)$, meaning add $\Sigma$ to the list or remove $\Sigma$ from list, respectively, where $\Sigma$ is a statement of arithmetic. 
So we have a machine:
\begin{equation*}
P: \mathbb{N} \to Strings \times \{\pm\}.
\end{equation*}

If there is an $n  _{0} $  with $P (n _{0} ) = (\Sigma  ,+ )$ s.t. there is no $m>n _{0} $ with $P (m) = (\Sigma, -)$ then $\Sigma $ is called \textbf{\emph{$P$-stable}}  and we say that $P$ \textbf{\emph{prints $\Sigma$ stably}}. 
\begin{definition}
 We say that $P$ is \textbf{\emph{stably sound}}  if every  $P$-stable $\Sigma$ is true.
  \end{definition}
\begin{definition}
   Given a stably sound $P$, we may construct from it a sound machine $P ^{s} $ simply by enumerating, in order, all the $P$-stable $\Sigma$. We call this the \textbf{\emph{stabilization}} of $P$. The range of $P ^{s} $ is called the \textbf{\emph{stable output}} of $P$.
\end{definition}
In general $P ^{s} $ may not be computable even if $P$ is computable. 
Explicit examples of this sort can be constructed by hand.
\begin{example} \label{remark:dio} We can construct a Turing machine $$A: \mathbb{N} \to Strings \times \{\pm\},$$ whose stabilization $A ^{s} $ enumerates every Diophantine equation with no integer solution, or every Turing machine which does not halt. These sets are well known to be not computably enumerable, \cite{TuringComputableNumbers}. To do this we may proceed via a zig-zag algorithm. 

In the case of Diophantine equations, here is a (inefficient) example.
Let $Z$ enumerate every polynomial with integer coefficients, and let $N$ enumerate the integers. 
\begin{itemize}
   \item Initialize an ordered list $L$  by $L=\emptyset,$
which we understand as a list of instructions. 
\item Start. For each $p \in \{Z (0), \ldots, Z (n)\}$ check if $\{N(0), \ldots, N(n)\}$ are solutions of $p$. Whenever no add $(p,+)$ to $L$, whenever yes add $(p,-)$. 
\item Set $n:=n+1$ go to Start and continue.
\end{itemize}
This will define a partial function $A: \mathbb{N} \to Strings$ whose value $A (m)$ is the $m$'th, not necessarily final, instruction in the list $L ^{m} $ which is $L$ after the $m$'th step of the algorithm. It's stabilization $A ^{s}$ enumerates polynomials which have no integer solutions.  \end{example} 
 We now translate the above to our setting. The crucial point of our G\"odel string is that it will still function in this stable soundness context.
Let $\mathcal{M} ^{\pm}  $ denote the set of machines
\begin{align*}
{M}: \mathcal{I} = \mathcal{T} \times \mathbb{N} \to Strings \times \{\pm\},
% \\ & \textbf{M} (T, k) = M _{k} (T), \text{for all $k \in \mathbb{N}$, and $T \in \mathcal{I}$}.
\end{align*}
where $\{\pm\}$ is the set containing two symbols $+,-$, likewise implicitly encoded as a subset of $Strings$.
We set $$\mathcal{T}  ^{\pm} := \{T \in \mathcal{T}| fog (T) \in \mathcal{M} ^{\pm} \}.
$$  
% Note that we are again implicitly encoding $Strings \times \{\pm\}$ as a subset of $Strings$.
\begin{definition} 
   For ${M} \in \mathcal{M} ^{\pm}  $ and for $ (T,m) \in \mathcal{I} $, we say that an abstract $O \in Strings$ is $(M,T)$-\textbf{\emph{stable}} and that \textbf{\emph{$M$ prints $O$ $T$-stably}} if there exists an $m \in \mathbb{N}$ s.t.  ${M} (T,m) = (O, +) $ and there is no $k>m$ s.t. $M (T,k) = (O,-)$.  When $T \in \mathcal{T} ^{\pm} $  and $fog (T)=M$ instead of writing $(M,T)$-stable we just write $T$-stable.
\end{definition}
% \begin{notation} In addition, we sometimes write $M$-stable instead $(M,B)$-stable. Since usually it is clear what $B$ is supposed to be. Likewise we may say that $M$ prints $O$ stably, instead of $B$-stably.
% \end{notation}
Let $$pr: Strings \times \{\pm\} \to  Strings,$$ be the natural projection.
For each $M \in \mathcal{M} ^{\pm} $, we define a machine: 
%
%
% $$\underline{M}: \mathcal{I} \to \mathcal{T} _{Z} \times Strings    $$ 
% $\underline {M} (B, m) \pr _{\mathcal{T} _{Z} \times Strings} \circ   $
$$\widetilde{M}: \mathcal{I} \to Strings \times \mathbb{N},    $$ 
\begin{equation} \label{eq:S0D}
   \widetilde{M}   (T,m) = (pr \circ M (T,m),m),
\end{equation}
which is naturally a Turing machine when $M$ is a Turing machine. 

\begin{definition} Given a partial function $M: Strings \to Strings \times \{\pm\}  $ and a Turing machine $T: Strings \to Strings \times \{\pm\}$, we say that $T$ \textbf{\emph{stably computes}} $M$ if $M ^{s} =T ^{s} $ for $T ^{s} $ the stabilization of the partial function $fog (T)$.
\end{definition}
We write $\Theta _{M,T} ^{s}  $ for the statement $T$ stably computes $M$.
In what follows $\mathcal{O} \subset \mathcal{T} _{\mathbb{Z}} \times Strings $ is as before.
\begin{definition} \label{def:SpropertyO} 
For ${M} \in \mathcal{M} ^{\pm} $, ${M}' \in \mathcal{T} ^{\pm}  $,  an abstract string $O \in Strings$  is said to have property \textbf{\emph{ $sC=sC ({M}, {M}')$}} if:
\begin{align*}
   & \Theta ^{s}  _{M,M'} \implies \forall m: (*M'(M',m) \text{ does not halt} )  \lor (pr \circ M' (M',m) \notin \mathcal{O}) \lor (pr \circ M' (M',m) \text{ is not $M'$-stable}) \\  & \lor (pr \circ M' (M',m) \in \mathcal{O}, O \in \mathcal{O} \text{ and } X(\Sigma,m) = D_1 \circ R \circ  \widetilde{M}' (M', m), \text{ where $(X, \Sigma)=O$})),
\end{align*}
for $\widetilde{M}'  $ determined by $M'$ as in \eqref{eq:S0D}. 
% We say that $O$ has property $N-sC (M,M')$ if the above holds for all $m \leq N$.
\end {definition}
\begin{definition} \label{def:SPsound}
   We say that ${M} \in \mathcal{M} ^{\pm}  $ is \textbf{\emph{stably $C$-sound}} on ${M}'$, and we write that $s-sound ({M}, {M}')$ holds, if every  $(M,M')$-stable $O$ has property $sC ({M}, {M}')$. We say that ${M}$ is \textbf{\emph{stably $C$-sound}} if it is stably $C$-sound on all ${M}'$, and in this case we write that $s-sound ({M})$ holds.
% A string $$(X, \Sigma _{1}, n) \in \mathcal{T} _{1} \times Strings \times \mathbb{Z} $$ is defined to have property $O (M,M')$, if $ (X, \Sigma _{1})$ has property $O (M,M')$ and $n= D_1 \circ R(X, \Sigma _{1}) $.
 % In this case we also say that $M (T)$ has property $O$.  %          We also say in this case that $D_0 (T) $ has property $O$, so that $M (T)$ has property $O$ iff $pr _{1} (M (T)) $ has property $O$ for 
%         $pr _{1}:  \mathcal{T} \times Strings \times \mathbb{Z} \to \mathcal{T} \times Strings$ the projection map.
 \end{definition}
\begin{example} \label{example:strivial}
  As before an example of a trivially stably $C$-sound machine $M$ is one for which $$M (T,m) =  (D_1 \circ R \circ  \widetilde{T}, T,+) $$ for every $(T,m) \in \mathcal{I} $. 
\end {example}
\begin{theorem} \label{thm:stablediagonalization} For all $M \in \mathcal{M} ^{\pm} $:
\begin{equation*}
   (\exists M' \in \mathcal{T} ^{\pm}: s-sound ({M}, {M}') \land \Theta ^{s}  _{{M}, {M}'}) \implies ((\text{$O$ is $(M,M')$-stable}) \implies O \neq \mathcal{G})
\end{equation*}
where $$\mathcal{G}:=(D_1, \infty) \in \mathcal{O}.$$
On the other hand, 
\begin{equation} 
\forall T \in \mathcal{T} ^{\pm}: s-sound (T, T)  \implies \text{$\mathcal{G}$ has property $sC (T,T)$}.
\end{equation}
%  In particular if $s-sound ({M})$ then $\mathcal{G}$ has property $sC ({M},T)$ for all $T$.
% So that $$\mathcal{G} (M')=(S' _{1,D}, \infty, D_1 \circ R'(D'_0(M')))$$ has property $O$.
\end{theorem}
\begin{proof}  This is mostly analogous to the proof of Theorem \ref{thm:diagonalization}. Suppose not, let $M$ be fixed and let ${M}' _{0} $ be such that $s-sound ({M},{M}' _{0} ) \land \Theta ^{s}  _{{M}, {M}' _{0} }$ and such that for some $m _{0} $:
\begin{equation*} 
   M ({M}' _{0} ,m _{0} ) = (\mathcal{G}, +)  \text{ so that $\nexists n > m _{0}: $  } M ({M}' _{0},n ) = (\mathcal{G}, -).
\end{equation*}
In particular  $\mathcal{G}$ has property $sC (M,M' _{0} )$ by $s-sound (M,M' _{0} )$.

By $\Theta ^{s}  _{M,M' _{0} } $ there exists $m' _{0} >0 $ such that $*M' _{0}   (M' _{0}, m' _{0}  ) \to (\mathcal{G},+)$. If we set $I _{0}: = ({M}' _{0}, m' _{0})$, then by  $\mathcal{G}$ having property $sC (M,M' _{0} )$, by $\mathcal{G} \in \mathcal{O}$ and by $\mathcal{G}$ being $M' _{0} $-stable as $\mathcal{G}$ is $(M,M' _{0} )$-stable:
\begin {equation} \label{eq:basic}
   D_1 (\infty, m _{0}) = D_1 \circ R \circ  \widetilde{M}' _{0} (I _{0} ).
\end{equation}
On the other hand:
\begin{align} 
      &  D_1 \circ R \circ  \widetilde{M}' _{0}   (I _{0} ) = D_1 \circ R (D_1, \infty, m _{0} )   \quad \text{ by $M' _{0}  (I _{0} ) = (\mathcal{G},+)$}, \\
 &  D_1 \circ R (D_1, \infty, m _{0} )=2 \quad \text{ by property $G$ of $R$ and by \eqref{eq:decision}}, \label{eq:MS} \\
& D_1 (\infty, m _{0} ) =1, \\ 
& 1=2, \text{by \eqref{eq:basic} and by \eqref{eq:MS}.
   }
\end{align}
 So we obtain a contradiction.
%
%
% Then after denoting by $M ^{\mathbb{Z}}, (M') ^{\mathbb{Z}}   $ the $\mathbb{Z}$ components we have:  
%    \begin{equation}
% \begin{split}
%    S' _{1,D} (\infty) = & 1= (M' _{0}) ^{\mathbb{Z}}     (T) \text{ since $\Theta _{M,M'}$ }   \\
%    &  = S' _{1,D}(R' (S' _{1,D}, \infty))  \text{ by \eqref{eq:Amachine}  and \eqref{eq:GS}} \\
%    &  = S' _{1,D}(S' _{1,D} (\infty)) \quad  \text{ by property $G$}\\
%    &  = 1+1 \quad \text{ by \eqref{eq:decision}}. \\
% \end{split}
% \end{equation}
% So we obtain a contradiction.
%

We now verify the second part of the theorem. 
Given any $T \in \mathcal{T} ^{\pm}  $, for any $m \in \mathbb{N}$, setting $I:= (T,m)$ we show that: 
   \begin{equation} \label{eq:SecondPart}
   s-sound (T,T) \land (pr \circ T (I) \in \mathcal{O})  \land ( pr \circ \text{$T (I)$ is $T$-stable} )  \implies R (\widetilde {T}(I)) = \infty.  \end{equation}
Suppose otherwise that for some $T _{0}, m _{0} $ and $I _{0}:= (T _{0}, m _{0}) $ 
   we have: 
    \begin{multline*}   s-sound (T _{0} , T _{0} ) \land (* T _{0}  (I _{0}) \text{ halts}) \land  (pr \circ T _{0} (I _{0} ) \in \mathcal{O}) \land ( pr \circ \text{$T _{0}  (I _{0} )$ is $T _{0} $-stable} )  \\ \land (R (\widetilde{T} _{0}   (I _{0} )) \neq \infty).
    \end{multline*}
  Then by the above condition we get: 
   \begin{equation} \label{eq:datatype}
  *T _{0}  (I _{0} ) \to (O,+), \text{ or } *T _{0}  (I _{0} ) \to (O,-),
\end{equation}
   for some  $O = (X,\Sigma) \in \mathcal{O}$, which is $(T _{0}, T _{0} )$-stable and with property $sC (T _{0} , T_{0} )$, by $s-sound (T _{0},T_{0}  )$. We can of course guarantee that there is some $m _{0}'$ with $T _{0}  (T_{0} , m _{0}' ) = (O,+)$, but we arranged the details so that this is not necessary. 

   Since $R$ is defined on all of $\mathcal{O}'$ we get: $$R (\widetilde{T} _{0}   (I _{0} )) = R (O, m _{0}) =  X   (\Sigma, m _{0}  ) =x \in \mathbb{Z}, \text{ for some $x$},  $$ 
   by Property $G$ of $R$ and by $R (\widetilde{T} _{0}  (I _{0} )) \neq \infty$.
Then we have: $$
    x=X (\Sigma, m _{0}) =   D_1 \circ R \circ \widetilde{T} _{0}   (I _{0} )= D _{1} (x)= x+1,
   $$  
by $(X, \Sigma)$ having property $sC (T, T)$, and by \eqref{eq:datatype}.
% But then we get:
% $$
% x= X  (\Sigma _{1},m _{0} )  = D_1 \circ R \circ \widetilde{M}'    (T _{0} ) = D _{1} (x) =  x+1,
%    $$  
So we get a contradiction and \eqref{eq:SecondPart} follows.  Our conclusion readily follows.
% The last part of the theorem follows by logic as in the proof .
% So
% \begin{equation} \label{eq:SecondPart2}
%    sound (M) \land  \Theta _{M,M' }    \implies M' (M') = S' _{1,D} (\infty,M'),
% \end {equation}
%   from which the conclusion follows.
% % Then since $\halt M (T _{0} )$, and since $M$ has property $P$, we have 
% %   \begin{equation*}
% %   \neg (sound (T _{0} ) \land \Theta _{M,T _{0} }).
% % \end{equation*} 
% % But $T _{0} $ computes $M$ which is $C$-sound so $sound (T _{0} )$, and hence $\neg \Theta _{M, T _{0} } $ a contradiction.
\end{proof}

\section{Stably undecidable problems and application} \label{section:systemMpm}
Let $S$ be a human subject, in a controlled environment, in communication with an experimenter/operator $E$ that as input passes to $S$ elements of $\mathcal{I} = \mathcal{T} \times \mathbb{N}$. Here \textbf{\emph{controlled environment}} means primarily that no information i.e. stimulus,
% =======
%       does not hold conditionally on $\Theta _{\Sigma} $, you will also be freed. We will explain $S _{0,D},  S' _{0,D}  $ in more detail further on. At the moment this last condition will not play a role.
that is not explicitly controlled by $E$ and that is usable by $S$, passes to $S$ while he is in this environment. This condition is only for simplicity, 
so long as we know in principle, or can compute in principle, what ``input'' our $S$ receives, it doesn't matter what kind of environment he is in. For practical purposes $S$ has in his environment a general purpose digital computer with arbitrarily, as necessary, expendable memory, (in other words a universal Turing machine). 

We suppose that upon receiving any ${I} \in \mathcal{I} $, as a string in his computer, after possibly using his computer in some way,  $S$ instructs his computer to print after some indeterminate time a string $\widetilde{S}  (I)$.
We are not actually assuming that $\widetilde{S}  (I)$ is defined on every $I$.  

So $S$ is meant to determine an element of $ \mathcal{M} ^{\pm} $: 
\begin{equation} \label{eq:Smachine}
\widetilde{S}: \mathcal{I} \to Strings \times \{\pm\}. 
\end{equation}
\begin{remark} \label{remark:simplification} The above is partially a simplification, because for a real world $S$ it may be that each $\widetilde{S}  (T,m)$ must be understood as a probability distribution on $Strings \times \{\pm\}$. In other words the value $\widetilde{S}  (T,m)$ may only be determined up to some dice roll, which we may expect if quantum mechanics plays a significant role. This extra complexity will be ignored,  as it does not meaningfully change any of our arguments, since dice rolls can be simulated completely with Turing machines.  Moreover, we are only interested in stable output of $\widetilde{S} $ which, as we shall see from construction, should not be affected by any dice rolls.
\end{remark}
As $S$ and $\widetilde{S} $ now denote two things: the human subject and the corresponding machine, we will say \textbf{\emph{physical $S$}} when we want to clarify that we are talking of the actual  human.  In what follows when we say  ``stably assert'', we mean that our physical $S$ will not change his mind,  formalized analogously to our definition of stably sound machines. We may also just say \textbf{\emph{perceive}} instead of stably assert, these words being technically synonymous in the usage here. On the other hand ``assert'' by itself is used in the usual sense of mathematicians asserting their theorems, possibly unsoundly. We emphasize that although we talk of our $S$ as a physical subject doing things like perceiving or asserting, we are just talking of various machines associated to this subject, analogously to $\widetilde{S} $ above, and of the mathematical properties of these machines. It is cumbersome to always make this explicit, but implicitly we are always talking of set theoretic objects, in this section and elsewhere.
% Where for each $(T,m) \in \mathcal{I}$, $S (T,m)$ is a string that $S$ asserts to have property $sC (S,T)$, at 
% We would like to say that $S$ satisfies the condition that for any fixed ${T} \in \mathcal{T} ^{\pm} $  if $(O,+) \in \{S (T,m)\} _{m} $ then at some point the physical $S$ asserts that $O$ has property $sC (S,T)$,  while being part of the above environment.
% % for some 
% % then $$  S ({T},m)=(O, +)  $$ for some $m$, and that moreover $O$ is $(S,T)$-stable. 
% However, this condition is self referential, since the physical $S$ would claim a property on strings that $S$ prints, that refers to the machine $S$ itself.  So to be safe let us now rephrase this condition in a non self-referential manner. 
% We now elaborate on the above.
% % \begin{definition} Given a partial function $f: D \to R$, 
% % we say that $g: B \supset D   \to R$ \textbf{\emph{extends}} $f$ if $f (x)=g (x)  $ for all $x \in D$, so that $g (x)$ is undefined if $f (x)$ is.
% % \end{definition}
% % The point of the above is that we don't give new definitions for undefined values of $f$, this has logical content in the following.
% % \begin{definition} Given $T \in \mathcal{T} ^{\pm} $, an abstract partial function $M _{n}:  \{0, \ldots, n\} \to Strings \times \{\pm\}$, is said to have \textbf{\emph{property}} $sC (T)$ if: 
% % \begin{align*}
% %    O \in \{pr \circ M _{n} (m)| m \in \{0, \ldots, n\} \} \land (O \text{ is $M _{n} $-stable}) \\ \implies (\Theta _{M ^{ext},  T} \implies \text{$O$ has property $n-sC (T,T)$}),
% % \end{align*}
% % for any partial function $M ^{ext}: \mathbb{N} \to Strings \times \{\pm\} $, extending $M _{n} $.
% % \end{definition}
% % For each $T \in \mathcal{T} ^{\pm} $, a \textbf{\emph{coherent system of machines}} $\{M _{n} (T) \} _{n \in \mathbb{N}} $ 
% % is defined to be a sequence of partial functions: $$M _{n} (T):  \{0, \ldots, n\} \to Strings \times \{\pm\},$$ satisfying the \textbf{\emph{coherency}} condition that $$M _{m} (T)| _{\{0, \ldots, n\}} =M _{n} (T)   $$ for $m>n$.
% % Let $$M _{\infty} (T): \mathbb{N} \to Strings \times \{\pm\} $$ denote the limiting partial function.  
% % For each $(T,n) \in \mathcal{T} ^{\pm} \times \mathbb{N}$, we suppose that our physical $S$ prints a string $O={S}  _{n}  (T,n)$ (could be undefined), and asserts the following: let $$\widetilde{S}_{n}: \mathcal{T} ^{\pm} \times \{0, \ldots, n\} \to Strings \times \{\pm\}  $$ be the partial function $\widetilde{S} _{n}  (T,m) = {S}  _{m}  (T,m)  $, then 
% % there exists an abstract extension $$\widetilde{S}: \mathcal{T} ^{\pm} \times \mathbb{N}  \to Strings \times \{\pm\} $$  of $\widetilde{S} _{n}$ satisfying $s-sound (\widetilde{S},T)$.  Of course, by construction we have that $\widetilde{S} = \lim _{n \to \infty}  \widetilde{S}_{n} $.
% % And moreover $S$ asserts that if $$L _{n} (T): \mathbb{N} \to Strings \times \{\pm\}  $$ denotes the trivial extension of $S _{n}(T) $ so that $L _{n}  (T)(m)$ is undefined for $m>n$, then also $s-sound (L _{n},T)$.  As indicated the extension $\widetilde{S} $ is meant to be the same for all $n$, while $L _{n} (T) $ of course vary. 
% % :  $$\text{ if }  $O$ \text{ is stably $S _{n} (T)  $ printed}  $$ then given any abstract extension of $S _{n} (T) $ to a partial function
% % \begin{equation*}
% % S ^{ext} (T): \mathbb{N} \to Strings \times \{\pm\},
% % \end{equation*}
% % \begin{equation*}
% % \Theta _{S ^{ext},  T} \implies \text{$O$ has property $n-sC (T,T)$.
% % } \end{equation*}
% % for some $k$, then $S _{n+k} $ is defined to be $S _{n+k'} $ for any 
% % Let us call this property $sC (S _{n},T)$. 
% This property for each $(T,n)$  logically only depends on $\widetilde{S} _{n}$ and $T$, so there are no self referentiality issues. 
% On the other hand if the sequence $\{S _{n} (T) \} _{n} $ is unbounded in $n$, then we must have $\widetilde{S} (T) =S _{\infty} (T)  $.
%  \begin{remark}
% There may now be a worry that $\{S _{n} ({T})  \} _{T,n} $  could be an empty set, at least once only stably printed strings are taken. (Although this is technically a red herring.) This is not the case however: since for any $T$ we may start by $$S _{1} (T) (1) = (D_1 \circ R \circ  \widetilde{T}, T,+),  $$ and this can certainly be stably printed.
% % \end{remark}
% \begin{definition} For a machine $M$ given by a coherent system $\{M _{n}  (T) \} _{T,n} $ as above, we say that $strong-sound(M,T)$ holds if 
% $\{M (T) \} _{n} $ consists of elements with property $sC (T)$.
% \end{definition}
% This property is of course stronger then the old property $s-sound(M,T)$.
%  \begin{definition}
% Given $T \in \mathcal{T} ^{\pm} $ an abstract $O \in Strings$ \textbf{\emph{has property}} $sC (T)$, if the following holds.
%  For any $N >0$, and any $M _{N} $ that has property $sC (T)$, if 
%  $M _{N+1} $ is the partial function
%  \begin{equation*}
%      M _{N+1} : \{0, \ldots, N+1\} \to Strings \times \{\pm\}, \quad M _{N+1}(N+1)=(O,+),
%  \end{equation*}
%  extending $M _{N}$, then  $M _{N+1} $ has property $sC (T)$.
%  \end{definition}
% We now give an additional constraint on $\widetilde{S}$.

Let 
$$D _{S} : \mathcal{T} ^{\pm} \times \mathbb{N}  \to (\{\hbar\} \bigsqcup \mathcal{U}) \times \{\pm\},$$ denote the machine with the properties below,  for $\mathcal{U}$ an abstract set identified with $Strings$. We write $\mathcal{U}$ because otherwise the encoding $$(\{\hbar\} \bigsqcup Strings) \times \{\pm\} \to Strings$$ may create confusion. But further on general elements of $\mathcal{U}$ may be implicitly identified with general elements of $Strings$. We ask that the following holds.
\begin{itemize}
\item For each $T,n$ $D _{S} (T,n) = (O,+)$, with $O \in \mathcal{U}$, if $S$ asserts at moment $n$
that $O$ is $(T,T)$-stable.
  \item  For each $T,n$ $D _{S} (T,n) = (\hbar,+)$ if $S$ asserts at the moment $n$ that no $O$ is $(T,T)$-stable.   
 % \item  For each $T,n$, $D _{S} (T,n) = (\hbar,-)$ if $O$ asserts at the moment $n$ that some $O$ is $(T,T)$-stable.   
\item For each $T,n$ $D _{S} (T,n)$ is undefined if $S$ at the moment $n$ does not assert anything new.
\item    For each $T,n$ $D _{S} (T,n) = (\hbar,-)$ if $S$ no longer asserts at the moment $n$ that no $O$ is $(T,T)$-stable.   
\end{itemize} 
Let $\mathcal{D}$ denote the set of abstract machines of the form:
$$D: \mathcal{T} ^{\pm} \times \mathbb{N}  \to (\{\hbar\} \bigsqcup \mathcal{U}) \times \{\pm\}.
$$ 
\begin{definition} 
%    We say that $D \in \mathcal{D} $ is 
%    \textbf{\emph{stably consistent}} if
% for each $T$: the following are mutually exclusive: some $O \in Strings$ is $(D,T)$-stable,  $\hbar$ is $(D,T)$-stable. 
We say that $D$ is \textbf{\emph{stably sound}} if for each $T$:
\begin{align*}
& \hbar \text{ is $(D,T)$-stable }  \implies \text{no $O$ is $(T,T)$-stable} \\
& O \in \mathcal{U} \text{ is $(D,T)$-stable } \implies \text{$O$ is $(T,T)$-stable}. 
\end{align*}

We say that $D$ \textbf{\emph{stably decides $\mathcal{P} (T)$}}  if the partial function $D(T) $ has non-empty stable output. We say that $D$ \textbf{\emph{stably soundly decides $\mathcal{P} (T)$}}  if $D$ is stably sound on $T$ and stably decides $\mathcal{P} (T)$. 
\end{definition}
% \begin{definition} 
% Given $T \in \mathcal{T} ^{\pm} $, we say that the physical $S$ can 
% We say that $G (S)$ holds if $\forall T: G (S,T)$.   We say that $S$ can 
%  \end{definition} 
For each $D \in \mathcal{D}$ there is an associated  partial function $$\widetilde{S} _{D}: \mathcal{T} ^{\pm}  \times \mathbb{N} \to Strings \times \{\pm\},  $$ defined via the following meta-algorithm,  which is a computational algorithm if $D$ is a Turing machine.
% First print $$S _{1} (T,1) = O _{1}:= (D_1 \circ R \circ  \widetilde{T}, T,+).$$ Next 
\begin{itemize}
   \item Let $L$ be initialized as an empty set, which as before as an ordered list of instructions. Also initialize $n:=0$, and let $T \in \mathcal{T} ^{\pm} $ be given.
\item Start. If $$D _{S} (T,n) = (O,+) \in \mathcal{U} \times \{\pm\} \text{ and $O \neq \mathcal{G}$}$$  then add $ (O,-) $ and $(\mathcal{G},+) $ to $L$.  If $O = \mathcal{G}$ then add $(O,-)$. 
If $$D _{S} (T,n) = (\hbar,+) $$ then
then  add $(\mathcal{G},+)$ to $L$.
If $$D _{S} (T,n) = (\hbar,-) $$ then
add $(\mathcal{G},-)$ to $L$. Finally, if $D _{S} (T,n)  $ is undefined then do nothing.
\item Set $n:=n+1$ go to Start and continue.
\end{itemize}

% for each element $e$ of $\widetilde{S}(T) $ of the form $(O _{e} ,+) \in Strings \times \{\pm\}$, 
% add $(O _{e},- )$.



% The resulting list $L$, in the order that they are added, to get a partial function $$\widetilde{S} ^{n}  (T): \mathbb{N} \to Strings \times \{\pm\},
% $$ whose range is $U$.

The above determines a partial function $\widetilde{S} _{D} $, whose value $\widetilde{S} _{D}  (T,m) $ is the $m$'th (not necessarily final) element of the list $L ^{m} $, which is $L$ after the $m$'th iteration of the meta-algorithm.  Unless $L ^{m} $ does not have at least $m$ elements in which case we set $\widetilde{S} (T,m) $ to be undefined.

To summarize informally in terms of our physical $S$: if $S$ perceives that some $O \neq \mathcal{G}$ is 
$(T,T)$-stable then $\widetilde{S}=\widetilde{S} _{D _{S} }  $ satisfies that 
$O$ is not $(\widetilde{S},T) $-stable, and so that $\mathcal{G}$ is $(\widetilde{S},T) $-stable. If $S$ perceives that $\mathcal{G}$ $(T,T)$-stable then $\widetilde{S}$ satisfies that $\mathcal{G}$ is not $(\widetilde{S},T) $-stable. 
If $S$ perceives that no $O$ is $(T,T)$-stable then again $\mathcal{G}$ is $(\widetilde{S},T) $-stable. 
Finally if $D _{S} $ does not stably decide $\mathcal{P} (T)$ then no $O$ is $(\widetilde{S}, T) $-stable. 

% By ``determine'' we just mean that $S$ prints values $\widetilde{S} (T) (n)$ (they can be undefined), for each $n$, so that the limit function $\widetilde{S} (T)$ would satisfy the above properties.  
% Note that if $S$ can stably decide problem $\mathcal{P} (T)$ then we may assume that $\widetilde{S} (T) $ is undefined for all $n$ sufficiently large.
% Also note that by the above conditions if $sound-GH (S,T)$ then by construction $\neg \Theta ^{s} _{\widetilde{S},T }$, and so 
% $$\Theta _{\widetilde{S},T } \implies s-sound (T,T)$$ and so $s-sound (\widetilde{S},T)$.
% So this is consistent with the above defining property of each $S _{n} (T,n) $.  
% We call the above property of a string $O$ $n-sC (S,T)$. And we say that $O$
% is $\infty-sC (S,T)$ if it is $n-sC (S,T)$ for all $n$.
% Note that $S _{\infty} (T) = \widetilde{S} (T)$ if $S _{n} (T) $ is defined for arbitrarily large $n$. While if  or $S _{\infty} (T)$
% This machine $\widetilde{S} $ is now defined. In principle, depending on the properties of the physical $S$. In other words, to say exactly what the term $S$ means in set theory we need to discover the physical principles underlying $S$ as well as all the necessary initial conditions. (Which of course is completely impossible in practice.) 

The following is immediate by construction:
\begin{proposition} \label{thm:2} 
% \begin{equation*}
% S \text{ is computable } \land s-sound ({S},T). 
% \end{equation*}
% In fact, for any $ {M'} \in \mathcal{T} ^{\pm} $:
For $\widetilde{S} _{D}  $ as above and for any $T \in \mathcal{T} ^{\pm}$
\begin{equation*}
      \neg \Theta ^{s} _{\widetilde{S} _{D}, T}  \lor  \neg (\text{$D  $ stably soundly decides $\mathcal{P}(T)$}).
\end{equation*}
% In particular if our physical $S$ is computable, they cannot be fundamentally sound,  specifically meaning stably sound.
\end{proposition} 


As a consequence we have:
\begin{theorem} There is no computable $D \in \mathcal{D}$ that  stably soundly decides $\mathcal{P}$. 
\end{theorem}
\begin{proof} Suppose otherwise that there is such a $D$, then by the above proposition we obtain:
\begin{equation*} 
\forall T \in \mathcal{T} ^{\pm}:    \neg \Theta ^{s} _{\widetilde{S} _{D} , {T}},
\end{equation*}
but this is absurd since by construction $\widetilde{S} _{D}  $ is computable if $D$ is.
\end{proof}


% In addition, by construction if $s-sound (S)$ then $S$ has the following property.
% \begin{definition} We say that $M \in \mathcal{M} ^{\pm} $ has \textbf{\emph{the G\"odel property}} if $\mathcal{G}$ is $(M,T)$-stable for every $T \in \mathcal{T} ^{\pm} $, unless $\neg s-sound (T,T)$.
% In particular if the physical $S $ stably asserts $s-sound ({S})$ and is aware of the second half of Theorem \ref{thm:stablediagonalization} then the associated  $S \in \mathcal{M} ^{\pm} $ has property $P$, by the condition above.
% \end{definition} 
% \begin{lemma} The above $S$ has the G\"odel property.
% \end{lemma}
% \begin{proof} Suppose 
%    
% \end{proof}
% Concretely
% we assume that 
% if at some moment $n$, meaning after $S _{n-1} (T,n-1) $ is printed but before $S _{n} (T,n) $ is printed, $S$ has determined  that some $O$ is $(T,T)$-stable. Then $S$ prints $S _{n} (T,n) = (O,-) $, $S _{n+1} (T,n+1) = (\mathcal{G}, +) $, and stops there unless he later decides he needs to correct.
% In other words  This is consistent with 
% has property $\infty-sC (S,T)$, then $(O,+) \in \{S (T,n) \} _{n} $.
% Conversely, we suppose that if, while part of the above environment, $S$ asserts that $O$ has the property $$
% And conversely if $O$ is $(S,T)$-stable, then $S$ stably asserts that $O$ has property $sC (S,T)$. Here, ``stably asserts'', analogously to previous usage,  means that $S$ is never to change their mind on this. 
% \begin{definition} As before, we say that the physical $S$  is \textbf{\emph{computable}} if the corresponding machine ${S}$ above is computable.
% \end{definition}
% But construction $S$ must perceive:
% $$\forall T \in \mathcal{T} ^{\pm}: \Theta _{\widetilde{S},T} \implies s-sound (T,T).
% $$  And so $S$ perceives that if at any moment ($n$) he prints $\mathcal{G}$, then $\neg \Theta _{\widetilde{S},T}$ by Theorem \ref{thm:stablediagonalization}, so that 
% \begin{equation*}
%    \forall T \in \mathcal{T} ^{\pm}: \mathcal{G} \text{ has property $\infty-sC (S,T)$}.
% \end{equation*}
% %
% % \begin{equation}
% %   \forall T \in \mathcal{T} ^{\pm}: \Theta _{\widetilde{S},T} \implies (\mathcal{G} \text{ has property $sC (T,T)$}).
% % \end{equation}
% % % where $T _{n-1} (T) + \mathcal{G}$ is the partial function $\{0, \ldots, n\} \to Strings \times \{\pm\}$, extending $S _{n-1} $ defined by $S _{n-1} (T) + \mathcal{G} (n)= (\mathcal{G},+)$.
% % % \begin{definition}
% % % An abstract $O \in Strings$ \textbf{\emph{has property}} $sC (T)$, if the following holds.
% % % For any $N >0$, and any $M _{N} $ that has property $sC (T)$, if 
% % % $M _{N+1} $ is the partial function
% % % \begin{equation*}
% % %     M _{N+1} : \{0, \ldots, N+1\} \to Strings \times \{\pm\}, \quad g (N+1)=(O,+),
% % % \end{equation*}
% % % extending $M _{N}$, then  $M _{N+1} $ has property $sC (T)$.
% % % \end{definition}
% % %
% % :  $$\text{ if }  $O$ \text{ is stably $S _{n} (T)  $ printed}  $$ then given any abstract extension of $S _{n} (T) $ to a partial function
% % \begin{equation*}
% % S ^{ext} (T): \mathbb{N} \to Strings \times \{\pm\},
% % \end{equation*}
% % \begin{equation*}
% % \Theta _{S ^{ext},  T} \implies \text{$O$ has property $n-sC (T,T)$.
% % } \end{equation*}
% % for some $k$, then $S _{n+k} $ is defined to be $S _{n+k'} $ for any 
% % Let us call this property $sC (S _{n},T)$.
% % And we ask that $S$ is aware of Theorem \ref{thm:stablediagonalization}, so that as a consequence $S$ perceives that 
% % \begin{equation*}
% %    \forall T \in \mathcal{T} ^{\pm}: \Theta _{S,T} \implies \mathcal{G} \text{ has property $sC (T,T)$}.
% % \end{equation*}
% % But it is also clear that:
% Then by our assumptions this is the same as $S$ having stable Penrose property, defined as follows.
% \begin{definition} We say that $M \in \mathcal{M} ^{\pm} $ has \textbf{\emph{the stable Penrose property}} or just \textbf{\emph{Penrose property}} for short, if $\mathcal{G}$ is $(M,T)$-stable for every $T \in \mathcal{T} ^{\pm} $.
% % In particular if the physical $S $ stably asserts $s-sound ({S})$ and is aware of the second half of Theorem \ref{thm:stablediagonalization} then the associated  $S \in \mathcal{M} ^{\pm} $ has property $P$, by the condition above.
% \end{definition} 
% We would like to say that we have deduced that $S$ must have the Penrose property. But this is not the really the case, the above ``deduction'' is in a subtle sense self referential. For the physical $S$ first claims that he constructs  $\widetilde{S} $ having a certain property (which by itself is not self referential), but then he assumes that $\widetilde{S} $ having these properties is already constructed, in constructing $\widetilde{S} $. 
% This author does not believe the Penrose property can be deduced from some fixed elementary principles. And probably this is impossible since otherwise $T$ could presumably do the same! But on the other hand it is an intuitively plausible axiom for what it means to be human. After all $s-sound (T,T)$ or not, this is fixed, and if $T$ computes $S$ then $S$ believing $s-sound (T,T)$ is reasonable.
%
% We suppose from now on that $S$ has property $P$.
% In this case given any input $T = (B,m)$, given the chosen computation $D_0 (T) = (X, \Sigma _{1} ) $ and given the wait time $t ^{W} >0 $,  if the computation $* X (\Sigma _{1} )$ does not halt in time $t ^W $ he prints $(X, \Sigma _{1}, 1)$ in any time less then $t ^{W}  $. More specifically,
% the time to answer of $D_1 (\infty) $ is less than $t ^{W} $.  
% \begin{remark}
% Technically, for our results, we don't need the list $\{S (T,m)\} _{n} $ to be complete in the sense above. We only need that this list contains a particular string. 
%    \end{remark} 
% Conversely if $S (T,m) = (O, +)$ for some $m$ then at some point the physical $S$ asserts that $O$ has property $sC (S,T)$. Similarly,
% if the physical $S$, after at some point asserting that $O$ has property $sC (S,T)$, later asserts that it does not, then  $$  S ({T},m)=(O, -)  $$ for some $m>k$, where  Conversely if $S (T,m) = (O, -)$ for some $m$ then at some point the physical $S$ asserts that $O$ does not have property $sC (S,T)$.
% We further examine this property below.
% The following theorem is an immediate consequence of Theorem \ref{thm:stablediagonalization}. 
% That said our idealization is very tame, for if $S$ is computable then for our purpose we may ``replace him'' by a physical computer $IS$. This $IS$ could then be understood as the idealized $S$, at least pretending that computers do not deteriorate. Then applying the theorem to $IS$, we get that $IS$ is not stably sound, since it is of course computable. 
% \begin{theorem} \label{thm:2} 
% % \begin{equation*}
% % S \text{ is computable } \land s-sound ({S},T). 
% % \end{equation*}
% % In fact, for any $ {M'} \in \mathcal{T} ^{\pm} $:
% For $S$ as above and for any $S' \in \mathcal{T} ^{\pm}$
%    \begin{equation*}
%       \neg (\Theta ^{s} _{\widetilde{S} , {S'}}  \land   sound-GH (S,S')).
% \end{equation*}
% % In particular if our physical $S$ is computable, they cannot be fundamentally sound,  specifically meaning stably sound.
% \end{theorem} 
% If we define a \emph{human} as a subject whose associated partial function $S$ has the stable Penrose property then this formalizes Theorem \ref{thm:1}. \footnote {This very limited definition is of course only for the purposes of our theorem. 
% } 
% \subsection {Examining the Penrose property} \label{section:justify}
% This property is forced on our $S$ by our assumptions. But these assumptions are based on our notion of ``perceive'', which is limited. To see this, for simplicity let us go back to discussing $S$ in terms of statements in arithmetic they assert to hold, and as before we call this function as $$P: \mathbb{N} \to \mathcal{A} \times \{\pm\}, $$ for $\mathcal{A}$ sentences of arithmetic. Suppose then that the life of $S$ is terminated. Then if $P (n) = (O,+)$ is the last output of $P$, $O$ by our definition is $P$-stable. So that by our definition $S$ perceives $O$ as true, which is perhaps not what one ideally expects. And this makes the implication of our Theorem \ref{thm:2} weaker, since in this case clearly what $S$ perceives to be true may not be true, so that there is no surprise that $S$ is not fundamentally sound.
% % It remains to explain however how property $P$ is justified. The interpretation of this for a given $S$ is that such a human perceives that the list of certain mathematical statements, that they assert to be true, converges in the exact sense above to a list of things which are actually true.  For example I assert in absolute faith $L$: $5$ is an odd number. This statement $L$ is likely stably on my list, unless I would have lost my sanity and hence would no longer be me. On the other hand, the statement $0=1$ should not be stably on my list.  % A non idealized $S$ can have the stable Penrose property, and rationally so, if they were extremely conservative. As an extreme example let us say they assert only $L$ and $\mathcal{G}$ and then retire.
% % Note that it can be rational for a non-idealized $S$ to assert their soundness, provided they stopped making statements before loin particular to have the stable Penrose property, if they are very conservative. For example let's say $S$ asserts only $L$.
%
% To make further sense of this, we could idealize our $S$ so that their brain is not subject to deterioration. But then we have to understand the implications of our theorem for idealized $S$, for non-idealized $S$. In principle this shouldn't be a problem, as because this particular intended idealization is straightforward, we can imagine a physical process of idealization that does not magically introduce non-computability in the limit, where the was none before.  But this discussion is outside our scope.
%
% % \begin{remark}
% % We only need to effectively idealize, this can mean for example that we can guarantee that all $(S,T)$-stable $O$, with generation number $m < N$, (the smallest $m$ so that $O = pr \circ S (T,m)$  have property $sC$.
% % We can then construct an effective version of our theory so that our argument can be adapted to apply to such a partial idealization, but this is outside our scope.  
% % \end{remark}
% Or we may say more concretely that the idealized human is represented by ``the evolving scientific community'' $H$, as we have already mentioned in the introduction. The fact that it is ``evolving'' because its members change (death/birth) presents no problems. If each individual human is Turing computable, then so is this $H$ itself understood as machine: 
% \begin{equation*}
% {H}: \mathcal{I} \to Strings \times \{\pm\},
% \end{equation*}
% where the output $H (I)$ is determined by, for example, majority consensus.
% % Each $H (T,m)$ does \emph{not} need to be printed in ``absolute faith'',  since we allow latter corrections.
% On the other hand, by the same discussion as before $H$ must perceive:
% $$\forall T \in \mathcal{T} ^{\pm}: \Theta _{H,T} \implies s-sound (T),$$
% % $H$ makes a preliminary assertion $s-sound (H)$, and so $$\forall T: (\exists m _{T} : H (T,m _{T} ) = (\mathcal{G},+)).
% % $$ Moreover, 
% % $$\exists (m > m _{T}): H (T,m ) = (\mathcal{G},-),$$
% % only if $H$ discovers \footnote {Discovering your own unsoundness is possibly paradoxical, but since we argue that it cannot happen anyway, we will not elaborate.} at a later time that $\neg s-sound (H)$. So if this does not happen $\mathcal{G}$ will be $(H,T)$-stable for all $T$. 
% % In other words we postulate 
% or more concretely $H$ has the Penrose property.
% % \begin{remark}
% %    Note that property $P$ is completely safe, in the sense that if $s-sound (H)$ then $s-sound (H ^{+} )$ where $H ^{+}$ is machine $H$ formally extended to have property $P$, simply by adding $\mathcal{G}$ to its stable output list. In other words $H$ cannot ``make itself unsound'' by stably printing $\mathcal{G}$. Then only thing that changes with property $P$ is whether or not $H$ can be computable.
% % \end{remark}
% % \footnote {$H$ knowing that $H$ is unsound is indeed very paradoxical. Concretely, for us, this just means $H$ removes $\mathcal{G}$ from its list.}   
% Then we may apply Theorem \ref{thm:2} above to this $H$, which then formalizes Theorem \ref{thm:1}.  
% \begin{remark} A perhaps trivial remark. Note that if $\Theta _{H,H'} $ 
% then $s-sound (H')$ or $\neg s-sound (H')$ independently of whether $H$ has property $P$, as $H'$ already knows what $H$ will do. In other words $H$ cannot make itself stably unsound by having property $P$, he is either already 
%    So if $s-sound (H')$ and property $P$ then we 
%
%    and so $\neg s-sound (H)$, then this is happens independently of $H$ having property $P$. That is to say the physical $H$ cannot save itself from being unsound by choosing to be conservative and not stably printing $\mathcal{G}$, its nature $H'$ is already determined. In this sense property $P$ is benign.
% \end{remark}
% \begin{proof} [Proof of Theorem \ref{thm:2}] Suppose $\Theta ^{s}  _{{S}, S'} \land sound-GH (S,S')$ for some $ {S}' \in \mathcal{T} ^{\pm}  $.
% Then by the defining properties of $\widetilde{S} $ and by $sound-GH (S,S')$, $\mathcal{G}$ is $(\widetilde{S} ,S')$-stable unless $S$ perceives that $\mathcal{G}$ is $(S',S')$-stable.
% In the latter case, it follows that $\neg s-sound (S',S')$ by Theorem \ref{thm:stablediagonalization}. But then $\neg s-sound (S,S')$ by $\Theta _{S,S'} $, so we would have a contradiction. 
% So indeed $\mathcal{G}$ is $(S,S')$-stable, but then $\neg s-sound (S,S') 
% $ by Theorem \ref{thm:stablediagonalization}, so we still have a contradiction.
% % $pr \circ S ({S}',m)$ is $(S,S')$-stable: $$S ({S}',m) = \mathcal{G},
% %    $$ unless $\mathcal{G}$ is $S'$-stable. But in this case Theorem \ref{thm:stablediagonalization}
% \end{proof}
 \begin{definition}
We say that $\mathcal{A} (S)$ holds if for any $T \in \mathcal{T} ^{\pm} $ whenever it is true that no $O$ is $(T,T)$ stable, $\hbar$ is $(D _{S},T')  $-stable for some $T'$ satisfying: $T \simeq _{s} T'  $.  Therefore, $\neg \mathcal{A} (S)$ in particular means that there exists a $T \in \mathcal{T} ^{\pm} $ so that $\mathcal{H} (T)$: \begin{equation*} \text{no $O$ is $(T,T)$-stable}
\end{equation*}
is true but $S$ will never perceive it to be true.
%     In other words $S$ can determine the truth of the statement
%
%
%     $\widetilde{S} $ is computable,
% there exists $T \in \mathcal{T}$, with $T \simeq _{s} \widetilde{S}  $, such that if 
%
   \end{definition}
$\mathcal{A}(S)$ is of course implied by $S$ being able to perceive that a given Turing machine $$f: \mathbb{N} \to \mathbb{N} \times \{\pm\}$$ has no $f$-stable output if $f$ does not have $f$-stable output.
However, the condition of the definition above is likely weaker since for $T$ as above $T (T,\cdot)$ stably computes the partial function $$u: \mathbb{N} \to Strings \times \{\pm\},$$ which is nowhere defined. One can then hope, since $u$ is so simple, that $T$ can be put into a normal form $T'$ with $T \simeq _{s} T' $ and with $T' (T',\cdot) = u$ and so that $S$ can perceive that $T' (T',\cdot) = u$.

 The following formalizes Theorem \ref{thm:1}.
\begin{theorem} \label{thm:3} For $S,\widetilde{S} = \widetilde{S} _{D _{S} }   $ as above and for all $T \in \mathcal{T} ^{\pm} $: $$\neg (D _{S} \text{ is stably sound}) \land \Theta ^{s}  _{\widetilde{S},T} \land \mathcal{A} (S)).
$$ 
\end{theorem} 
\begin{proof} If $D _{S}$ is stably sound then in particular
$s-sound (\widetilde{S})$ by construction.
Then if $T$ stably computes $\widetilde{S} $ no $O$ is $(T,T)$-stable since otherwise $\widetilde{S} $ has non-empty stable output, and by construction of $\widetilde{S} $ this can happen only if $\mathcal{G}$ is $\widetilde{S} $-stable, in which case $\neg s-sound (\widetilde{S} )$ by Theorem \ref{thm:stablediagonalization}.  

So if $\mathcal{A}(S)$ then for some $T'$ stably computing $\widetilde{S} $ 
$\hbar$ is $D _{S} (T') $-stable and so
by construction of $\widetilde{S} $  $\mathcal{G}$ is $(\widetilde{S}, T') $-stable. But then $\mathcal{G}$ is $(T,T)$-stable which is a contradiction.  
\end{proof}
% \section {A seemingly trivial decision problem} 
% We now explain that if  $sound-GH (S)$  then $\mathcal{P} (S)$ is a trivial problem. For suppose $\Theta ^{s}  _{\widetilde{S},T''} $ for some $T'' \in \mathcal{T} ^{\pm}  $ then the stabilization $\{\widetilde{S} (T'') ^{s} (n)\} _{n}= \emptyset  $, that is $\widetilde{S} (T'') ^{s}  $ must be the totally undefined partial function $u$. For otherwise, by the defining properties of $\widetilde{S} (T'') $, we have $sound-GH (S,T'')$ which as mentioned implies $\neg \Theta ^{s}  _{\widetilde{S},T''} $. 
%
% Now, since $\widetilde{S} (T'') ^{s} =u  $ it seems likely we can define $T' \in \mathcal{T} ^{\pm} $ also stably computing $\widetilde{S} $ so that 
% $T' (T',n) := u (n)$. 
% % Otherwise $T' (T,n):= T'' (T,n)$. Clearly $T'$ is also a Turing machine and it stably computes $\widetilde{S} $. Moreover, $$O \text{ is }(T',T')-stable \iff O \text{ is }(T',T'')-\text{stable},$$
% If we can, then clearly $S$ can perceive that no $O$ \text{ is }$(T',T')$-stable, just by examining the specification of $T'$, and so $sound-GH (S)$.
% , so it would be highly implausible that $O$ cannot perceive that no $O$ is $(T,T')$-stable, and so implausible that $S$ cannot decide $\mathcal{P}(S)$.  
% We now reformulate 
% Observe also that by the discussion above if $H$
% \begin{remark} We had mentioned that $\mathcal{G}$ should be $(H,T)$-stable 
%   unless at some point $H$ discovers that it is unsound. This is indeed as paradoxical as it sounds. For if $H$ ``knows'' that it is unsound, it presumably knows specifically in what way it is unsound, and understand how to fix this issue, so that it is not actually unsound. Unless, $H$ 
% \end{remark}
% (After $S (T, n _{0} )$ is already printed, if $T$ computes $S$ then the computation $*T (T, n _{0} )$ must halt, and the value $T (T, n _{0} )$ can be empirically found by $S$.) 
% We will write more formally in the following section.
% \section {Formal system interpretation} \label{section:formalsystem}
% Let us fix our interpretation of an idealized human as $H$ from before, postulated to have the Penrose property. As before, we will say physical $H$ when we want to emphasize that we are talking of the physical thing representing the partial function $H$. Theorem \ref{thm:2}, allows us to conclude that if $H$ is computable then $H$ not stably sound. Under the computability assumption, the one string $\mathcal{G}$ that $H$ is guaranteed to stably print, which expresses stable unsoundness of $H$, while elementary is slightly esoteric. Can we see more clearly that $H$ is stably unsound? Yes, but we need stronger assumptions, and some language of formal systems. This section can be safely omitted as it is only of secondary interest.
%
% For simplicity we will base everything of standard set theory $\mathcal{ST}$ (Zermelo-Fraenkel axioms). Turing machines, and arithmetic are assumed to be naturally formalized in $\mathcal{ST}$. 
% In what follows, for a statement $L$, $\mathcal{F} \vdash L$ means that $L$ is provable in the formal system $\mathcal{F}$.
%
% Let $\mathcal{A}$ denote the set of sentences of arithmetic, as formalized by $\mathcal{ST}$. Let
% \begin{equation*} P: \mathbb{N} \to  \mathcal{A} \times \{+, -\},
% \end{equation*}
% be the machine associated to the physical $H$, analogously to the previous discussion, and as in the preamble to Section \ref{section:fundamentalSoundness}.
% \begin{definition}
%   We will say that the physical $H $ \textbf{\emph{is captured by a formal system}} $\mathcal{F}  \supset \mathcal{ST}$ if the following are satisfied:
% \begin{enumerate}
% \item  For any $T \in \mathcal{T} ^{\pm} $:
% \begin{equation*}
%    (O \text{ is $(H,T)$-stable}) \iff \mathcal{F} \vdash (O \text{ has property } sC (H,T)).
% \end{equation*}
% % The right hand side only makes sense after the partial function $S$ has been  given a set theoretic, or $\mathcal{F}$ theoretic construction. So existence of such a construction is part of the hypothesis. But we do not ask that this construction is known to the physical $S$.
% \item  
% \begin{equation*}
%    (A \in \mathcal{A} \text{ is $P$-stable}) \iff \mathcal{F} \vdash A.
% \end{equation*}
% \end{enumerate}
% \end{definition}
% We will suppose from now on that the physical $H$ accepts $\mathcal{ST}$  as sound, meaning more specifically that $H$ perceives its theorems as true, where the meaning of this is as in previous sense. 
% In this case a formal system $\mathcal{F}$ in the language of set theory, that captures $H$, always exists. We may simply define $\mathcal{F} (H)$ capturing $H$, by adding to $\mathcal{ST}$ as axioms the $P$-stable statements, and adding as an axiom, for each $O$ $(H,T)$-stable, the statement:
% \begin{equation*}
% \text{$O$ has property $sC (H,T)$.}
% \end{equation*}
%  The resulting formal system $\mathcal{F} (H)$ is in fact minimal, in the sense that any other $\mathcal{F}$ which captures $H$ contains $\mathcal{F} (H)$.
% \footnote {$\mathcal{F} (H)$ may not however be recursively axiomatized, cf.
%  Remark \ref{remark:stable}, but this is not relevant to our present discussion.} 
% Let $Con (H)$ denote the statement:
% \begin{equation*}
%    \exists \mathcal{F}: (\mathcal{F} \supset \mathcal{ST} \text{ s.t. $\mathcal{F}$ captures $H$}) \land  (\text {$\mathcal{F}$ is consistent}).
% \end{equation*}
% This is of course equivalent to the condition that $\mathcal{F} (H)$ is consistent by the above discussion.
% % We suppose that $\mathcal{F} (S)$ contains standard set theory, enough so that Turing machines can be formalized.  
% % In what follows by ``provably'' we mean provably in $\mathcal{ST}$. 
% % (Or we can say that there is a model of Turing machines in the sense of model theory, and $S$ accepts this model.) 
% \begin{theorem} \label{thm:negCon} Let $H $ be as above then:
% \begin{equation*}
%  \mathcal{ST} \vdash (\exists H' \in \mathcal{T} ^{\pm}: 
%  \Theta _{H, H'})  \implies \neg Con (H).
% \end{equation*} 
% In other words if $H$ is provably computable then they are not consistent. 
% \end{theorem}
%  Note that the statement: $$\mathcal{ST} \vdash (\exists H' \in \mathcal{T} ^{\pm}: 
%  \Theta _{H, H'})$$ does not mean that the physical $H $ can prove the statement $M$:
% \begin{equation} \label{eq:M}
% \exists H' \in \mathcal{T} ^{\pm}: 
%  \Theta _{H, H'}
% \end{equation}
%   in the practical sense. It just means that after the term $H$ in the statement $\Theta _{H, H' } $ has been suitably interpreted in set theory $\mathcal{ST}$, $M$ is provable in $\mathcal{ST}$.  But a set theoretic, in other words mathematical, interpretation of the term $H$ may not be practically attainable. At the least this necessitates detailed knowledge of the physics and biology underlying our humans. And even if this interpretation was attainable, $H$ may not be clever enough to find the proof of $M$, again in the practical sense. Also note that $\neg Con (H)$ expresses \emph{fundamental} inconsistency of $H$, as we only take stable assertions of $H$ above.  
%  \begin{example} \label{example:0=1} Suppose that $H$ is provably computable as in the hypothesis of the theorem above. Then $\mathcal{F} (H)$ captures $H$ and $\neg Con (\mathcal{F} (H))$ by the theorem, and so $\mathcal{F} (H)$ proves $0=1$. Since $\mathcal{F} (H)$  captures $H$, the physical $H$ must \emph{stably} assert $0=1$.
% \end{example}
% \begin{proof}[Proof of Theorem \ref{thm:negCon}]
%  Let $\mathcal{F} $ capture $H$ as above. By the proof of the second part of Theorem \ref{thm:2}:
% \begin{equation*}
%    \mathcal{ST} \vdash (M \implies L),
% \end{equation*}
% where 
%    $L$ is: 
% \begin{align*}
% \exists m \in \mathbb{N}, \exists H' \in \mathcal{T} ^{\pm}: (pr \circ H    (H',m) \text{ is defined and is $(H,H')$-stable}) \land \\ \neg (pr \circ H (H',m) \text{ has property $sC (H, H' )$}),
% \end{align*}
% and where $M$ is as in \eqref{eq:M}.
%
%    So
% \begin{equation*}
%    (\mathcal{ST} \vdash M) \implies (\mathcal{ST} \vdash L) \implies (\mathcal{F} \vdash L),
% \end{equation*}
%
% On the other hand, by the assumption that $H $ is captured by $\mathcal{F}$:
% \begin{align*}
% \mathcal{F} \vdash
%    (\forall m \in \mathbb{N}, \forall H' \in \mathcal{T} ^{\pm}: (pr \circ H    (H',m) \text{ is defined and is $(H,H')$-stable}) \implies \\ (pr \circ H (H',m) \text{ has property $sC (H, H' )$})).
% \end{align*}
% So $\mathcal{F} \vdash \neg L$.
% \end{proof}
% Let now $S$ be as in Section \ref{}, so is not assumed to have property $P$. $\mathcal{F} (S)$ will denote the formal system constructed analogously to $\mathcal{F} (H)$ as above.
% Let us now slightly relax definition 
% \begin{definition}
% We say that $M \in \mathcal{M} ^{\pm} $ \textbf{\emph{is captured by a formal system}} $\mathcal{F}  \supset \mathcal{ST}$ if 
% for any $T \in \mathcal{T} ^{\pm} $:
% \begin{equation*}
%    (O \text{ is $(M,T)$-stable}) \iff \mathcal{F} \vdash (O \text{ has property } sC (M,T)).
% \end{equation*}
% % The right hand side only makes sense after the partial function $S$ has been  given a set theoretic, or $\mathcal{F}$ theoretic construction. So existence of such a construction is part of the hypothesis. But we do not ask that this construction is known to the physical $S$.
% \end{definition}
%
% \begin{theorem} If $\mathcal{F}$ captures $S$ and is sound, and if $\Theta _{S,S'} $ then 
%   \begin{align}
%  & \forall m \in \mathbb{N}: \neg (\mathcal{F}  \vdash (*S' (S',m) \text{ does not halt.})) \\ \label{eq:1F}
%   &   \forall m \in \mathbb{N}, \forall O \in Strings: \neg (\mathcal{F} (S) \vdash (S' (S',m) = O)). \label{eq:2F}
%   \end{align} 
% \end{theorem}
% This formalizes the discussion of Section \ref{}.
% % In other words the physical $S$ cannot soundly determine any values $S' (S',m)$ nor if $*S' (S',m)$ halts. 
% \begin{proof} Suppose otherwise, then for some $m \in \mathbb{N}$ either 
% \begin{equation*}
% \mathcal{F}  \vdash (*S' (S',m) \text{ does not halt.}),
% \end{equation*} or for some $m,O _{m} $:
%    \begin{equation*} \mathcal{F} (S) \vdash (S' (S',m) = O _{m} ).
% \end{equation*}
% In either case 
% \begin{equation*}
% \mathcal{F}  \vdash \text{ $O$ has property $sC (S,S')$, for all $O \in \mathcal{O}$ s.t.    } 
% \end{equation*}
%
%    $$
%    so that either \eqref{eq:1F}, or \eqref{eq:2F}. Then 
%
% \end{proof}

\section{Relationship with the G\"odel and Penrose argument} \label{section:Penrose}
The most lucid criticism of G\"odel and Penrose arguments known to me appears in Koellner~\cite{citeKoellner2018-KOEOTQ-3}, \cite{citeKoellnerII2018-KOEOTQ-4}. Our argument is a certain significant extension of G\"odel's argument, although we are also inspired by the ideas of Penrose. An important point is that our argument is entirely based on set theory, while G\"odel's argument has meta-logical elements that require interpretation. Although,  as Koellner explains \cite{citeKoellnerII2018-KOEOTQ-4}, G\"odel's argument can also be at least in some sense fully formalized.

% the reason that the argument of Penrose is susceptible criticism is that it is only a meta-argument, meaning principally that it partly relies on interpretation of truth and knowledge. In other words, it is not written as a proof in some formal system, even implied one.  And there may be logical subtleties to interpretation of truth that a non-logician such as myself or Penrose may simply miss. 
% So what of the main argument of this paper? 
% Here the situation is rather different. With the possible exception of the inessential Section \ref{section:formalsystem}, where we touch on some logic, our theorems are in fact theorems of set theory, just classical Zermelo-Fraenkel set theory. For example our G\"odel string $\mathcal{G}$ for a stably $C$-sound $M$ is proved in set theory to have property $sC$. In contrast, in  \cite{citePenroseBeyondShadow} Penrose asserts the truth of a certain analogously used G\"odel statement by a meta-proof. And this is partly what is contested by Koellner. 
% So essentially instead of arguing
% in terms of truth of some sentences, we argue in terms of set theoretic properties of certain objects. This makes our argument more concrete.
% \footnote {As far as I can see the version of the Penrose argument I give in the introduction is free of the particular objection intended by Koellner, but this is a red herring since I don't propose it as an actual argument.} 
This is not to say that there are no issues of interpretation in this paper.  One must interpret our definition of stable soundness as it applies to actual human beings. We of course have already partly addressed this. At least under the previously explained assumption of weak idealization, stable soundness seems to be a very compelling hypothesis.
% For the moment my position is that the idealized human being of this paper is represented by the world scientific community $H$ (considered as evolving). And our theorem can be interpreted to directly apply to this $H$.  

It is always the case that we must interpret mathematical theorems when applied to the real world. What one looks for is whether there is any meaningful physical obstruction to carrying out the necessary idealization in principle. In our specific case I see no such obstruction. 
Of course if the universe and humanity must eventually go extinct then our weakly idealized humans cannot even in principle exist. But to me this is not a meaningful obstruction. The potential mortality of the universe is very unlikely to have any causal relation with computability of intelligence. So we can imagine an eternal universe and a weakly idealized human, run the argument then translate to our universe.
\section{Concluding remark} While it can be argued that humans are not sound,  it would be very difficult to argue that we are not stably sound.  Scientists operate on the unshakeable faith that scientific progress converges on truth. And our interpretation above of this convergence as stable soundness is very simple and natural. So the only thing to reasonably wonder is whether there could such a stably undecidable arithmetic statement of the form $\mathcal{H} (T)$ above. To this author this seems unlikely, precisely because stable soundness is such a loose assumption, and mathematicians are so good at creating increasingly more powerful formal systems. However such a discussion is outside our scope. 
% VIn addition, at least under the stronger hypothesis of Theorem \ref{thm:negCon}, stable unsoundness is testable/observable, at least in principle. 
% For if $H$ is provably computable as in Example \ref{example:0=1} then $H$  must eventually \emph{stably}  assert $0=1$.  If we knew in addition that a given $H'$ computes $H$ then, as $H'$ is a Turing machine, we can simulate it on a powerful computer and see if such non-sense statements really do appear. Given our basic understanding of humanity, such a possibility seems too ridiculous. 
\subsection*{Acknowledgements} Dennis Sullivan, Bernardo Ameneyro Rodriguez, David Chalmers, and in particular Peter Koellner for comments and helpful discussions.
% Bibliography
% \bibliography{pnas-sample}
%  \printbibliography
\bibliographystyle{siam}  
%  \bibliography{/root/texmf/bibtex/bib/link} 
   \bibliography{/home/yashasavelyev/texmf/bibtex/bib/link} 
\end{document}
